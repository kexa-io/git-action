/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { createHttpPoller } from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlResources operations. */
export class SqlResourcesImpl {
    /**
     * Initialize a new instance of the class SqlResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the SQL databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlDatabases(resourceGroupName, accountName, options) {
        const iter = this.listSqlDatabasesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlDatabasesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlDatabasesPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlDatabasesPagingPage_1() {
            let result;
            result = yield __await(this._listSqlDatabases(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlDatabasesPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listSqlDatabasesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlDatabasesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listSqlContainers(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listSqlContainersPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlContainersPagingPage_1() {
            let result;
            result = yield __await(this._listSqlContainers(resourceGroupName, accountName, databaseName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlContainersPagingAll(resourceGroupName, accountName, databaseName, options) {
        return __asyncGenerator(this, arguments, function* listSqlContainersPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listClientEncryptionKeysPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listClientEncryptionKeysPagingPage_1() {
            let result;
            result = yield __await(this._listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options));
            yield yield __await(result.value || []);
        });
    }
    listClientEncryptionKeysPagingAll(resourceGroupName, accountName, databaseName, options) {
        return __asyncGenerator(this, arguments, function* listClientEncryptionKeysPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlStoredProceduresPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlStoredProceduresPagingPage_1() {
            let result;
            result = yield __await(this._listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlStoredProceduresPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return __asyncGenerator(this, arguments, function* listSqlStoredProceduresPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlUserDefinedFunctionsPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlUserDefinedFunctionsPagingPage_1() {
            let result;
            result = yield __await(this._listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlUserDefinedFunctionsPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return __asyncGenerator(this, arguments, function* listSqlUserDefinedFunctionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlTriggersPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlTriggersPagingPage_1() {
            let result;
            result = yield __await(this._listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlTriggersPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return __asyncGenerator(this, arguments, function* listSqlTriggersPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlRoleDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listSqlRoleDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlRoleDefinitionsPagingPage_1() {
            let result;
            result = yield __await(this._listSqlRoleDefinitions(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlRoleDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listSqlRoleDefinitionsPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlRoleAssignments(resourceGroupName, accountName, options) {
        const iter = this.listSqlRoleAssignmentsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listSqlRoleAssignmentsPagingPage_1() {
            let result;
            result = yield __await(this._listSqlRoleAssignments(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listSqlRoleAssignmentsPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listSqlRoleAssignmentsPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Lists the SQL databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlDatabases(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlDatabasesOperationSpec);
    }
    /**
     * Gets the SQL database under an existing Azure Cosmos DB database account with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getSqlDatabase(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getSqlDatabaseOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    createUpdateSqlDatabaseParameters,
                    options
                },
                spec: createUpdateSqlDatabaseOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlDatabaseAndWait(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: deleteSqlDatabaseOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteSqlDatabaseAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the SQL database under an existing Azure Cosmos DB database account with
     * the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getSqlDatabaseThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL database.
     * @param options The options parameters.
     */
    beginUpdateSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    updateThroughputParameters,
                    options
                },
                spec: updateSqlDatabaseThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL database.
     * @param options The options parameters.
     */
    beginUpdateSqlDatabaseThroughputAndWait(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateSqlDatabaseToAutoscaleOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToAutoscaleAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateSqlDatabaseToManualThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToManualThroughputAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listSqlContainers(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listSqlContainersOperationSpec);
    }
    /**
     * Gets the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, getSqlContainerOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    createUpdateSqlContainerParameters,
                    options
                },
                spec: createUpdateSqlContainerOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlContainerAndWait(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: deleteSqlContainerOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginDeleteSqlContainerAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    getSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, getSqlContainerThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL container.
     * @param options The options parameters.
     */
    beginUpdateSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    updateThroughputParameters,
                    options
                },
                spec: updateSqlContainerThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL container.
     * @param options The options parameters.
     */
    beginUpdateSqlContainerThroughputAndWait(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToAutoscale(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: migrateSqlContainerToAutoscaleOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToAutoscaleAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlContainerToAutoscale(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToManualThroughput(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: migrateSqlContainerToManualThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToManualThroughputAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlContainerToManualThroughput(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listClientEncryptionKeysOperationSpec);
    }
    /**
     * Gets the ClientEncryptionKey under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param options The options parameters.
     */
    getClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            clientEncryptionKeyName,
            options
        }, getClientEncryptionKeyOperationSpec);
    }
    /**
     * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
     * Powershell (instead of directly).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
     *                                                  key.
     * @param options The options parameters.
     */
    beginCreateUpdateClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    clientEncryptionKeyName,
                    createUpdateClientEncryptionKeyParameters,
                    options
                },
                spec: createUpdateClientEncryptionKeyOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
     * Powershell (instead of directly).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
     *                                                  key.
     * @param options The options parameters.
     */
    beginCreateUpdateClientEncryptionKeyAndWait(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlStoredProceduresOperationSpec);
    }
    /**
     * Gets the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    getSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            storedProcedureName,
            options
        }, getSqlStoredProcedureOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL storedProcedure
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
     *                                                 storedProcedure.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    storedProcedureName,
                    createUpdateSqlStoredProcedureParameters,
                    options
                },
                spec: createUpdateSqlStoredProcedureOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL storedProcedure
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
     *                                                 storedProcedure.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlStoredProcedureAndWait(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL storedProcedure.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    beginDeleteSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    storedProcedureName,
                    options
                },
                spec: deleteSqlStoredProcedureOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL storedProcedure.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    beginDeleteSqlStoredProcedureAndWait(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlUserDefinedFunctionsOperationSpec);
    }
    /**
     * Gets the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    getSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            userDefinedFunctionName,
            options
        }, getSqlUserDefinedFunctionOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL userDefinedFunction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
     *                                                     userDefinedFunction.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    userDefinedFunctionName,
                    createUpdateSqlUserDefinedFunctionParameters,
                    options
                },
                spec: createUpdateSqlUserDefinedFunctionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL userDefinedFunction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
     *                                                     userDefinedFunction.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlUserDefinedFunctionAndWait(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    beginDeleteSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    userDefinedFunctionName,
                    options
                },
                spec: deleteSqlUserDefinedFunctionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    beginDeleteSqlUserDefinedFunctionAndWait(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlTriggersOperationSpec);
    }
    /**
     * Gets the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    getSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            triggerName,
            options
        }, getSqlTriggerOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL trigger
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    triggerName,
                    createUpdateSqlTriggerParameters,
                    options
                },
                spec: createUpdateSqlTriggerOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL trigger
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlTriggerAndWait(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL trigger.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    beginDeleteSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    triggerName,
                    options
                },
                spec: deleteSqlTriggerOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL trigger.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    beginDeleteSqlTriggerAndWait(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB SQL Role Definition with the given Id.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ roleDefinitionId, resourceGroupName, accountName, options }, getSqlRoleDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
     *                                                Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    roleDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateSqlRoleDefinitionParameters,
                    options
                },
                spec: createUpdateSqlRoleDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
     *                                                Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleDefinitionAndWait(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { roleDefinitionId, resourceGroupName, accountName, options },
                spec: deleteSqlRoleDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleDefinitionAndWait(roleDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlRoleDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlRoleDefinitionsOperationSpec);
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB SQL Role Assignment with the given Id.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ roleAssignmentId, resourceGroupName, accountName, options }, getSqlRoleAssignmentOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
     *                                                Assignment.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    roleAssignmentId,
                    resourceGroupName,
                    accountName,
                    createUpdateSqlRoleAssignmentParameters,
                    options
                },
                spec: createUpdateSqlRoleAssignmentOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
     *                                                Assignment.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleAssignmentAndWait(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { roleAssignmentId, resourceGroupName, accountName, options },
                spec: deleteSqlRoleAssignmentOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleAssignmentAndWait(roleAssignmentId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlRoleAssignments(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlRoleAssignmentsOperationSpec);
    }
    /**
     * Retrieves continuous backup information for a container resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, containerName, location, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    location,
                    options
                },
                spec: retrieveContinuousBackupInformationOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a container resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, databaseName, containerName, location, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, containerName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const listSqlDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlDatabaseListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlDatabaseGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlDatabaseGetResults
        },
        201: {
            bodyMapper: Mappers.SqlDatabaseGetResults
        },
        202: {
            bodyMapper: Mappers.SqlDatabaseGetResults
        },
        204: {
            bodyMapper: Mappers.SqlDatabaseGetResults
        }
    },
    requestBody: Parameters.createUpdateSqlDatabaseParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders
        },
        201: {
            headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders
        },
        202: {
            headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders
        },
        204: {
            headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    serializer
};
const getSqlDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const updateSqlDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const migrateSqlDatabaseToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const migrateSqlDatabaseToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listSqlContainersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlContainerListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlContainerGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlContainerGetResults
        },
        201: {
            bodyMapper: Mappers.SqlContainerGetResults
        },
        202: {
            bodyMapper: Mappers.SqlContainerGetResults
        },
        204: {
            bodyMapper: Mappers.SqlContainerGetResults
        }
    },
    requestBody: Parameters.createUpdateSqlContainerParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders
        },
        201: {
            headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders
        },
        202: {
            headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders
        },
        204: {
            headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    serializer
};
const getSqlContainerThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const updateSqlContainerThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const migrateSqlContainerToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const migrateSqlContainerToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listClientEncryptionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ClientEncryptionKeysListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getClientEncryptionKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ClientEncryptionKeyGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.clientEncryptionKeyName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateClientEncryptionKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.ClientEncryptionKeyGetResults
        },
        201: {
            bodyMapper: Mappers.ClientEncryptionKeyGetResults
        },
        202: {
            bodyMapper: Mappers.ClientEncryptionKeyGetResults
        },
        204: {
            bodyMapper: Mappers.ClientEncryptionKeyGetResults
        }
    },
    requestBody: Parameters.createUpdateClientEncryptionKeyParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.clientEncryptionKeyName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const listSqlStoredProceduresOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlStoredProcedureListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlStoredProcedureGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.storedProcedureName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlStoredProcedureGetResults
        },
        201: {
            bodyMapper: Mappers.SqlStoredProcedureGetResults
        },
        202: {
            bodyMapper: Mappers.SqlStoredProcedureGetResults
        },
        204: {
            bodyMapper: Mappers.SqlStoredProcedureGetResults
        }
    },
    requestBody: Parameters.createUpdateSqlStoredProcedureParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.storedProcedureName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        201: {
            headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        202: {
            headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        204: {
            headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.storedProcedureName
    ],
    serializer
};
const listSqlUserDefinedFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlUserDefinedFunctionListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.userDefinedFunctionName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
        },
        201: {
            bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
        },
        202: {
            bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
        },
        204: {
            bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
        }
    },
    requestBody: Parameters.createUpdateSqlUserDefinedFunctionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.userDefinedFunctionName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        201: {
            headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        202: {
            headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        204: {
            headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.userDefinedFunctionName
    ],
    serializer
};
const listSqlTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlTriggerListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlTriggerGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.triggerName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlTriggerGetResults
        },
        201: {
            bodyMapper: Mappers.SqlTriggerGetResults
        },
        202: {
            bodyMapper: Mappers.SqlTriggerGetResults
        },
        204: {
            bodyMapper: Mappers.SqlTriggerGetResults
        }
    },
    requestBody: Parameters.createUpdateSqlTriggerParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.triggerName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders
        },
        201: {
            headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders
        },
        202: {
            headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders
        },
        204: {
            headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName,
        Parameters.triggerName
    ],
    serializer
};
const getSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleDefinitionGetResults
        },
        201: {
            bodyMapper: Mappers.SqlRoleDefinitionGetResults
        },
        202: {
            bodyMapper: Mappers.SqlRoleDefinitionGetResults
        },
        204: {
            bodyMapper: Mappers.SqlRoleDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.createUpdateSqlRoleDefinitionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleDefinitionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listSqlRoleDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleDefinitionListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleAssignmentGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleAssignmentId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleAssignmentGetResults
        },
        201: {
            bodyMapper: Mappers.SqlRoleAssignmentGetResults
        },
        202: {
            bodyMapper: Mappers.SqlRoleAssignmentGetResults
        },
        204: {
            bodyMapper: Mappers.SqlRoleAssignmentGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.createUpdateSqlRoleAssignmentParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleAssignmentId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.roleAssignmentId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listSqlRoleAssignmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SqlRoleAssignmentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const retrieveContinuousBackupInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BackupInformation
        },
        201: {
            bodyMapper: Mappers.BackupInformation
        },
        202: {
            bodyMapper: Mappers.BackupInformation
        },
        204: {
            bodyMapper: Mappers.BackupInformation
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.location,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.containerName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
//# sourceMappingURL=sqlResources.js.map