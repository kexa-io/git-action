'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** Standard */
    KnownSkuName["Standard"] = "Standard";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link JobType} that the service accepts. */
exports.KnownJobType = void 0;
(function (KnownJobType) {
    /** Cloud */
    KnownJobType["Cloud"] = "Cloud";
    /** Edge */
    KnownJobType["Edge"] = "Edge";
})(exports.KnownJobType || (exports.KnownJobType = {}));
/** Known values of {@link OutputStartMode} that the service accepts. */
exports.KnownOutputStartMode = void 0;
(function (KnownOutputStartMode) {
    /** JobStartTime */
    KnownOutputStartMode["JobStartTime"] = "JobStartTime";
    /** CustomTime */
    KnownOutputStartMode["CustomTime"] = "CustomTime";
    /** LastOutputEventTime */
    KnownOutputStartMode["LastOutputEventTime"] = "LastOutputEventTime";
})(exports.KnownOutputStartMode || (exports.KnownOutputStartMode = {}));
/** Known values of {@link EventsOutOfOrderPolicy} that the service accepts. */
exports.KnownEventsOutOfOrderPolicy = void 0;
(function (KnownEventsOutOfOrderPolicy) {
    /** Adjust */
    KnownEventsOutOfOrderPolicy["Adjust"] = "Adjust";
    /** Drop */
    KnownEventsOutOfOrderPolicy["Drop"] = "Drop";
})(exports.KnownEventsOutOfOrderPolicy || (exports.KnownEventsOutOfOrderPolicy = {}));
/** Known values of {@link OutputErrorPolicy} that the service accepts. */
exports.KnownOutputErrorPolicy = void 0;
(function (KnownOutputErrorPolicy) {
    /** Stop */
    KnownOutputErrorPolicy["Stop"] = "Stop";
    /** Drop */
    KnownOutputErrorPolicy["Drop"] = "Drop";
})(exports.KnownOutputErrorPolicy || (exports.KnownOutputErrorPolicy = {}));
/** Known values of {@link CompatibilityLevel} that the service accepts. */
exports.KnownCompatibilityLevel = void 0;
(function (KnownCompatibilityLevel) {
    /** One0 */
    KnownCompatibilityLevel["One0"] = "1.0";
    /** One2 */
    KnownCompatibilityLevel["One2"] = "1.2";
})(exports.KnownCompatibilityLevel || (exports.KnownCompatibilityLevel = {}));
/** Known values of {@link EventSerializationType} that the service accepts. */
exports.KnownEventSerializationType = void 0;
(function (KnownEventSerializationType) {
    /** Csv */
    KnownEventSerializationType["Csv"] = "Csv";
    /** Avro */
    KnownEventSerializationType["Avro"] = "Avro";
    /** Json */
    KnownEventSerializationType["Json"] = "Json";
    /** Parquet */
    KnownEventSerializationType["Parquet"] = "Parquet";
})(exports.KnownEventSerializationType || (exports.KnownEventSerializationType = {}));
/** Known values of {@link CompressionType} that the service accepts. */
exports.KnownCompressionType = void 0;
(function (KnownCompressionType) {
    /** None */
    KnownCompressionType["None"] = "None";
    /** GZip */
    KnownCompressionType["GZip"] = "GZip";
    /** Deflate */
    KnownCompressionType["Deflate"] = "Deflate";
})(exports.KnownCompressionType || (exports.KnownCompressionType = {}));
/** Known values of {@link AuthenticationMode} that the service accepts. */
exports.KnownAuthenticationMode = void 0;
(function (KnownAuthenticationMode) {
    /** Msi */
    KnownAuthenticationMode["Msi"] = "Msi";
    /** UserToken */
    KnownAuthenticationMode["UserToken"] = "UserToken";
    /** ConnectionString */
    KnownAuthenticationMode["ConnectionString"] = "ConnectionString";
})(exports.KnownAuthenticationMode || (exports.KnownAuthenticationMode = {}));
/** Known values of {@link ContentStoragePolicy} that the service accepts. */
exports.KnownContentStoragePolicy = void 0;
(function (KnownContentStoragePolicy) {
    /** SystemAccount */
    KnownContentStoragePolicy["SystemAccount"] = "SystemAccount";
    /** JobStorageAccount */
    KnownContentStoragePolicy["JobStorageAccount"] = "JobStorageAccount";
})(exports.KnownContentStoragePolicy || (exports.KnownContentStoragePolicy = {}));
/** Known values of {@link ClusterSkuName} that the service accepts. */
exports.KnownClusterSkuName = void 0;
(function (KnownClusterSkuName) {
    /** The default SKU. */
    KnownClusterSkuName["Default"] = "Default";
})(exports.KnownClusterSkuName || (exports.KnownClusterSkuName = {}));
/** Known values of {@link ClusterProvisioningState} that the service accepts. */
exports.KnownClusterProvisioningState = void 0;
(function (KnownClusterProvisioningState) {
    /** The cluster provisioning succeeded. */
    KnownClusterProvisioningState["Succeeded"] = "Succeeded";
    /** The cluster provisioning failed. */
    KnownClusterProvisioningState["Failed"] = "Failed";
    /** The cluster provisioning was canceled. */
    KnownClusterProvisioningState["Canceled"] = "Canceled";
    /** The cluster provisioning was inprogress. */
    KnownClusterProvisioningState["InProgress"] = "InProgress";
})(exports.KnownClusterProvisioningState || (exports.KnownClusterProvisioningState = {}));
/** Known values of {@link JobState} that the service accepts. */
exports.KnownJobState = void 0;
(function (KnownJobState) {
    /** The job is currently in the Created state. */
    KnownJobState["Created"] = "Created";
    /** The job is currently in the Starting state. */
    KnownJobState["Starting"] = "Starting";
    /** The job is currently in the Running state. */
    KnownJobState["Running"] = "Running";
    /** The job is currently in the Stopping state. */
    KnownJobState["Stopping"] = "Stopping";
    /** The job is currently in the Stopped state. */
    KnownJobState["Stopped"] = "Stopped";
    /** The job is currently in the Deleting state. */
    KnownJobState["Deleting"] = "Deleting";
    /** The job is currently in the Failed state. */
    KnownJobState["Failed"] = "Failed";
    /** The job is currently in the Degraded state. */
    KnownJobState["Degraded"] = "Degraded";
    /** The job is currently in the Restarting state. */
    KnownJobState["Restarting"] = "Restarting";
    /** The job is currently in the Scaling state. */
    KnownJobState["Scaling"] = "Scaling";
})(exports.KnownJobState || (exports.KnownJobState = {}));
/** Known values of {@link Encoding} that the service accepts. */
exports.KnownEncoding = void 0;
(function (KnownEncoding) {
    /** UTF8 */
    KnownEncoding["UTF8"] = "UTF8";
})(exports.KnownEncoding || (exports.KnownEncoding = {}));
/** Known values of {@link JsonOutputSerializationFormat} that the service accepts. */
exports.KnownJsonOutputSerializationFormat = void 0;
(function (KnownJsonOutputSerializationFormat) {
    /** LineSeparated */
    KnownJsonOutputSerializationFormat["LineSeparated"] = "LineSeparated";
    /** Array */
    KnownJsonOutputSerializationFormat["Array"] = "Array";
})(exports.KnownJsonOutputSerializationFormat || (exports.KnownJsonOutputSerializationFormat = {}));
/** Known values of {@link RefreshType} that the service accepts. */
exports.KnownRefreshType = void 0;
(function (KnownRefreshType) {
    /** Static */
    KnownRefreshType["Static"] = "Static";
    /** RefreshPeriodicallyWithFull */
    KnownRefreshType["RefreshPeriodicallyWithFull"] = "RefreshPeriodicallyWithFull";
    /** RefreshPeriodicallyWithDelta */
    KnownRefreshType["RefreshPeriodicallyWithDelta"] = "RefreshPeriodicallyWithDelta";
})(exports.KnownRefreshType || (exports.KnownRefreshType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorError"
                }
            }
        }
    }
};
const ErrorError = {
    type: {
        name: "Composite",
        className: "ErrorError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetails"
                        }
                    }
                }
            }
        }
    }
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InputProperties = {
    type: {
        name: "Composite",
        className: "InputProperties",
        uberParent: "InputProperties",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            serialization: {
                serializedName: "serialization",
                type: {
                    name: "Composite",
                    className: "Serialization"
                }
            },
            diagnostics: {
                serializedName: "diagnostics",
                type: {
                    name: "Composite",
                    className: "Diagnostics"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            compression: {
                serializedName: "compression",
                type: {
                    name: "Composite",
                    className: "Compression"
                }
            },
            partitionKey: {
                serializedName: "partitionKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Serialization = {
    type: {
        name: "Composite",
        className: "Serialization",
        uberParent: "Serialization",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Diagnostics = {
    type: {
        name: "Composite",
        className: "Diagnostics",
        modelProperties: {
            conditions: {
                serializedName: "conditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticCondition"
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticCondition = {
    type: {
        name: "Composite",
        className: "DiagnosticCondition",
        modelProperties: {
            since: {
                serializedName: "since",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Compression = {
    type: {
        name: "Composite",
        className: "Compression",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutputDataSource = {
    type: {
        name: "Composite",
        className: "OutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionProperties = {
    type: {
        name: "Composite",
        className: "FunctionProperties",
        uberParent: "FunctionProperties",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccount = {
    type: {
        name: "Composite",
        className: "StorageAccount",
        modelProperties: {
            accountName: {
                serializedName: "accountName",
                type: {
                    name: "String"
                }
            },
            accountKey: {
                serializedName: "accountKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterInfo = {
    type: {
        name: "Composite",
        className: "ClusterInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StreamingJobListResult = {
    type: {
        name: "Composite",
        className: "StreamingJobListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StreamingJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StartStreamingJobParameters = {
    type: {
        name: "Composite",
        className: "StartStreamingJobParameters",
        modelProperties: {
            outputStartMode: {
                serializedName: "outputStartMode",
                type: {
                    name: "String"
                }
            },
            outputStartTime: {
                serializedName: "outputStartTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ScaleStreamingJobParameters = {
    type: {
        name: "Composite",
        className: "ScaleStreamingJobParameters",
        modelProperties: {
            streamingUnits: {
                serializedName: "streamingUnits",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const InputListResult = {
    type: {
        name: "Composite",
        className: "InputListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Input"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceTestStatus = {
    type: {
        name: "Composite",
        className: "ResourceTestStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutputListResult = {
    type: {
        name: "Composite",
        className: "OutputListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Output"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionListResult = {
    type: {
        name: "Composite",
        className: "FunctionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionRetrieveDefaultDefinitionParameters = {
    type: {
        name: "Composite",
        className: "FunctionRetrieveDefaultDefinitionParameters",
        uberParent: "FunctionRetrieveDefaultDefinitionParameters",
        polymorphicDiscriminator: {
            serializedName: "bindingType",
            clientName: "bindingType"
        },
        modelProperties: {
            bindingType: {
                serializedName: "bindingType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionQuotasListResult = {
    type: {
        name: "Composite",
        className: "SubscriptionQuotasListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubscriptionQuota"
                        }
                    }
                }
            }
        }
    }
};
const ClusterSku = {
    type: {
        name: "Composite",
        className: "ClusterSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            capacity: {
                constraints: {
                    InclusiveMaximum: 216,
                    InclusiveMinimum: 36
                },
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClusterListResult = {
    type: {
        name: "Composite",
        className: "ClusterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cluster"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterJobListResult = {
    type: {
        name: "Composite",
        className: "ClusterJobListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterJob = {
    type: {
        name: "Composite",
        className: "ClusterJob",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            streamingUnits: {
                serializedName: "streamingUnits",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            jobState: {
                serializedName: "jobState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnection = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnection",
        modelProperties: {
            privateLinkServiceId: {
                serializedName: "properties.privateLinkServiceId",
                type: {
                    name: "String"
                }
            },
            groupIds: {
                serializedName: "properties.groupIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requestMessage: {
                serializedName: "properties.requestMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState"
                }
            }
        }
    }
};
const PrivateLinkConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StreamInputDataSource = {
    type: {
        name: "Composite",
        className: "StreamInputDataSource",
        uberParent: "StreamInputDataSource",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReferenceInputDataSource = {
    type: {
        name: "Composite",
        className: "ReferenceInputDataSource",
        uberParent: "ReferenceInputDataSource",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BlobDataSourceProperties = {
    type: {
        name: "Composite",
        className: "BlobDataSourceProperties",
        modelProperties: {
            storageAccounts: {
                serializedName: "storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            },
            container: {
                serializedName: "container",
                type: {
                    name: "String"
                }
            },
            pathPattern: {
                serializedName: "pathPattern",
                type: {
                    name: "String"
                }
            },
            dateFormat: {
                serializedName: "dateFormat",
                type: {
                    name: "String"
                }
            },
            timeFormat: {
                serializedName: "timeFormat",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceBusDataSourceProperties = {
    type: {
        name: "Composite",
        className: "ServiceBusDataSourceProperties",
        modelProperties: {
            serviceBusNamespace: {
                serializedName: "serviceBusNamespace",
                type: {
                    name: "String"
                }
            },
            sharedAccessPolicyName: {
                serializedName: "sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            },
            sharedAccessPolicyKey: {
                serializedName: "sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            },
            authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureSqlDatabaseDataSourceProperties = {
    type: {
        name: "Composite",
        className: "AzureSqlDatabaseDataSourceProperties",
        modelProperties: {
            server: {
                serializedName: "server",
                type: {
                    name: "String"
                }
            },
            database: {
                serializedName: "database",
                type: {
                    name: "String"
                }
            },
            user: {
                serializedName: "user",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            table: {
                serializedName: "table",
                type: {
                    name: "String"
                }
            },
            maxBatchCount: {
                serializedName: "maxBatchCount",
                type: {
                    name: "Number"
                }
            },
            maxWriterCount: {
                serializedName: "maxWriterCount",
                type: {
                    name: "Number"
                }
            },
            authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureSynapseDataSourceProperties = {
    type: {
        name: "Composite",
        className: "AzureSynapseDataSourceProperties",
        modelProperties: {
            server: {
                serializedName: "server",
                type: {
                    name: "String"
                }
            },
            database: {
                serializedName: "database",
                type: {
                    name: "String"
                }
            },
            table: {
                serializedName: "table",
                type: {
                    name: "String"
                }
            },
            user: {
                serializedName: "user",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OAuthBasedDataSourceProperties = {
    type: {
        name: "Composite",
        className: "OAuthBasedDataSourceProperties",
        modelProperties: {
            refreshToken: {
                serializedName: "refreshToken",
                type: {
                    name: "String"
                }
            },
            tokenUserPrincipalName: {
                serializedName: "tokenUserPrincipalName",
                type: {
                    name: "String"
                }
            },
            tokenUserDisplayName: {
                serializedName: "tokenUserDisplayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionInput = {
    type: {
        name: "Composite",
        className: "FunctionInput",
        modelProperties: {
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            isConfigurationParameter: {
                serializedName: "isConfigurationParameter",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FunctionOutput = {
    type: {
        name: "Composite",
        className: "FunctionOutput",
        modelProperties: {
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionBinding = {
    type: {
        name: "Composite",
        className: "FunctionBinding",
        uberParent: "FunctionBinding",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureMachineLearningWebServiceInputs = {
    type: {
        name: "Composite",
        className: "AzureMachineLearningWebServiceInputs",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            columnNames: {
                serializedName: "columnNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureMachineLearningWebServiceInputColumn"
                        }
                    }
                }
            }
        }
    }
};
const AzureMachineLearningWebServiceInputColumn = {
    type: {
        name: "Composite",
        className: "AzureMachineLearningWebServiceInputColumn",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            mapTo: {
                serializedName: "mapTo",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureMachineLearningWebServiceOutputColumn = {
    type: {
        name: "Composite",
        className: "AzureMachineLearningWebServiceOutputColumn",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StreamInputProperties = {
    serializedName: "Stream",
    type: {
        name: "Composite",
        className: "StreamInputProperties",
        uberParent: "InputProperties",
        polymorphicDiscriminator: InputProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, InputProperties.type.modelProperties), { datasource: {
                serializedName: "datasource",
                type: {
                    name: "Composite",
                    className: "StreamInputDataSource"
                }
            } })
    }
};
const ReferenceInputProperties = {
    serializedName: "Reference",
    type: {
        name: "Composite",
        className: "ReferenceInputProperties",
        uberParent: "InputProperties",
        polymorphicDiscriminator: InputProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, InputProperties.type.modelProperties), { datasource: {
                serializedName: "datasource",
                type: {
                    name: "Composite",
                    className: "ReferenceInputDataSource"
                }
            } })
    }
};
const ParquetSerialization = {
    serializedName: "Parquet",
    type: {
        name: "Composite",
        className: "ParquetSerialization",
        uberParent: "Serialization",
        polymorphicDiscriminator: Serialization.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Serialization.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const CsvSerialization = {
    serializedName: "Csv",
    type: {
        name: "Composite",
        className: "CsvSerialization",
        uberParent: "Serialization",
        polymorphicDiscriminator: Serialization.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Serialization.type.modelProperties), { fieldDelimiter: {
                serializedName: "properties.fieldDelimiter",
                type: {
                    name: "String"
                }
            }, encoding: {
                serializedName: "properties.encoding",
                type: {
                    name: "String"
                }
            } })
    }
};
const JsonSerialization = {
    serializedName: "Json",
    type: {
        name: "Composite",
        className: "JsonSerialization",
        uberParent: "Serialization",
        polymorphicDiscriminator: Serialization.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Serialization.type.modelProperties), { encoding: {
                serializedName: "properties.encoding",
                type: {
                    name: "String"
                }
            }, format: {
                serializedName: "properties.format",
                type: {
                    name: "String"
                }
            } })
    }
};
const AvroSerialization = {
    serializedName: "Avro",
    type: {
        name: "Composite",
        className: "AvroSerialization",
        uberParent: "Serialization",
        polymorphicDiscriminator: Serialization.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Serialization.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const Input = {
    type: {
        name: "Composite",
        className: "Input",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "InputProperties"
                }
            } })
    }
};
const Transformation = {
    type: {
        name: "Composite",
        className: "Transformation",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { streamingUnits: {
                serializedName: "properties.streamingUnits",
                type: {
                    name: "Number"
                }
            }, validStreamingUnits: {
                serializedName: "properties.validStreamingUnits",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }, query: {
                serializedName: "properties.query",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "properties.etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Output = {
    type: {
        name: "Composite",
        className: "Output",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { datasource: {
                serializedName: "properties.datasource",
                type: {
                    name: "Composite",
                    className: "OutputDataSource"
                }
            }, timeWindow: {
                serializedName: "properties.timeWindow",
                type: {
                    name: "String"
                }
            }, sizeWindow: {
                serializedName: "properties.sizeWindow",
                type: {
                    name: "Number"
                }
            }, serialization: {
                serializedName: "properties.serialization",
                type: {
                    name: "Composite",
                    className: "Serialization"
                }
            }, diagnostics: {
                serializedName: "properties.diagnostics",
                type: {
                    name: "Composite",
                    className: "Diagnostics"
                }
            }, etag: {
                serializedName: "properties.etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const FunctionModel = {
    type: {
        name: "Composite",
        className: "FunctionModel",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "FunctionProperties"
                }
            } })
    }
};
const SubscriptionQuota = {
    type: {
        name: "Composite",
        className: "SubscriptionQuota",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { maxCount: {
                serializedName: "properties.maxCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, currentCount: {
                serializedName: "properties.currentCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const BlobOutputDataSource = {
    serializedName: "Microsoft.Storage/Blob",
    type: {
        name: "Composite",
        className: "BlobOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { storageAccounts: {
                serializedName: "properties.storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            }, container: {
                serializedName: "properties.container",
                type: {
                    name: "String"
                }
            }, pathPattern: {
                serializedName: "properties.pathPattern",
                type: {
                    name: "String"
                }
            }, dateFormat: {
                serializedName: "properties.dateFormat",
                type: {
                    name: "String"
                }
            }, timeFormat: {
                serializedName: "properties.timeFormat",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureTableOutputDataSource = {
    serializedName: "Microsoft.Storage/Table",
    type: {
        name: "Composite",
        className: "AzureTableOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { accountName: {
                serializedName: "properties.accountName",
                type: {
                    name: "String"
                }
            }, accountKey: {
                serializedName: "properties.accountKey",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, partitionKey: {
                serializedName: "properties.partitionKey",
                type: {
                    name: "String"
                }
            }, rowKey: {
                serializedName: "properties.rowKey",
                type: {
                    name: "String"
                }
            }, columnsToRemove: {
                serializedName: "properties.columnsToRemove",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, batchSize: {
                serializedName: "properties.batchSize",
                type: {
                    name: "Number"
                }
            } })
    }
};
const EventHubOutputDataSource = {
    serializedName: "Microsoft.ServiceBus/EventHub",
    type: {
        name: "Composite",
        className: "EventHubOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, eventHubName: {
                serializedName: "properties.eventHubName",
                type: {
                    name: "String"
                }
            }, partitionKey: {
                serializedName: "properties.partitionKey",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "properties.propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const EventHubV2OutputDataSource = {
    serializedName: "Microsoft.EventHub/EventHub",
    type: {
        name: "Composite",
        className: "EventHubV2OutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, eventHubName: {
                serializedName: "properties.eventHubName",
                type: {
                    name: "String"
                }
            }, partitionKey: {
                serializedName: "properties.partitionKey",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "properties.propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AzureSqlDatabaseOutputDataSource = {
    serializedName: "Microsoft.Sql/Server/Database",
    type: {
        name: "Composite",
        className: "AzureSqlDatabaseOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { server: {
                serializedName: "properties.server",
                type: {
                    name: "String"
                }
            }, database: {
                serializedName: "properties.database",
                type: {
                    name: "String"
                }
            }, user: {
                serializedName: "properties.user",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, maxBatchCount: {
                serializedName: "properties.maxBatchCount",
                type: {
                    name: "Number"
                }
            }, maxWriterCount: {
                serializedName: "properties.maxWriterCount",
                type: {
                    name: "Number"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureSynapseOutputDataSource = {
    serializedName: "Microsoft.Sql/Server/DataWarehouse",
    type: {
        name: "Composite",
        className: "AzureSynapseOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { server: {
                serializedName: "properties.server",
                type: {
                    name: "String"
                }
            }, database: {
                serializedName: "properties.database",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, user: {
                serializedName: "properties.user",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            } })
    }
};
const DocumentDbOutputDataSource = {
    serializedName: "Microsoft.Storage/DocumentDB",
    type: {
        name: "Composite",
        className: "DocumentDbOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { accountId: {
                serializedName: "properties.accountId",
                type: {
                    name: "String"
                }
            }, accountKey: {
                serializedName: "properties.accountKey",
                type: {
                    name: "String"
                }
            }, database: {
                serializedName: "properties.database",
                type: {
                    name: "String"
                }
            }, collectionNamePattern: {
                serializedName: "properties.collectionNamePattern",
                type: {
                    name: "String"
                }
            }, partitionKey: {
                serializedName: "properties.partitionKey",
                type: {
                    name: "String"
                }
            }, documentId: {
                serializedName: "properties.documentId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceBusQueueOutputDataSource = {
    serializedName: "Microsoft.ServiceBus/Queue",
    type: {
        name: "Composite",
        className: "ServiceBusQueueOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, queueName: {
                serializedName: "properties.queueName",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "properties.propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, systemPropertyColumns: {
                serializedName: "properties.systemPropertyColumns",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const ServiceBusTopicOutputDataSource = {
    serializedName: "Microsoft.ServiceBus/Topic",
    type: {
        name: "Composite",
        className: "ServiceBusTopicOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, topicName: {
                serializedName: "properties.topicName",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "properties.propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, systemPropertyColumns: {
                serializedName: "properties.systemPropertyColumns",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const PowerBIOutputDataSource = {
    serializedName: "PowerBI",
    type: {
        name: "Composite",
        className: "PowerBIOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { refreshToken: {
                serializedName: "properties.refreshToken",
                type: {
                    name: "String"
                }
            }, tokenUserPrincipalName: {
                serializedName: "properties.tokenUserPrincipalName",
                type: {
                    name: "String"
                }
            }, tokenUserDisplayName: {
                serializedName: "properties.tokenUserDisplayName",
                type: {
                    name: "String"
                }
            }, dataset: {
                serializedName: "properties.dataset",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            }, groupName: {
                serializedName: "properties.groupName",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureDataLakeStoreOutputDataSource = {
    serializedName: "Microsoft.DataLake/Accounts",
    type: {
        name: "Composite",
        className: "AzureDataLakeStoreOutputDataSource",
        uberParent: "OutputDataSource",
        polymorphicDiscriminator: OutputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OutputDataSource.type.modelProperties), { refreshToken: {
                serializedName: "properties.refreshToken",
                type: {
                    name: "String"
                }
            }, tokenUserPrincipalName: {
                serializedName: "properties.tokenUserPrincipalName",
                type: {
                    name: "String"
                }
            }, tokenUserDisplayName: {
                serializedName: "properties.tokenUserDisplayName",
                type: {
                    name: "String"
                }
            }, accountName: {
                serializedName: "properties.accountName",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            }, filePathPrefix: {
                serializedName: "properties.filePathPrefix",
                type: {
                    name: "String"
                }
            }, dateFormat: {
                serializedName: "properties.dateFormat",
                type: {
                    name: "String"
                }
            }, timeFormat: {
                serializedName: "properties.timeFormat",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const ScalarFunctionProperties = {
    serializedName: "Scalar",
    type: {
        name: "Composite",
        className: "ScalarFunctionProperties",
        uberParent: "FunctionProperties",
        polymorphicDiscriminator: FunctionProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FunctionProperties.type.modelProperties), { inputs: {
                serializedName: "properties.inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionInput"
                        }
                    }
                }
            }, output: {
                serializedName: "properties.output",
                type: {
                    name: "Composite",
                    className: "FunctionOutput"
                }
            }, binding: {
                serializedName: "properties.binding",
                type: {
                    name: "Composite",
                    className: "FunctionBinding"
                }
            } })
    }
};
const JobStorageAccount = {
    type: {
        name: "Composite",
        className: "JobStorageAccount",
        modelProperties: Object.assign(Object.assign({}, StorageAccount.type.modelProperties), { authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters = {
    serializedName: "Microsoft.MachineLearning/WebService",
    type: {
        name: "Composite",
        className: "AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters",
        uberParent: "FunctionRetrieveDefaultDefinitionParameters",
        polymorphicDiscriminator: FunctionRetrieveDefaultDefinitionParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FunctionRetrieveDefaultDefinitionParameters.type.modelProperties), { executeEndpoint: {
                serializedName: "bindingRetrievalProperties.executeEndpoint",
                type: {
                    name: "String"
                }
            }, udfType: {
                defaultValue: "Scalar",
                isConstant: true,
                serializedName: "bindingRetrievalProperties.udfType",
                type: {
                    name: "String"
                }
            } })
    }
};
const JavaScriptFunctionRetrieveDefaultDefinitionParameters = {
    serializedName: "Microsoft.StreamAnalytics/JavascriptUdf",
    type: {
        name: "Composite",
        className: "JavaScriptFunctionRetrieveDefaultDefinitionParameters",
        uberParent: "FunctionRetrieveDefaultDefinitionParameters",
        polymorphicDiscriminator: FunctionRetrieveDefaultDefinitionParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FunctionRetrieveDefaultDefinitionParameters.type.modelProperties), { script: {
                serializedName: "bindingRetrievalProperties.script",
                type: {
                    name: "String"
                }
            }, udfType: {
                defaultValue: "Scalar",
                isConstant: true,
                serializedName: "bindingRetrievalProperties.udfType",
                type: {
                    name: "String"
                }
            } })
    }
};
const BlobStreamInputDataSource = {
    serializedName: "Microsoft.Storage/Blob",
    type: {
        name: "Composite",
        className: "BlobStreamInputDataSource",
        uberParent: "StreamInputDataSource",
        polymorphicDiscriminator: StreamInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, StreamInputDataSource.type.modelProperties), { storageAccounts: {
                serializedName: "properties.storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            }, container: {
                serializedName: "properties.container",
                type: {
                    name: "String"
                }
            }, pathPattern: {
                serializedName: "properties.pathPattern",
                type: {
                    name: "String"
                }
            }, dateFormat: {
                serializedName: "properties.dateFormat",
                type: {
                    name: "String"
                }
            }, timeFormat: {
                serializedName: "properties.timeFormat",
                type: {
                    name: "String"
                }
            }, sourcePartitionCount: {
                serializedName: "properties.sourcePartitionCount",
                type: {
                    name: "Number"
                }
            } })
    }
};
const EventHubStreamInputDataSource = {
    serializedName: "Microsoft.ServiceBus/EventHub",
    type: {
        name: "Composite",
        className: "EventHubStreamInputDataSource",
        uberParent: "StreamInputDataSource",
        polymorphicDiscriminator: StreamInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, StreamInputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, eventHubName: {
                serializedName: "properties.eventHubName",
                type: {
                    name: "String"
                }
            }, consumerGroupName: {
                serializedName: "properties.consumerGroupName",
                type: {
                    name: "String"
                }
            } })
    }
};
const EventHubV2StreamInputDataSource = {
    serializedName: "Microsoft.EventHub/EventHub",
    type: {
        name: "Composite",
        className: "EventHubV2StreamInputDataSource",
        uberParent: "StreamInputDataSource",
        polymorphicDiscriminator: StreamInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, StreamInputDataSource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "properties.authenticationMode",
                type: {
                    name: "String"
                }
            }, eventHubName: {
                serializedName: "properties.eventHubName",
                type: {
                    name: "String"
                }
            }, consumerGroupName: {
                serializedName: "properties.consumerGroupName",
                type: {
                    name: "String"
                }
            } })
    }
};
const IoTHubStreamInputDataSource = {
    serializedName: "Microsoft.Devices/IotHubs",
    type: {
        name: "Composite",
        className: "IoTHubStreamInputDataSource",
        uberParent: "StreamInputDataSource",
        polymorphicDiscriminator: StreamInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, StreamInputDataSource.type.modelProperties), { iotHubNamespace: {
                serializedName: "properties.iotHubNamespace",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, sharedAccessPolicyKey: {
                serializedName: "properties.sharedAccessPolicyKey",
                type: {
                    name: "String"
                }
            }, consumerGroupName: {
                serializedName: "properties.consumerGroupName",
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "properties.endpoint",
                type: {
                    name: "String"
                }
            } })
    }
};
const BlobReferenceInputDataSource = {
    serializedName: "Microsoft.Storage/Blob",
    type: {
        name: "Composite",
        className: "BlobReferenceInputDataSource",
        uberParent: "ReferenceInputDataSource",
        polymorphicDiscriminator: ReferenceInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ReferenceInputDataSource.type.modelProperties), { storageAccounts: {
                serializedName: "properties.storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            }, container: {
                serializedName: "properties.container",
                type: {
                    name: "String"
                }
            }, pathPattern: {
                serializedName: "properties.pathPattern",
                type: {
                    name: "String"
                }
            }, dateFormat: {
                serializedName: "properties.dateFormat",
                type: {
                    name: "String"
                }
            }, timeFormat: {
                serializedName: "properties.timeFormat",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureSqlReferenceInputDataSource = {
    serializedName: "Microsoft.Sql/Server/Database",
    type: {
        name: "Composite",
        className: "AzureSqlReferenceInputDataSource",
        uberParent: "ReferenceInputDataSource",
        polymorphicDiscriminator: ReferenceInputDataSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ReferenceInputDataSource.type.modelProperties), { server: {
                serializedName: "properties.server",
                type: {
                    name: "String"
                }
            }, database: {
                serializedName: "properties.database",
                type: {
                    name: "String"
                }
            }, user: {
                serializedName: "properties.user",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, refreshType: {
                serializedName: "properties.refreshType",
                type: {
                    name: "String"
                }
            }, refreshRate: {
                serializedName: "properties.refreshRate",
                type: {
                    name: "String"
                }
            }, fullSnapshotQuery: {
                serializedName: "properties.fullSnapshotQuery",
                type: {
                    name: "String"
                }
            }, deltaSnapshotQuery: {
                serializedName: "properties.deltaSnapshotQuery",
                type: {
                    name: "String"
                }
            } })
    }
};
const BlobStreamInputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "BlobStreamInputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, BlobDataSourceProperties.type.modelProperties), { sourcePartitionCount: {
                serializedName: "sourcePartitionCount",
                type: {
                    name: "Number"
                }
            } })
    }
};
const BlobReferenceInputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "BlobReferenceInputDataSourceProperties",
        modelProperties: Object.assign({}, BlobDataSourceProperties.type.modelProperties)
    }
};
const BlobOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "BlobOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, BlobDataSourceProperties.type.modelProperties), { authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const EventHubDataSourceProperties = {
    type: {
        name: "Composite",
        className: "EventHubDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, ServiceBusDataSourceProperties.type.modelProperties), { eventHubName: {
                serializedName: "eventHubName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceBusQueueOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "ServiceBusQueueOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, ServiceBusDataSourceProperties.type.modelProperties), { queueName: {
                serializedName: "queueName",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, systemPropertyColumns: {
                serializedName: "systemPropertyColumns",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const ServiceBusTopicOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "ServiceBusTopicOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, ServiceBusDataSourceProperties.type.modelProperties), { topicName: {
                serializedName: "topicName",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, systemPropertyColumns: {
                serializedName: "systemPropertyColumns",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const AzureSqlDatabaseOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "AzureSqlDatabaseOutputDataSourceProperties",
        modelProperties: Object.assign({}, AzureSqlDatabaseDataSourceProperties.type.modelProperties)
    }
};
const AzureSynapseOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "AzureSynapseOutputDataSourceProperties",
        modelProperties: Object.assign({}, AzureSynapseDataSourceProperties.type.modelProperties)
    }
};
const PowerBIOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "PowerBIOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, OAuthBasedDataSourceProperties.type.modelProperties), { dataset: {
                serializedName: "dataset",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "table",
                type: {
                    name: "String"
                }
            }, groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            }, groupName: {
                serializedName: "groupName",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureDataLakeStoreOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "AzureDataLakeStoreOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, OAuthBasedDataSourceProperties.type.modelProperties), { accountName: {
                serializedName: "accountName",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            }, filePathPrefix: {
                serializedName: "filePathPrefix",
                type: {
                    name: "String"
                }
            }, dateFormat: {
                serializedName: "dateFormat",
                type: {
                    name: "String"
                }
            }, timeFormat: {
                serializedName: "timeFormat",
                type: {
                    name: "String"
                }
            }, authenticationMode: {
                serializedName: "authenticationMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureMachineLearningWebServiceFunctionBinding = {
    serializedName: "Microsoft.MachineLearning/WebService",
    type: {
        name: "Composite",
        className: "AzureMachineLearningWebServiceFunctionBinding",
        uberParent: "FunctionBinding",
        polymorphicDiscriminator: FunctionBinding.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FunctionBinding.type.modelProperties), { endpoint: {
                serializedName: "properties.endpoint",
                type: {
                    name: "String"
                }
            }, apiKey: {
                serializedName: "properties.apiKey",
                type: {
                    name: "String"
                }
            }, inputs: {
                serializedName: "properties.inputs",
                type: {
                    name: "Composite",
                    className: "AzureMachineLearningWebServiceInputs"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureMachineLearningWebServiceOutputColumn"
                        }
                    }
                }
            }, batchSize: {
                serializedName: "properties.batchSize",
                type: {
                    name: "Number"
                }
            } })
    }
};
const JavaScriptFunctionBinding = {
    serializedName: "Microsoft.StreamAnalytics/JavascriptUdf",
    type: {
        name: "Composite",
        className: "JavaScriptFunctionBinding",
        uberParent: "FunctionBinding",
        polymorphicDiscriminator: FunctionBinding.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FunctionBinding.type.modelProperties), { script: {
                serializedName: "properties.script",
                type: {
                    name: "String"
                }
            } })
    }
};
const StreamingJob = {
    type: {
        name: "Composite",
        className: "StreamingJob",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, jobId: {
                serializedName: "properties.jobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, jobState: {
                serializedName: "properties.jobState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, jobType: {
                serializedName: "properties.jobType",
                type: {
                    name: "String"
                }
            }, outputStartMode: {
                serializedName: "properties.outputStartMode",
                type: {
                    name: "String"
                }
            }, outputStartTime: {
                serializedName: "properties.outputStartTime",
                type: {
                    name: "DateTime"
                }
            }, lastOutputEventTime: {
                serializedName: "properties.lastOutputEventTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, eventsOutOfOrderPolicy: {
                serializedName: "properties.eventsOutOfOrderPolicy",
                type: {
                    name: "String"
                }
            }, outputErrorPolicy: {
                serializedName: "properties.outputErrorPolicy",
                type: {
                    name: "String"
                }
            }, eventsOutOfOrderMaxDelayInSeconds: {
                serializedName: "properties.eventsOutOfOrderMaxDelayInSeconds",
                type: {
                    name: "Number"
                }
            }, eventsLateArrivalMaxDelayInSeconds: {
                serializedName: "properties.eventsLateArrivalMaxDelayInSeconds",
                type: {
                    name: "Number"
                }
            }, dataLocale: {
                serializedName: "properties.dataLocale",
                type: {
                    name: "String"
                }
            }, compatibilityLevel: {
                serializedName: "properties.compatibilityLevel",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, inputs: {
                serializedName: "properties.inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Input"
                        }
                    }
                }
            }, transformation: {
                serializedName: "properties.transformation",
                type: {
                    name: "Composite",
                    className: "Transformation"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Output"
                        }
                    }
                }
            }, functions: {
                serializedName: "properties.functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionModel"
                        }
                    }
                }
            }, etag: {
                serializedName: "properties.etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, jobStorageAccount: {
                serializedName: "properties.jobStorageAccount",
                type: {
                    name: "Composite",
                    className: "JobStorageAccount"
                }
            }, contentStoragePolicy: {
                serializedName: "properties.contentStoragePolicy",
                type: {
                    name: "String"
                }
            }, cluster: {
                serializedName: "properties.cluster",
                type: {
                    name: "Composite",
                    className: "ClusterInfo"
                }
            } })
    }
};
const Cluster = {
    type: {
        name: "Composite",
        className: "Cluster",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ClusterSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, clusterId: {
                serializedName: "properties.clusterId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, capacityAllocated: {
                serializedName: "properties.capacityAllocated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, capacityAssigned: {
                serializedName: "properties.capacityAssigned",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, manualPrivateLinkServiceConnections: {
                serializedName: "properties.manualPrivateLinkServiceConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceConnection"
                        }
                    }
                }
            } })
    }
};
const EventHubStreamInputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "EventHubStreamInputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, EventHubDataSourceProperties.type.modelProperties), { consumerGroupName: {
                serializedName: "consumerGroupName",
                type: {
                    name: "String"
                }
            } })
    }
};
const EventHubOutputDataSourceProperties = {
    type: {
        name: "Composite",
        className: "EventHubOutputDataSourceProperties",
        modelProperties: Object.assign(Object.assign({}, EventHubDataSourceProperties.type.modelProperties), { partitionKey: {
                serializedName: "partitionKey",
                type: {
                    name: "String"
                }
            }, propertyColumns: {
                serializedName: "propertyColumns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StreamingJobsCreateOrReplaceHeaders = {
    type: {
        name: "Composite",
        className: "StreamingJobsCreateOrReplaceHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StreamingJobsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "StreamingJobsUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StreamingJobsGetHeaders = {
    type: {
        name: "Composite",
        className: "StreamingJobsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InputsCreateOrReplaceHeaders = {
    type: {
        name: "Composite",
        className: "InputsCreateOrReplaceHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InputsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "InputsUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InputsGetHeaders = {
    type: {
        name: "Composite",
        className: "InputsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutputsCreateOrReplaceHeaders = {
    type: {
        name: "Composite",
        className: "OutputsCreateOrReplaceHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutputsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "OutputsUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutputsGetHeaders = {
    type: {
        name: "Composite",
        className: "OutputsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TransformationsCreateOrReplaceHeaders = {
    type: {
        name: "Composite",
        className: "TransformationsCreateOrReplaceHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TransformationsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "TransformationsUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TransformationsGetHeaders = {
    type: {
        name: "Composite",
        className: "TransformationsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionsCreateOrReplaceHeaders = {
    type: {
        name: "Composite",
        className: "FunctionsCreateOrReplaceHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "FunctionsUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FunctionsGetHeaders = {
    type: {
        name: "Composite",
        className: "FunctionsGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    InputProperties: InputProperties,
    Serialization: Serialization,
    OutputDataSource: OutputDataSource,
    FunctionProperties: FunctionProperties,
    FunctionRetrieveDefaultDefinitionParameters: FunctionRetrieveDefaultDefinitionParameters,
    StreamInputDataSource: StreamInputDataSource,
    ReferenceInputDataSource: ReferenceInputDataSource,
    FunctionBinding: FunctionBinding,
    "InputProperties.Stream": StreamInputProperties,
    "InputProperties.Reference": ReferenceInputProperties,
    "Serialization.Parquet": ParquetSerialization,
    "Serialization.Csv": CsvSerialization,
    "Serialization.Json": JsonSerialization,
    "Serialization.Avro": AvroSerialization,
    "OutputDataSource.Microsoft.Storage/Blob": BlobOutputDataSource,
    "OutputDataSource.Microsoft.Storage/Table": AzureTableOutputDataSource,
    "OutputDataSource.Microsoft.ServiceBus/EventHub": EventHubOutputDataSource,
    "OutputDataSource.Microsoft.EventHub/EventHub": EventHubV2OutputDataSource,
    "OutputDataSource.Microsoft.Sql/Server/Database": AzureSqlDatabaseOutputDataSource,
    "OutputDataSource.Microsoft.Sql/Server/DataWarehouse": AzureSynapseOutputDataSource,
    "OutputDataSource.Microsoft.Storage/DocumentDB": DocumentDbOutputDataSource,
    "OutputDataSource.Microsoft.ServiceBus/Queue": ServiceBusQueueOutputDataSource,
    "OutputDataSource.Microsoft.ServiceBus/Topic": ServiceBusTopicOutputDataSource,
    "OutputDataSource.PowerBI": PowerBIOutputDataSource,
    "OutputDataSource.Microsoft.DataLake/Accounts": AzureDataLakeStoreOutputDataSource,
    "FunctionProperties.Scalar": ScalarFunctionProperties,
    "FunctionRetrieveDefaultDefinitionParameters.Microsoft.MachineLearning/WebService": AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters,
    "FunctionRetrieveDefaultDefinitionParameters.Microsoft.StreamAnalytics/JavascriptUdf": JavaScriptFunctionRetrieveDefaultDefinitionParameters,
    "StreamInputDataSource.Microsoft.Storage/Blob": BlobStreamInputDataSource,
    "StreamInputDataSource.Microsoft.ServiceBus/EventHub": EventHubStreamInputDataSource,
    "StreamInputDataSource.Microsoft.EventHub/EventHub": EventHubV2StreamInputDataSource,
    "StreamInputDataSource.Microsoft.Devices/IotHubs": IoTHubStreamInputDataSource,
    "ReferenceInputDataSource.Microsoft.Storage/Blob": BlobReferenceInputDataSource,
    "ReferenceInputDataSource.Microsoft.Sql/Server/Database": AzureSqlReferenceInputDataSource,
    "FunctionBinding.Microsoft.MachineLearning/WebService": AzureMachineLearningWebServiceFunctionBinding,
    "FunctionBinding.Microsoft.StreamAnalytics/JavascriptUdf": JavaScriptFunctionBinding
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ErrorModel: ErrorModel,
    ErrorError: ErrorError,
    ErrorDetails: ErrorDetails,
    Sku: Sku,
    InputProperties: InputProperties,
    Serialization: Serialization,
    Diagnostics: Diagnostics,
    DiagnosticCondition: DiagnosticCondition,
    Compression: Compression,
    SubResource: SubResource,
    OutputDataSource: OutputDataSource,
    FunctionProperties: FunctionProperties,
    StorageAccount: StorageAccount,
    ClusterInfo: ClusterInfo,
    Identity: Identity,
    Resource: Resource,
    StreamingJobListResult: StreamingJobListResult,
    StartStreamingJobParameters: StartStreamingJobParameters,
    ScaleStreamingJobParameters: ScaleStreamingJobParameters,
    InputListResult: InputListResult,
    ResourceTestStatus: ResourceTestStatus,
    ErrorResponse: ErrorResponse,
    OutputListResult: OutputListResult,
    FunctionListResult: FunctionListResult,
    FunctionRetrieveDefaultDefinitionParameters: FunctionRetrieveDefaultDefinitionParameters,
    SubscriptionQuotasListResult: SubscriptionQuotasListResult,
    ClusterSku: ClusterSku,
    ClusterListResult: ClusterListResult,
    ClusterJobListResult: ClusterJobListResult,
    ClusterJob: ClusterJob,
    PrivateLinkServiceConnection: PrivateLinkServiceConnection,
    PrivateLinkConnectionState: PrivateLinkConnectionState,
    PrivateEndpointListResult: PrivateEndpointListResult,
    StreamInputDataSource: StreamInputDataSource,
    ReferenceInputDataSource: ReferenceInputDataSource,
    BlobDataSourceProperties: BlobDataSourceProperties,
    ServiceBusDataSourceProperties: ServiceBusDataSourceProperties,
    AzureSqlDatabaseDataSourceProperties: AzureSqlDatabaseDataSourceProperties,
    AzureSynapseDataSourceProperties: AzureSynapseDataSourceProperties,
    OAuthBasedDataSourceProperties: OAuthBasedDataSourceProperties,
    FunctionInput: FunctionInput,
    FunctionOutput: FunctionOutput,
    FunctionBinding: FunctionBinding,
    AzureMachineLearningWebServiceInputs: AzureMachineLearningWebServiceInputs,
    AzureMachineLearningWebServiceInputColumn: AzureMachineLearningWebServiceInputColumn,
    AzureMachineLearningWebServiceOutputColumn: AzureMachineLearningWebServiceOutputColumn,
    StreamInputProperties: StreamInputProperties,
    ReferenceInputProperties: ReferenceInputProperties,
    ParquetSerialization: ParquetSerialization,
    CsvSerialization: CsvSerialization,
    JsonSerialization: JsonSerialization,
    AvroSerialization: AvroSerialization,
    Input: Input,
    Transformation: Transformation,
    Output: Output,
    FunctionModel: FunctionModel,
    SubscriptionQuota: SubscriptionQuota,
    BlobOutputDataSource: BlobOutputDataSource,
    AzureTableOutputDataSource: AzureTableOutputDataSource,
    EventHubOutputDataSource: EventHubOutputDataSource,
    EventHubV2OutputDataSource: EventHubV2OutputDataSource,
    AzureSqlDatabaseOutputDataSource: AzureSqlDatabaseOutputDataSource,
    AzureSynapseOutputDataSource: AzureSynapseOutputDataSource,
    DocumentDbOutputDataSource: DocumentDbOutputDataSource,
    ServiceBusQueueOutputDataSource: ServiceBusQueueOutputDataSource,
    ServiceBusTopicOutputDataSource: ServiceBusTopicOutputDataSource,
    PowerBIOutputDataSource: PowerBIOutputDataSource,
    AzureDataLakeStoreOutputDataSource: AzureDataLakeStoreOutputDataSource,
    ScalarFunctionProperties: ScalarFunctionProperties,
    JobStorageAccount: JobStorageAccount,
    TrackedResource: TrackedResource,
    ProxyResource: ProxyResource,
    AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters: AzureMachineLearningWebServiceFunctionRetrieveDefaultDefinitionParameters,
    JavaScriptFunctionRetrieveDefaultDefinitionParameters: JavaScriptFunctionRetrieveDefaultDefinitionParameters,
    BlobStreamInputDataSource: BlobStreamInputDataSource,
    EventHubStreamInputDataSource: EventHubStreamInputDataSource,
    EventHubV2StreamInputDataSource: EventHubV2StreamInputDataSource,
    IoTHubStreamInputDataSource: IoTHubStreamInputDataSource,
    BlobReferenceInputDataSource: BlobReferenceInputDataSource,
    AzureSqlReferenceInputDataSource: AzureSqlReferenceInputDataSource,
    BlobStreamInputDataSourceProperties: BlobStreamInputDataSourceProperties,
    BlobReferenceInputDataSourceProperties: BlobReferenceInputDataSourceProperties,
    BlobOutputDataSourceProperties: BlobOutputDataSourceProperties,
    EventHubDataSourceProperties: EventHubDataSourceProperties,
    ServiceBusQueueOutputDataSourceProperties: ServiceBusQueueOutputDataSourceProperties,
    ServiceBusTopicOutputDataSourceProperties: ServiceBusTopicOutputDataSourceProperties,
    AzureSqlDatabaseOutputDataSourceProperties: AzureSqlDatabaseOutputDataSourceProperties,
    AzureSynapseOutputDataSourceProperties: AzureSynapseOutputDataSourceProperties,
    PowerBIOutputDataSourceProperties: PowerBIOutputDataSourceProperties,
    AzureDataLakeStoreOutputDataSourceProperties: AzureDataLakeStoreOutputDataSourceProperties,
    AzureMachineLearningWebServiceFunctionBinding: AzureMachineLearningWebServiceFunctionBinding,
    JavaScriptFunctionBinding: JavaScriptFunctionBinding,
    StreamingJob: StreamingJob,
    Cluster: Cluster,
    PrivateEndpoint: PrivateEndpoint,
    EventHubStreamInputDataSourceProperties: EventHubStreamInputDataSourceProperties,
    EventHubOutputDataSourceProperties: EventHubOutputDataSourceProperties,
    StreamingJobsCreateOrReplaceHeaders: StreamingJobsCreateOrReplaceHeaders,
    StreamingJobsUpdateHeaders: StreamingJobsUpdateHeaders,
    StreamingJobsGetHeaders: StreamingJobsGetHeaders,
    InputsCreateOrReplaceHeaders: InputsCreateOrReplaceHeaders,
    InputsUpdateHeaders: InputsUpdateHeaders,
    InputsGetHeaders: InputsGetHeaders,
    OutputsCreateOrReplaceHeaders: OutputsCreateOrReplaceHeaders,
    OutputsUpdateHeaders: OutputsUpdateHeaders,
    OutputsGetHeaders: OutputsGetHeaders,
    TransformationsCreateOrReplaceHeaders: TransformationsCreateOrReplaceHeaders,
    TransformationsUpdateHeaders: TransformationsUpdateHeaders,
    TransformationsGetHeaders: TransformationsGetHeaders,
    FunctionsCreateOrReplaceHeaders: FunctionsCreateOrReplaceHeaders,
    FunctionsUpdateHeaders: FunctionsUpdateHeaders,
    FunctionsGetHeaders: FunctionsGetHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-03-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const streamingJob = {
    parameterPath: "streamingJob",
    mapper: StreamingJob
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobName = {
    parameterPath: "jobName",
    mapper: {
        serializedName: "jobName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const startJobParameters = {
    parameterPath: ["options", "startJobParameters"],
    mapper: StartStreamingJobParameters
};
const scaleJobParameters = {
    parameterPath: ["options", "scaleJobParameters"],
    mapper: ScaleStreamingJobParameters
};
const input = {
    parameterPath: "input",
    mapper: Input
};
const inputName = {
    parameterPath: "inputName",
    mapper: {
        serializedName: "inputName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const input1 = {
    parameterPath: ["options", "input"],
    mapper: Input
};
const output = {
    parameterPath: "output",
    mapper: Output
};
const outputName = {
    parameterPath: "outputName",
    mapper: {
        serializedName: "outputName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const output1 = {
    parameterPath: ["options", "output"],
    mapper: Output
};
const transformation = {
    parameterPath: "transformation",
    mapper: Transformation
};
const transformationName = {
    parameterPath: "transformationName",
    mapper: {
        serializedName: "transformationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const functionParam = {
    parameterPath: "functionParam",
    mapper: FunctionModel
};
const functionName = {
    parameterPath: "functionName",
    mapper: {
        serializedName: "functionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const functionParam1 = {
    parameterPath: ["options", "function"],
    mapper: FunctionModel
};
const functionRetrieveDefaultDefinitionParameters = {
    parameterPath: ["options", "functionRetrieveDefaultDefinitionParameters"],
    mapper: FunctionRetrieveDefaultDefinitionParameters
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cluster = {
    parameterPath: "cluster",
    mapper: Cluster
};
const clusterName = {
    parameterPath: "clusterName",
    mapper: {
        serializedName: "clusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpoint = {
    parameterPath: "privateEndpoint",
    mapper: PrivateEndpoint
};
const privateEndpointName = {
    parameterPath: "privateEndpointName",
    mapper: {
        serializedName: "privateEndpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Stream Analytics related operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Stream Analytics related operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.StreamAnalytics/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StreamingJobs operations. */
class StreamingJobsImpl {
    /**
     * Initialize a new instance of the class StreamingJobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the streaming jobs in the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the streaming jobs in the given subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates a streaming job or replaces an already existing streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming
     *                     job or replace the existing one.
     * @param options The options parameters.
     */
    beginCreateOrReplace(resourceGroupName, jobName, streamingJob, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, streamingJob, options }, createOrReplaceOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a streaming job or replaces an already existing streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming
     *                     job or replace the existing one.
     * @param options The options parameters.
     */
    beginCreateOrReplaceAndWait(resourceGroupName, jobName, streamingJob, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrReplace(resourceGroupName, jobName, streamingJob, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two
     * properties) a streaming job without affecting the rest the job definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the
     *                     corresponding properties in the existing streaming job (ie. Those properties will be updated). Any
     *                     properties that are set to null here will mean that the corresponding property in the existing input
     *                     will remain the same and not change as a result of this PATCH operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, jobName, streamingJob, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, streamingJob, options }, updateOperationSpec$5);
    }
    /**
     * Deletes a streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets details about the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, getOperationSpec$6);
    }
    /**
     * Lists all of the streaming jobs in the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Lists all of the streaming jobs in the given subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce
     * output.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce
     * output.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input
     * events and producing output.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input
     * events and producing output.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Scales a streaming job when the job is running.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginScale(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, options }, scaleOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Scales a streaming job when the job is running.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    beginScaleAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginScale(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrReplaceOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsCreateOrReplaceHeaders
        },
        201: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsCreateOrReplaceHeaders
        },
        202: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsCreateOrReplaceHeaders
        },
        204: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsCreateOrReplaceHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: streamingJob,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$7
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: streamingJob,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StreamingJob,
            headersMapper: StreamingJobsGetHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StreamingJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StreamAnalytics/streamingjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StreamingJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: startJobParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const scaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/scale",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: scaleJobParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StreamingJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StreamingJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Inputs operations. */
class InputsImpl {
    /**
     * Initialize a new instance of the class Inputs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the inputs under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    listByStreamingJob(resourceGroupName, jobName, options) {
        const iter = this.listByStreamingJobPagingAll(resourceGroupName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings);
            }
        };
    }
    listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByStreamingJob(resourceGroupName, jobName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByStreamingJobNext(resourceGroupName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByStreamingJobPagingAll(resourceGroupName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByStreamingJobPagingPage(resourceGroupName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the
     *              existing one under the streaming job.
     * @param options The options parameters.
     */
    createOrReplace(resourceGroupName, jobName, inputName, input, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, inputName, input, options }, createOrReplaceOperationSpec$3);
    }
    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie.
     * update one or two properties) an input without affecting the rest the job or input definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding
     *              properties in the existing input (ie. Those properties will be updated). Any properties that are set
     *              to null here will mean that the corresponding property in the existing input will remain the same
     *              and not change as a result of this PATCH operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, jobName, inputName, input, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, inputName, input, options }, updateOperationSpec$4);
    }
    /**
     * Deletes an input from the streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param options The options parameters.
     */
    delete(resourceGroupName, jobName, inputName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, inputName, options }, deleteOperationSpec$4);
    }
    /**
     * Gets details about the specified input.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, inputName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, inputName, options }, getOperationSpec$5);
    }
    /**
     * Lists all of the inputs under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    _listByStreamingJob(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, listByStreamingJobOperationSpec$2);
    }
    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param options The options parameters.
     */
    beginTest(resourceGroupName, jobName, inputName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, inputName, options }, testOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param options The options parameters.
     */
    beginTestAndWait(resourceGroupName, jobName, inputName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTest(resourceGroupName, jobName, inputName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByStreamingJobNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param nextLink The nextLink from the previous successful call to the ListByStreamingJob method.
     * @param options The options parameters.
     */
    _listByStreamingJobNext(resourceGroupName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, nextLink, options }, listByStreamingJobNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrReplaceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Input,
            headersMapper: InputsCreateOrReplaceHeaders
        },
        201: {
            bodyMapper: Input,
            headersMapper: InputsCreateOrReplaceHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: input,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        inputName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Input,
            headersMapper: InputsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: input,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        inputName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        inputName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Input,
            headersMapper: InputsGetHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        inputName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByStreamingJobOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InputListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const testOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}/test",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceTestStatus
        },
        201: {
            bodyMapper: ResourceTestStatus
        },
        202: {
            bodyMapper: ResourceTestStatus
        },
        204: {
            bodyMapper: ResourceTestStatus
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: input1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        inputName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listByStreamingJobNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InputListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Outputs operations. */
class OutputsImpl {
    /**
     * Initialize a new instance of the class Outputs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the outputs under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    listByStreamingJob(resourceGroupName, jobName, options) {
        const iter = this.listByStreamingJobPagingAll(resourceGroupName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings);
            }
        };
    }
    listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByStreamingJob(resourceGroupName, jobName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByStreamingJobNext(resourceGroupName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByStreamingJobPagingAll(resourceGroupName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByStreamingJobPagingPage(resourceGroupName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates an output or replaces an already existing output under an existing streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output The definition of the output that will be used to create a new output or replace the
     *               existing one under the streaming job.
     * @param options The options parameters.
     */
    createOrReplace(resourceGroupName, jobName, outputName, output, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, outputName, output, options }, createOrReplaceOperationSpec$2);
    }
    /**
     * Updates an existing output under an existing streaming job. This can be used to partially update
     * (ie. update one or two properties) an output without affecting the rest the job or output
     * definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param output An Output object. The properties specified here will overwrite the corresponding
     *               properties in the existing output (ie. Those properties will be updated). Any properties that are
     *               set to null here will mean that the corresponding property in the existing output will remain the
     *               same and not change as a result of this PATCH operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, jobName, outputName, output, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, outputName, output, options }, updateOperationSpec$3);
    }
    /**
     * Deletes an output from the streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param options The options parameters.
     */
    delete(resourceGroupName, jobName, outputName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, outputName, options }, deleteOperationSpec$3);
    }
    /**
     * Gets details about the specified output.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, outputName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, outputName, options }, getOperationSpec$4);
    }
    /**
     * Lists all of the outputs under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    _listByStreamingJob(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, listByStreamingJobOperationSpec$1);
    }
    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param options The options parameters.
     */
    beginTest(resourceGroupName, jobName, outputName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, outputName, options }, testOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tests whether an outputs datasource is reachable and usable by the Azure Stream Analytics service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param outputName The name of the output.
     * @param options The options parameters.
     */
    beginTestAndWait(resourceGroupName, jobName, outputName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTest(resourceGroupName, jobName, outputName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByStreamingJobNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param nextLink The nextLink from the previous successful call to the ListByStreamingJob method.
     * @param options The options parameters.
     */
    _listByStreamingJobNext(resourceGroupName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, nextLink, options }, listByStreamingJobNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrReplaceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Output,
            headersMapper: OutputsCreateOrReplaceHeaders
        },
        201: {
            bodyMapper: Output,
            headersMapper: OutputsCreateOrReplaceHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: output,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        outputName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Output,
            headersMapper: OutputsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: output,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        outputName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        outputName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Output,
            headersMapper: OutputsGetHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        outputName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByStreamingJobOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutputListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const testOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/outputs/{outputName}/test",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceTestStatus
        },
        201: {
            bodyMapper: ResourceTestStatus
        },
        202: {
            bodyMapper: ResourceTestStatus
        },
        204: {
            bodyMapper: ResourceTestStatus
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: output1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        outputName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listByStreamingJobNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutputListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Transformations operations. */
class TransformationsImpl {
    /**
     * Initialize a new instance of the class Transformations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming
     * job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new
     *                       transformation or replace the existing one under the streaming job.
     * @param options The options parameters.
     */
    createOrReplace(resourceGroupName, jobName, transformationName, transformation, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            jobName,
            transformationName,
            transformation,
            options
        }, createOrReplaceOperationSpec$1);
    }
    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially
     * update (ie. update one or two properties) a transformation without affecting the rest the job or
     * transformation definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the
     *                       corresponding properties in the existing transformation (ie. Those properties will be updated). Any
     *                       properties that are set to null here will mean that the corresponding property in the existing
     *                       transformation will remain the same and not change as a result of this PATCH operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, jobName, transformationName, transformation, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            jobName,
            transformationName,
            transformation,
            options
        }, updateOperationSpec$2);
    }
    /**
     * Gets details about the specified transformation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, transformationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, transformationName, options }, getOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrReplaceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Transformation,
            headersMapper: TransformationsCreateOrReplaceHeaders
        },
        201: {
            bodyMapper: Transformation,
            headersMapper: TransformationsCreateOrReplaceHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: transformation,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        transformationName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$4
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Transformation,
            headersMapper: TransformationsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: transformation,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        transformationName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Transformation,
            headersMapper: TransformationsGetHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        transformationName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Functions operations. */
class FunctionsImpl {
    /**
     * Initialize a new instance of the class Functions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the functions under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    listByStreamingJob(resourceGroupName, jobName, options) {
        const iter = this.listByStreamingJobPagingAll(resourceGroupName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings);
            }
        };
    }
    listByStreamingJobPagingPage(resourceGroupName, jobName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByStreamingJob(resourceGroupName, jobName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByStreamingJobNext(resourceGroupName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByStreamingJobPagingAll(resourceGroupName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStreamingJobPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByStreamingJobPagingPage(resourceGroupName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a function or replaces an already existing function under an existing streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionParam The definition of the function that will be used to create a new function or
     *                      replace the existing one under the streaming job.
     * @param options The options parameters.
     */
    createOrReplace(resourceGroupName, jobName, functionName, functionParam, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, functionName, functionParam, options }, createOrReplaceOperationSpec);
    }
    /**
     * Updates an existing function under an existing streaming job. This can be used to partially update
     * (ie. update one or two properties) a function without affecting the rest the job or function
     * definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param functionParam A function object. The properties specified here will overwrite the
     *                      corresponding properties in the existing function (ie. Those properties will be updated). Any
     *                      properties that are set to null here will mean that the corresponding property in the existing
     *                      function will remain the same and not change as a result of this PATCH operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, jobName, functionName, functionParam, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, functionName, functionParam, options }, updateOperationSpec$1);
    }
    /**
     * Deletes a function from the streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param options The options parameters.
     */
    delete(resourceGroupName, jobName, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, functionName, options }, deleteOperationSpec$2);
    }
    /**
     * Gets details about the specified function.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, functionName, options }, getOperationSpec$2);
    }
    /**
     * Lists all of the functions under the specified streaming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param options The options parameters.
     */
    _listByStreamingJob(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, listByStreamingJobOperationSpec);
    }
    /**
     * Tests if the information provided for a function is valid. This can range from testing the
     * connection to the underlying web service behind the function or making sure the function code
     * provided is syntactically correct.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param options The options parameters.
     */
    beginTest(resourceGroupName, jobName, functionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, jobName, functionName, options }, testOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tests if the information provided for a function is valid. This can range from testing the
     * connection to the underlying web service behind the function or making sure the function code
     * provided is syntactically correct.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param options The options parameters.
     */
    beginTestAndWait(resourceGroupName, jobName, functionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTest(resourceGroupName, jobName, functionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the default definition of a function based on the parameters specified.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param functionName The name of the function.
     * @param options The options parameters.
     */
    retrieveDefaultDefinition(resourceGroupName, jobName, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, functionName, options }, retrieveDefaultDefinitionOperationSpec);
    }
    /**
     * ListByStreamingJobNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName The name of the streaming job.
     * @param nextLink The nextLink from the previous successful call to the ListByStreamingJob method.
     * @param options The options parameters.
     */
    _listByStreamingJobNext(resourceGroupName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, nextLink, options }, listByStreamingJobNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrReplaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FunctionModel,
            headersMapper: FunctionsCreateOrReplaceHeaders
        },
        201: {
            bodyMapper: FunctionModel,
            headersMapper: FunctionsCreateOrReplaceHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: functionParam,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FunctionModel,
            headersMapper: FunctionsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: functionParam,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionModel,
            headersMapper: FunctionsGetHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByStreamingJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const testOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}/test",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceTestStatus
        },
        201: {
            bodyMapper: ResourceTestStatus
        },
        202: {
            bodyMapper: ResourceTestStatus
        },
        204: {
            bodyMapper: ResourceTestStatus
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: functionParam1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const retrieveDefaultDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/functions/{functionName}/retrieveDefaultDefinition",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionModel
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: functionRetrieveDefaultDefinitionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        functionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listByStreamingJobNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Subscriptions operations. */
class SubscriptionsImpl {
    /**
     * Initialize a new instance of the class Subscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the subscription's current quota information in a particular region.
     * @param location The region in which to retrieve the subscription's quota information. You can find
     *                 out which regions Azure Stream Analytics is supported in here:
     *                 https://azure.microsoft.com/en-us/regions/
     * @param options The options parameters.
     */
    listQuotas(location, options) {
        return this.client.sendOperationRequest({ location, options }, listQuotasOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listQuotasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StreamAnalytics/locations/{location}/quotas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionQuotasListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Clusters operations. */
class ClustersImpl {
    /**
     * Initialize a new instance of the class Clusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the clusters in the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the clusters in the given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the streaming jobs in the given cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listStreamingJobs(resourceGroupName, clusterName, options) {
        const iter = this.listStreamingJobsPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listStreamingJobsPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listStreamingJobsPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listStreamingJobsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listStreamingJobs(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listStreamingJobsNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listStreamingJobsPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStreamingJobsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listStreamingJobsPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Creates a Stream Analytics Cluster or replaces an already existing cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param cluster The definition of the cluster that will be used to create a new cluster or replace
     *                the existing one.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, cluster, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a Stream Analytics Cluster or replaces an already existing cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param cluster The definition of the cluster that will be used to create a new cluster or replace
     *                the existing one.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, cluster, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing cluster. This can be used to partially update (ie. update one or two properties)
     * a cluster without affecting the rest of the cluster definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param cluster The properties specified here will overwrite the corresponding properties in the
     *                existing cluster (ie. Those properties will be updated).
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, cluster, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an existing cluster. This can be used to partially update (ie. update one or two properties)
     * a cluster without affecting the rest of the cluster definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param cluster The properties specified here will overwrite the corresponding properties in the
     *                existing cluster (ie. Those properties will be updated).
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, cluster, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getOperationSpec$1);
    }
    /**
     * Deletes the specified cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all of the clusters in the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Lists all of the clusters in the given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Lists all of the streaming jobs in the given cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listStreamingJobs(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listStreamingJobsOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListStreamingJobsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListStreamingJobs method.
     * @param options The options parameters.
     */
    _listStreamingJobsNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listStreamingJobsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: cluster,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: cluster,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StreamAnalytics/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listStreamingJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}/listStreamingJobs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClusterJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listStreamingJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterJobListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpoints operations. */
class PrivateEndpointsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the private endpoints in the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        const iter = this.listByClusterPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByClusterPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listByClusterPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCluster(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByClusterNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByClusterPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByClusterPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a Stream Analytics Private Endpoint or replaces an already existing Private Endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateEndpoint The definition of the private endpoint that will be used to create a new
     *                        cluster or replace the existing one.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, clusterName, privateEndpointName, privateEndpoint, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            clusterName,
            privateEndpointName,
            privateEndpoint,
            options
        }, createOrUpdateOperationSpec);
    }
    /**
     * Gets information about the specified Private Endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, privateEndpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, privateEndpointName, options }, getOperationSpec);
    }
    /**
     * Delete the specified private endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, privateEndpointName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified private endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, privateEndpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the private endpoints in the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec);
    }
    /**
     * ListByClusterNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListByCluster method.
     * @param options The options parameters.
     */
    _listByClusterNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listByClusterNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}/privateEndpoints/{privateEndpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        201: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: privateEndpoint,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}/privateEndpoints/{privateEndpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}/privateEndpoints/{privateEndpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer
};
const listByClusterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/clusters/{clusterName}/privateEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer
};
const listByClusterNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class StreamAnalyticsManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the StreamAnalyticsManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-streamanalytics/4.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2020-03-01";
        this.operations = new OperationsImpl(this);
        this.streamingJobs = new StreamingJobsImpl(this);
        this.inputs = new InputsImpl(this);
        this.outputs = new OutputsImpl(this);
        this.transformations = new TransformationsImpl(this);
        this.functions = new FunctionsImpl(this);
        this.subscriptions = new SubscriptionsImpl(this);
        this.clusters = new ClustersImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.StreamAnalyticsManagementClient = StreamAnalyticsManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
