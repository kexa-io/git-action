import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

/** Encryption settings */
export declare interface AccountEncryption {
    /** The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault */
    keySource?: KeySource;
    /** Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'. */
    keyVaultProperties?: KeyVaultProperties;
    /** Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'. */
    identity?: EncryptionIdentity;
}

/** Interface representing a Accounts. */
export declare interface Accounts {
    /**
     * List and describe all NetApp accounts in the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options?: AccountsListBySubscriptionOptionalParams): PagedAsyncIterableIterator<NetAppAccount>;
    /**
     * List and describe all NetApp accounts in the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName: string, options?: AccountsListOptionalParams): PagedAsyncIterableIterator<NetAppAccount>;
    /**
     * Get the NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, options?: AccountsGetOptionalParams): Promise<AccountsGetResponse>;
    /**
     * Create or update the specified NetApp account within the resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, body: NetAppAccount, options?: AccountsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AccountsCreateOrUpdateResponse>, AccountsCreateOrUpdateResponse>>;
    /**
     * Create or update the specified NetApp account within the resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, body: NetAppAccount, options?: AccountsCreateOrUpdateOptionalParams): Promise<AccountsCreateOrUpdateResponse>;
    /**
     * Delete the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<void>;
    /**
     * Patch the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, body: NetAppAccountPatch, options?: AccountsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AccountsUpdateResponse>, AccountsUpdateResponse>>;
    /**
     * Patch the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, body: NetAppAccountPatch, options?: AccountsUpdateOptionalParams): Promise<AccountsUpdateResponse>;
    /**
     * Renew identity credentials that are used to authenticate to key vault, for customer-managed key
     * encryption. If encryption.identity.principalId does not match identity.principalId, running this
     * operation will fix it.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginRenewCredentials(resourceGroupName: string, accountName: string, options?: AccountsRenewCredentialsOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Renew identity credentials that are used to authenticate to key vault, for customer-managed key
     * encryption. If encryption.identity.principalId does not match identity.principalId, running this
     * operation will fix it.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginRenewCredentialsAndWait(resourceGroupName: string, accountName: string, options?: AccountsRenewCredentialsOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface AccountsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type AccountsCreateOrUpdateResponse = NetAppAccount;

/** Optional parameters. */
export declare interface AccountsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface AccountsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type AccountsGetResponse = NetAppAccount;

/** Optional parameters. */
export declare interface AccountsListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listBySubscriptionNext operation. */
export declare type AccountsListBySubscriptionNextResponse = NetAppAccountList;

/** Optional parameters. */
export declare interface AccountsListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listBySubscription operation. */
export declare type AccountsListBySubscriptionResponse = NetAppAccountList;

/** Optional parameters. */
export declare interface AccountsListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type AccountsListNextResponse = NetAppAccountList;

/** Optional parameters. */
export declare interface AccountsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type AccountsListResponse = NetAppAccountList;

/** Optional parameters. */
export declare interface AccountsRenewCredentialsOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface AccountsUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type AccountsUpdateResponse = NetAppAccount;

/** Active Directory */
export declare interface ActiveDirectory {
    /** Id of the Active Directory */
    activeDirectoryId?: string;
    /** A domain user account with permission to create machine accounts */
    username?: string;
    /** Plain text password of Active Directory domain administrator, value is masked in the response */
    password?: string;
    /** Name of the Active Directory domain */
    domain?: string;
    /** Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain */
    dns?: string;
    /**
     * Status of the Active Directory
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly status?: ActiveDirectoryStatus;
    /**
     * Any details in regards to the Status of the Active Directory
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly statusDetails?: string;
    /** NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes */
    smbServerName?: string;
    /** The Organizational Unit (OU) within the Windows Active Directory */
    organizationalUnit?: string;
    /** The Active Directory site the service will limit Domain Controller discovery to */
    site?: string;
    /** Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier */
    backupOperators?: string[];
    /** Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier */
    administrators?: string[];
    /** kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume. */
    kdcIP?: string;
    /** Name of the active directory machine. This optional parameter is used only while creating kerberos volume */
    adName?: string;
    /** When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes. */
    serverRootCACertificate?: string;
    /** If enabled, AES encryption will be enabled for SMB communication. */
    aesEncryption?: boolean;
    /** Specifies whether or not the LDAP traffic needs to be signed. */
    ldapSigning?: boolean;
    /** Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier */
    securityOperators?: string[];
    /** Specifies whether or not the LDAP traffic needs to be secured via TLS. */
    ldapOverTLS?: boolean;
    /**  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes. */
    allowLocalNfsUsersWithLdap?: boolean;
    /** If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted. */
    encryptDCConnections?: boolean;
    /** LDAP Search scope options */
    ldapSearchScope?: LdapSearchScopeOpt;
    /** Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed. */
    preferredServersForLdapClient?: string;
}

/**
 * Defines values for ActiveDirectoryStatus. \
 * {@link KnownActiveDirectoryStatus} can be used interchangeably with ActiveDirectoryStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Created**: Active Directory created but not in use \
 * **InUse**: Active Directory in use by SMB Volume \
 * **Deleted**: Active Directory Deleted \
 * **Error**: Error with the Active Directory \
 * **Updating**: Active Directory Updating
 */
export declare type ActiveDirectoryStatus = string;

/**
 * Defines values for ApplicationType. \
 * {@link KnownApplicationType} can be used interchangeably with ApplicationType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **SAP-HANA** \
 * **ORACLE**
 */
export declare type ApplicationType = string;

/** Authorize request */
export declare interface AuthorizeRequest {
    /** Resource id of the remote volume */
    remoteVolumeResourceId?: string;
}

/**
 * Defines values for AvsDataStore. \
 * {@link KnownAvsDataStore} can be used interchangeably with AvsDataStore,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled**: avsDataStore is enabled \
 * **Disabled**: avsDataStore is disabled
 */
export declare type AvsDataStore = string;

/** Interface representing a BackupPolicies. */
export declare interface BackupPolicies {
    /**
     * List backup policies for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName: string, accountName: string, options?: BackupPoliciesListOptionalParams): PagedAsyncIterableIterator<BackupPolicy>;
    /**
     * Get a particular backup Policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesGetOptionalParams): Promise<BackupPoliciesGetResponse>;
    /**
     * Create a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicy, options?: BackupPoliciesCreateOptionalParams): Promise<SimplePollerLike<OperationState<BackupPoliciesCreateResponse>, BackupPoliciesCreateResponse>>;
    /**
     * Create a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicy, options?: BackupPoliciesCreateOptionalParams): Promise<BackupPoliciesCreateResponse>;
    /**
     * Patch a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicyPatch, options?: BackupPoliciesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BackupPoliciesUpdateResponse>, BackupPoliciesUpdateResponse>>;
    /**
     * Patch a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicyPatch, options?: BackupPoliciesUpdateOptionalParams): Promise<BackupPoliciesUpdateResponse>;
    /**
     * Delete backup policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete backup policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface BackupPoliciesCreateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the create operation. */
export declare type BackupPoliciesCreateResponse = BackupPolicy;

/** Optional parameters. */
export declare interface BackupPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface BackupPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type BackupPoliciesGetResponse = BackupPolicy;

/** List of Backup Policies */
export declare interface BackupPoliciesList {
    /** A list of backup policies */
    value?: BackupPolicy[];
}

/** Optional parameters. */
export declare interface BackupPoliciesListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type BackupPoliciesListResponse = BackupPoliciesList;

/** Optional parameters. */
export declare interface BackupPoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type BackupPoliciesUpdateResponse = BackupPolicy;

/** Backup policy information */
export declare interface BackupPolicy extends TrackedResource {
    /**
     * A unique read-only string that changes whenever the resource is updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly etag?: string;
    /**
     * Backup Policy Resource ID
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly backupPolicyId?: string;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Daily backups count to keep */
    dailyBackupsToKeep?: number;
    /** Weekly backups count to keep */
    weeklyBackupsToKeep?: number;
    /** Monthly backups count to keep */
    monthlyBackupsToKeep?: number;
    /**
     * Volumes using current backup policy
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumesAssigned?: number;
    /** The property to decide policy is enabled or not */
    enabled?: boolean;
    /**
     * A list of volumes assigned to this policy
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumeBackups?: VolumeBackups[];
}

/** Backup policy Details for create and update */
export declare interface BackupPolicyPatch {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * Backup Policy Resource ID
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly backupPolicyId?: string;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Daily backups count to keep */
    dailyBackupsToKeep?: number;
    /** Weekly backups count to keep */
    weeklyBackupsToKeep?: number;
    /** Monthly backups count to keep */
    monthlyBackupsToKeep?: number;
    /**
     * Volumes using current backup policy
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumesAssigned?: number;
    /** The property to decide policy is enabled or not */
    enabled?: boolean;
    /**
     * A list of volumes assigned to this policy
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumeBackups?: VolumeBackups[];
}

/** Interface representing a Backups. */
export declare interface Backups {
    /**
     * Get the status of the restore for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    getVolumeRestoreStatus(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsGetVolumeRestoreStatusOptionalParams): Promise<BackupsGetVolumeRestoreStatusResponse>;
}

/** Optional parameters. */
export declare interface BackupsGetVolumeRestoreStatusOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the getVolumeRestoreStatus operation. */
export declare type BackupsGetVolumeRestoreStatusResponse = RestoreStatus;

/** Break file locks request */
export declare interface BreakFileLocksRequest {
    /** To clear file locks on a volume for a particular client */
    clientIp?: string;
    /** Break File locks could be a disruptive operation for application as locks on the volume will be broken, if want to process, set to true. */
    confirmRunningDisruptiveOperation?: boolean;
}

/** Break replication request */
export declare interface BreakReplicationRequest {
    /** If replication is in status transferring and you want to force break the replication, set to true */
    forceBreakReplication?: boolean;
}

/** Capacity pool resource */
export declare interface CapacityPool extends TrackedResource {
    /**
     * A unique read-only string that changes whenever the resource is updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly etag?: string;
    /**
     * UUID v4 used to identify the Pool
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly poolId?: string;
    /** Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiply of 4398046511104). */
    size: number;
    /** The service level of the file system */
    serviceLevel: ServiceLevel;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /**
     * Total throughput of pool in MiB/s
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly totalThroughputMibps?: number;
    /**
     * Utilized throughput of pool in MiB/s
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly utilizedThroughputMibps?: number;
    /** The qos type of the pool */
    qosType?: QosType;
    /** If enabled (true) the pool can contain cool Access enabled volumes. */
    coolAccess?: boolean;
    /** Encryption type of the capacity pool, set encryption type for data at rest for this pool and all volumes in it. This value can only be set when creating new pool. */
    encryptionType?: EncryptionType;
}

/** List of capacity pool resources */
export declare interface CapacityPoolList {
    /** List of Capacity pools */
    value?: CapacityPool[];
    /** URL to get the next set of results. */
    nextLink?: string;
}

/** Capacity pool patch resource */
export declare interface CapacityPoolPatch {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiply of 4398046511104). */
    size?: number;
    /** The qos type of the pool */
    qosType?: QosType;
    /** If enabled (true) the pool can contain cool Access enabled volumes. */
    coolAccess?: boolean;
}

/** Information regarding availability of a resource. */
export declare interface CheckAvailabilityResponse {
    /** <code>true</code> indicates name is valid and available. <code>false</code> indicates the name is invalid, unavailable, or both. */
    isAvailable?: boolean;
    /** <code>Invalid</code> indicates the name provided does not match Azure App Service naming requirements. <code>AlreadyExists</code> indicates that the name is already in use and is therefore unavailable. */
    reason?: InAvailabilityReasonType;
    /** If reason == invalid, provide the user with the reason why the given name is invalid, and provide the resource naming requirements so that the user can select a valid name. If reason == AlreadyExists, explain that resource name is already in use, and direct them to select a different name. */
    message?: string;
}

/**
 * Defines values for CheckNameResourceTypes. \
 * {@link KnownCheckNameResourceTypes} can be used interchangeably with CheckNameResourceTypes,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Microsoft.NetApp\/netAppAccounts** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools\/volumes** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools\/volumes\/snapshots**
 */
export declare type CheckNameResourceTypes = string;

/**
 * Defines values for CheckQuotaNameResourceTypes. \
 * {@link KnownCheckQuotaNameResourceTypes} can be used interchangeably with CheckQuotaNameResourceTypes,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Microsoft.NetApp\/netAppAccounts** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools\/volumes** \
 * **Microsoft.NetApp\/netAppAccounts\/capacityPools\/volumes\/snapshots**
 */
export declare type CheckQuotaNameResourceTypes = string;

/**
 * Defines values for ChownMode. \
 * {@link KnownChownMode} can be used interchangeably with ChownMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Restricted** \
 * **Unrestricted**
 */
export declare type ChownMode = string;

/** An error response from the service. */
export declare interface CloudError {
    /** Cloud error body. */
    error?: CloudErrorBody;
}

/** An error response from the service. */
export declare interface CloudErrorBody {
    /** An identifier for the error. Codes are invariant and are intended to be consumed programmatically. */
    code?: string;
    /** A message describing the error, intended to be suitable for display in a user interface. */
    message?: string;
}

/**
 * Defines values for CoolAccessRetrievalPolicy. \
 * {@link KnownCoolAccessRetrievalPolicy} can be used interchangeably with CoolAccessRetrievalPolicy,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Default** \
 * **OnRead** \
 * **Never**
 */
export declare type CoolAccessRetrievalPolicy = string;

/**
 * Defines values for CreatedByType. \
 * {@link KnownCreatedByType} can be used interchangeably with CreatedByType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **User** \
 * **Application** \
 * **ManagedIdentity** \
 * **Key**
 */
export declare type CreatedByType = string;

/** Daily Schedule properties */
export declare interface DailySchedule {
    /** Daily snapshot count to keep */
    snapshotsToKeep?: number;
    /** Indicates which hour in UTC timezone a snapshot should be taken */
    hour?: number;
    /** Indicates which minute snapshot should be taken */
    minute?: number;
    /** Resource size in bytes, current storage usage for the volume in bytes */
    usedBytes?: number;
}

/** Dimension of blobs, possibly be blob type or access tier. */
export declare interface Dimension {
    /** Display name of dimension. */
    name?: string;
    /** Display name of dimension. */
    displayName?: string;
}

/**
 * Defines values for EnableSubvolumes. \
 * {@link KnownEnableSubvolumes} can be used interchangeably with EnableSubvolumes,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled**: subvolumes are enabled \
 * **Disabled**: subvolumes are not enabled
 */
export declare type EnableSubvolumes = string;

/** Identity used to authenticate with key vault. */
export declare interface EncryptionIdentity {
    /**
     * The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly principalId?: string;
    /** The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities. */
    userAssignedIdentity?: string;
}

/**
 * Defines values for EncryptionKeySource. \
 * {@link KnownEncryptionKeySource} can be used interchangeably with EncryptionKeySource,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Microsoft.NetApp**: Microsoft-managed key encryption \
 * **Microsoft.KeyVault**: Customer-managed key encryption
 */
export declare type EncryptionKeySource = string;

/**
 * Defines values for EncryptionType. \
 * {@link KnownEncryptionType} can be used interchangeably with EncryptionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Single**: EncryptionType Single, volumes will use single encryption at rest \
 * **Double**: EncryptionType Double, volumes will use double encryption at rest
 */
export declare type EncryptionType = string;

/**
 * Defines values for EndpointType. \
 * {@link KnownEndpointType} can be used interchangeably with EndpointType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **src** \
 * **dst**
 */
export declare type EndpointType = string;

/** The resource management error additional info. */
export declare interface ErrorAdditionalInfo {
    /**
     * The additional info type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * The additional info.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly info?: Record<string, unknown>;
}

/** The error detail. */
export declare interface ErrorDetail {
    /**
     * The error code.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly code?: string;
    /**
     * The error message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The error target.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly target?: string;
    /**
     * The error details.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly details?: ErrorDetail[];
    /**
     * The error additional info.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly additionalInfo?: ErrorAdditionalInfo[];
}

/** Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.). */
export declare interface ErrorResponse {
    /** The error object. */
    error?: ErrorDetail;
}

/** Volume Export Policy Rule */
export declare interface ExportPolicyRule {
    /** Order index */
    ruleIndex?: number;
    /** Read only access */
    unixReadOnly?: boolean;
    /** Read and write access */
    unixReadWrite?: boolean;
    /** Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later */
    kerberos5ReadOnly?: boolean;
    /** Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later */
    kerberos5ReadWrite?: boolean;
    /** Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later */
    kerberos5IReadOnly?: boolean;
    /** Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later */
    kerberos5IReadWrite?: boolean;
    /** Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later */
    kerberos5PReadOnly?: boolean;
    /** Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later */
    kerberos5PReadWrite?: boolean;
    /** Allows CIFS protocol */
    cifs?: boolean;
    /** Allows NFSv3 protocol. Enable only for NFSv3 type volumes */
    nfsv3?: boolean;
    /** Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes */
    nfsv41?: boolean;
    /** Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names */
    allowedClients?: string;
    /** Has root access to volume */
    hasRootAccess?: boolean;
    /** This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own. */
    chownMode?: ChownMode;
}

/**
 * Defines values for FileAccessLogs. \
 * {@link KnownFileAccessLogs} can be used interchangeably with FileAccessLogs,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled**: fileAccessLogs are enabled \
 * **Disabled**: fileAccessLogs are not enabled
 */
export declare type FileAccessLogs = string;

/** File path availability request content - availability is based on the name and the subnetId. */
export declare interface FilePathAvailabilityRequest {
    /** File path to verify. */
    name: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes */
    subnetId: string;
}

/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
export declare function getContinuationToken(page: unknown): string | undefined;

/** Get group Id list for LDAP User request */
export declare interface GetGroupIdListForLdapUserRequest {
    /** username is required to fetch the group to which user is part of */
    username: string;
}

/** Group Id list for Ldap user */
export declare interface GetGroupIdListForLdapUserResponse {
    /** Group Id list */
    groupIdsForLdapUser?: string[];
}

/** Hourly Schedule properties */
export declare interface HourlySchedule {
    /** Hourly snapshot count to keep */
    snapshotsToKeep?: number;
    /** Indicates which minute snapshot should be taken */
    minute?: number;
    /** Resource size in bytes, current storage usage for the volume in bytes */
    usedBytes?: number;
}

/**
 * Defines values for InAvailabilityReasonType. \
 * {@link KnownInAvailabilityReasonType} can be used interchangeably with InAvailabilityReasonType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Invalid** \
 * **AlreadyExists**
 */
export declare type InAvailabilityReasonType = string;

/**
 * Defines values for KeySource. \
 * {@link KnownKeySource} can be used interchangeably with KeySource,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Microsoft.NetApp**: Microsoft-managed key encryption \
 * **Microsoft.KeyVault**: Customer-managed key encryption
 */
export declare type KeySource = string;

/** Properties of key vault. */
export declare interface KeyVaultProperties {
    /**
     * UUID v4 used to identify the Azure Key Vault configuration
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly keyVaultId?: string;
    /** The Uri of KeyVault. */
    keyVaultUri: string;
    /** The name of KeyVault key. */
    keyName: string;
    /** The resource ID of KeyVault. */
    keyVaultResourceId: string;
    /**
     * Status of the KeyVault connection.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly status?: KeyVaultStatus;
}

/**
 * Defines values for KeyVaultStatus. \
 * {@link KnownKeyVaultStatus} can be used interchangeably with KeyVaultStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Created**: KeyVault connection created but not in use \
 * **InUse**: KeyVault connection in use by SMB Volume \
 * **Deleted**: KeyVault connection Deleted \
 * **Error**: Error with the KeyVault connection \
 * **Updating**: KeyVault connection Updating
 */
export declare type KeyVaultStatus = string;

/** Known values of {@link ActiveDirectoryStatus} that the service accepts. */
export declare enum KnownActiveDirectoryStatus {
    /** Active Directory created but not in use */
    Created = "Created",
    /** Active Directory in use by SMB Volume */
    InUse = "InUse",
    /** Active Directory Deleted */
    Deleted = "Deleted",
    /** Error with the Active Directory */
    Error = "Error",
    /** Active Directory Updating */
    Updating = "Updating"
}

/** Known values of {@link ApplicationType} that the service accepts. */
export declare enum KnownApplicationType {
    /** SAPHana */
    SAPHana = "SAP-HANA",
    /** Oracle */
    Oracle = "ORACLE"
}

/** Known values of {@link AvsDataStore} that the service accepts. */
export declare enum KnownAvsDataStore {
    /** avsDataStore is enabled */
    Enabled = "Enabled",
    /** avsDataStore is disabled */
    Disabled = "Disabled"
}

/** Known values of {@link CheckNameResourceTypes} that the service accepts. */
export declare enum KnownCheckNameResourceTypes {
    /** MicrosoftNetAppNetAppAccounts */
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    /** MicrosoftNetAppNetAppAccountsCapacityPools */
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes */
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots */
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

/** Known values of {@link CheckQuotaNameResourceTypes} that the service accepts. */
export declare enum KnownCheckQuotaNameResourceTypes {
    /** MicrosoftNetAppNetAppAccounts */
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    /** MicrosoftNetAppNetAppAccountsCapacityPools */
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes */
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots */
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

/** Known values of {@link ChownMode} that the service accepts. */
export declare enum KnownChownMode {
    /** Restricted */
    Restricted = "Restricted",
    /** Unrestricted */
    Unrestricted = "Unrestricted"
}

/** Known values of {@link CoolAccessRetrievalPolicy} that the service accepts. */
export declare enum KnownCoolAccessRetrievalPolicy {
    /** Default */
    Default = "Default",
    /** OnRead */
    OnRead = "OnRead",
    /** Never */
    Never = "Never"
}

/** Known values of {@link CreatedByType} that the service accepts. */
export declare enum KnownCreatedByType {
    /** User */
    User = "User",
    /** Application */
    Application = "Application",
    /** ManagedIdentity */
    ManagedIdentity = "ManagedIdentity",
    /** Key */
    Key = "Key"
}

/** Known values of {@link EnableSubvolumes} that the service accepts. */
export declare enum KnownEnableSubvolumes {
    /** subvolumes are enabled */
    Enabled = "Enabled",
    /** subvolumes are not enabled */
    Disabled = "Disabled"
}

/** Known values of {@link EncryptionKeySource} that the service accepts. */
export declare enum KnownEncryptionKeySource {
    /** Microsoft-managed key encryption */
    MicrosoftNetApp = "Microsoft.NetApp",
    /** Customer-managed key encryption */
    MicrosoftKeyVault = "Microsoft.KeyVault"
}

/** Known values of {@link EncryptionType} that the service accepts. */
export declare enum KnownEncryptionType {
    /** EncryptionType Single, volumes will use single encryption at rest */
    Single = "Single",
    /** EncryptionType Double, volumes will use double encryption at rest */
    Double = "Double"
}

/** Known values of {@link EndpointType} that the service accepts. */
export declare enum KnownEndpointType {
    /** Src */
    Src = "src",
    /** Dst */
    Dst = "dst"
}

/** Known values of {@link FileAccessLogs} that the service accepts. */
export declare enum KnownFileAccessLogs {
    /** fileAccessLogs are enabled */
    Enabled = "Enabled",
    /** fileAccessLogs are not enabled */
    Disabled = "Disabled"
}

/** Known values of {@link InAvailabilityReasonType} that the service accepts. */
export declare enum KnownInAvailabilityReasonType {
    /** Invalid */
    Invalid = "Invalid",
    /** AlreadyExists */
    AlreadyExists = "AlreadyExists"
}

/** Known values of {@link KeySource} that the service accepts. */
export declare enum KnownKeySource {
    /** Microsoft-managed key encryption */
    MicrosoftNetApp = "Microsoft.NetApp",
    /** Customer-managed key encryption */
    MicrosoftKeyVault = "Microsoft.KeyVault"
}

/** Known values of {@link KeyVaultStatus} that the service accepts. */
export declare enum KnownKeyVaultStatus {
    /** KeyVault connection created but not in use */
    Created = "Created",
    /** KeyVault connection in use by SMB Volume */
    InUse = "InUse",
    /** KeyVault connection Deleted */
    Deleted = "Deleted",
    /** Error with the KeyVault connection */
    Error = "Error",
    /** KeyVault connection Updating */
    Updating = "Updating"
}

/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
export declare enum KnownManagedServiceIdentityType {
    /** None */
    None = "None",
    /** SystemAssigned */
    SystemAssigned = "SystemAssigned",
    /** UserAssigned */
    UserAssigned = "UserAssigned",
    /** SystemAssignedUserAssigned */
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned"
}

/** Known values of {@link MetricAggregationType} that the service accepts. */
export declare enum KnownMetricAggregationType {
    /** Average */
    Average = "Average"
}

/** Known values of {@link MirrorState} that the service accepts. */
export declare enum KnownMirrorState {
    /** Uninitialized */
    Uninitialized = "Uninitialized",
    /** Mirrored */
    Mirrored = "Mirrored",
    /** Broken */
    Broken = "Broken"
}

/** Known values of {@link NetworkFeatures} that the service accepts. */
export declare enum KnownNetworkFeatures {
    /** Basic network features. */
    Basic = "Basic",
    /** Standard network features. */
    Standard = "Standard",
    /** Updating from Basic to Standard network features. */
    BasicStandard = "Basic_Standard",
    /** Updating from Standard to Basic network features. */
    StandardBasic = "Standard_Basic"
}

/** Known values of {@link NetworkSiblingSetProvisioningState} that the service accepts. */
export declare enum KnownNetworkSiblingSetProvisioningState {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** Canceled */
    Canceled = "Canceled",
    /** Updating */
    Updating = "Updating"
}

/** Known values of {@link QosType} that the service accepts. */
export declare enum KnownQosType {
    /** qos type Auto */
    Auto = "Auto",
    /** qos type Manual */
    Manual = "Manual"
}

/** Known values of {@link RegionStorageToNetworkProximity} that the service accepts. */
export declare enum KnownRegionStorageToNetworkProximity {
    /** Basic network connectivity. */
    Default = "Default",
    /** Standard T1 network connectivity. */
    T1 = "T1",
    /** Standard T2 network connectivity. */
    T2 = "T2",
    /** Standard AcrossT2 network connectivity. */
    AcrossT2 = "AcrossT2",
    /** Standard T1 and T2 network connectivity. */
    T1AndT2 = "T1AndT2",
    /** Standard T1 and AcrossT2 network connectivity. */
    T1AndAcrossT2 = "T1AndAcrossT2",
    /** Standard T2 and AcrossT2 network connectivity. */
    T2AndAcrossT2 = "T2AndAcrossT2",
    /** Standard T1, T2 and AcrossT2 network connectivity. */
    T1AndT2AndAcrossT2 = "T1AndT2AndAcrossT2"
}

/** Known values of {@link RelationshipStatus} that the service accepts. */
export declare enum KnownRelationshipStatus {
    /** Idle */
    Idle = "Idle",
    /** Transferring */
    Transferring = "Transferring"
}

/** Known values of {@link ReplicationSchedule} that the service accepts. */
export declare enum KnownReplicationSchedule {
    /** 10Minutely */
    "10Minutely" = "_10minutely",
    /** Hourly */
    Hourly = "hourly",
    /** Daily */
    Daily = "daily"
}

/** Known values of {@link SecurityStyle} that the service accepts. */
export declare enum KnownSecurityStyle {
    /** Ntfs */
    Ntfs = "ntfs",
    /** Unix */
    Unix = "unix"
}

/** Known values of {@link ServiceLevel} that the service accepts. */
export declare enum KnownServiceLevel {
    /** Standard service level */
    Standard = "Standard",
    /** Premium service level */
    Premium = "Premium",
    /** Ultra service level */
    Ultra = "Ultra",
    /** Zone redundant storage service level */
    StandardZRS = "StandardZRS"
}

/** Known values of {@link SmbAccessBasedEnumeration} that the service accepts. */
export declare enum KnownSmbAccessBasedEnumeration {
    /** smbAccessBasedEnumeration share setting is disabled */
    Disabled = "Disabled",
    /** smbAccessBasedEnumeration share setting is enabled */
    Enabled = "Enabled"
}

/** Known values of {@link SmbNonBrowsable} that the service accepts. */
export declare enum KnownSmbNonBrowsable {
    /** smbNonBrowsable share setting is disabled */
    Disabled = "Disabled",
    /** smbNonBrowsable share setting is enabled */
    Enabled = "Enabled"
}

/** Known values of {@link Type} that the service accepts. */
export declare enum KnownType {
    /** Default user quota */
    DefaultUserQuota = "DefaultUserQuota",
    /** Default group quota */
    DefaultGroupQuota = "DefaultGroupQuota",
    /** Individual user quota */
    IndividualUserQuota = "IndividualUserQuota",
    /** Individual group quota */
    IndividualGroupQuota = "IndividualGroupQuota"
}

/** Known values of {@link VolumeStorageToNetworkProximity} that the service accepts. */
export declare enum KnownVolumeStorageToNetworkProximity {
    /** Basic storage to network connectivity. */
    Default = "Default",
    /** Standard T1 storage to network connectivity. */
    T1 = "T1",
    /** Standard T2 storage to network connectivity. */
    T2 = "T2",
    /** Standard AcrossT2 storage to network connectivity. */
    AcrossT2 = "AcrossT2"
}

/** LDAP search scope */
export declare interface LdapSearchScopeOpt {
    /** This specifies the user DN, which overrides the base DN for user lookups. */
    userDN?: string;
    /** This specifies the group DN, which overrides the base DN for group lookups. */
    groupDN?: string;
    /** This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server. */
    groupMembershipFilter?: string;
}

/** List Replications */
export declare interface ListReplications {
    /** A list of replications */
    value?: Replication[];
}

/** Log Definition of a single resource metric. */
export declare interface LogSpecification {
    /** Name of log specification. */
    name?: string;
    /** Display name of log specification. */
    displayName?: string;
}

/** Managed service identity (system assigned and/or user assigned identities) */
export declare interface ManagedServiceIdentity {
    /**
     * The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly principalId?: string;
    /**
     * The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly tenantId?: string;
    /** Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed). */
    type: ManagedServiceIdentityType;
    /** The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests. */
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

/**
 * Defines values for ManagedServiceIdentityType. \
 * {@link KnownManagedServiceIdentityType} can be used interchangeably with ManagedServiceIdentityType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **None** \
 * **SystemAssigned** \
 * **UserAssigned** \
 * **SystemAssigned,UserAssigned**
 */
export declare type ManagedServiceIdentityType = string;

/**
 * Defines values for MetricAggregationType. \
 * {@link KnownMetricAggregationType} can be used interchangeably with MetricAggregationType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Average**
 */
export declare type MetricAggregationType = string;

/** Metric specification of operation. */
export declare interface MetricSpecification {
    /** Name of metric specification. */
    name?: string;
    /** Display name of metric specification. */
    displayName?: string;
    /** Display description of metric specification. */
    displayDescription?: string;
    /** Unit could be Bytes or Count. */
    unit?: string;
    /** Support metric aggregation type. */
    supportedAggregationTypes?: MetricAggregationType[];
    /** The supported time grain types for the metrics. */
    supportedTimeGrainTypes?: string[];
    /** The internal metric name. */
    internalMetricName?: string;
    /** Whether or not the service is using regional MDM accounts. */
    enableRegionalMdmAccount?: boolean;
    /** The source MDM account. */
    sourceMdmAccount?: string;
    /** The source MDM namespace. */
    sourceMdmNamespace?: string;
    /** Dimensions of blobs, including blob type and access tier. */
    dimensions?: Dimension[];
    /** Aggregation type could be Average. */
    aggregationType?: string;
    /** The property to decide fill gap with zero or not. */
    fillGapWithZero?: boolean;
    /** The category this metric specification belong to, could be Capacity. */
    category?: string;
    /** Account Resource Id. */
    resourceIdDimensionNameOverride?: string;
    /** Whether the metric is internal. */
    isInternal?: boolean;
}

/**
 * Defines values for MirrorState. \
 * {@link KnownMirrorState} can be used interchangeably with MirrorState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Uninitialized** \
 * **Mirrored** \
 * **Broken**
 */
export declare type MirrorState = string;

/** Monthly Schedule properties */
export declare interface MonthlySchedule {
    /** Monthly snapshot count to keep */
    snapshotsToKeep?: number;
    /** Indicates which days of the month snapshot should be taken. A comma delimited string. */
    daysOfMonth?: string;
    /** Indicates which hour in UTC timezone a snapshot should be taken */
    hour?: number;
    /** Indicates which minute snapshot should be taken */
    minute?: number;
    /** Resource size in bytes, current storage usage for the volume in bytes */
    usedBytes?: number;
}

/** Mount Target */
export declare interface MountTarget {
    /** Resource location */
    location: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * UUID v4 used to identify the MountTarget
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly mountTargetId?: string;
    /** UUID v4 used to identify the MountTarget */
    fileSystemId: string;
    /**
     * The mount target's IPv4 address
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ipAddress?: string;
    /** The SMB server's Fully Qualified Domain Name, FQDN */
    smbServerFqdn?: string;
}

/** Mount target properties */
export declare interface MountTargetProperties {
    /**
     * UUID v4 used to identify the MountTarget
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly mountTargetId?: string;
    /** UUID v4 used to identify the MountTarget */
    fileSystemId: string;
    /**
     * The mount target's IPv4 address
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ipAddress?: string;
    /** The SMB server's Fully Qualified Domain Name, FQDN */
    smbServerFqdn?: string;
}

/** NetApp account resource */
export declare interface NetAppAccount extends TrackedResource {
    /**
     * A unique read-only string that changes whenever the resource is updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly etag?: string;
    /** The identity used for the resource. */
    identity?: ManagedServiceIdentity;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Active Directories */
    activeDirectories?: ActiveDirectory[];
    /** Encryption settings */
    encryption?: AccountEncryption;
    /**
     * Shows the status of disableShowmount for all volumes under the subscription, null equals false
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly disableShowmount?: boolean;
}

/** List of NetApp account resources */
export declare interface NetAppAccountList {
    /** Multiple NetApp accounts */
    value?: NetAppAccount[];
    /** URL to get the next set of results. */
    nextLink?: string;
}

/** NetApp account patch resource */
export declare interface NetAppAccountPatch {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** The identity used for the resource. */
    identity?: ManagedServiceIdentity;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Active Directories */
    activeDirectories?: ActiveDirectory[];
    /** Encryption settings */
    encryption?: AccountEncryption;
    /**
     * Shows the status of disableShowmount for all volumes under the subscription, null equals false
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly disableShowmount?: boolean;
}

export declare class NetAppManagementClient extends coreClient.ServiceClient {
    $host: string;
    apiVersion: string;
    subscriptionId: string;
    /**
     * Initializes a new instance of the NetAppManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: NetAppManagementClientOptionalParams);
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    private addCustomApiVersionPolicy;
    operations: Operations;
    netAppResource: NetAppResource;
    netAppResourceQuotaLimits: NetAppResourceQuotaLimits;
    accounts: Accounts;
    pools: Pools;
    volumes: Volumes;
    snapshots: Snapshots;
    snapshotPolicies: SnapshotPolicies;
    backups: Backups;
    backupPolicies: BackupPolicies;
    volumeQuotaRules: VolumeQuotaRules;
    volumeGroups: VolumeGroups;
    subvolumes: Subvolumes;
}

/** Optional parameters. */
export declare interface NetAppManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    /** server parameter */
    $host?: string;
    /** Api Version */
    apiVersion?: string;
    /** Overrides client endpoint. */
    endpoint?: string;
}

/** Interface representing a NetAppResource. */
export declare interface NetAppResource {
    /**
     * Check if a resource name is available.
     * @param location The name of Azure region.
     * @param name Resource name to verify.
     * @param typeParam Resource type used for verification.
     * @param resourceGroup Resource group name.
     * @param options The options parameters.
     */
    checkNameAvailability(location: string, name: string, typeParam: CheckNameResourceTypes, resourceGroup: string, options?: NetAppResourceCheckNameAvailabilityOptionalParams): Promise<NetAppResourceCheckNameAvailabilityResponse>;
    /**
     * Check if a file path is available.
     * @param location The name of Azure region.
     * @param name File path to verify.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes
     * @param options The options parameters.
     */
    checkFilePathAvailability(location: string, name: string, subnetId: string, options?: NetAppResourceCheckFilePathAvailabilityOptionalParams): Promise<NetAppResourceCheckFilePathAvailabilityResponse>;
    /**
     * Check if a quota is available.
     * @param location The name of Azure region.
     * @param name Name of the resource to verify.
     * @param typeParam Resource type used for verification.
     * @param resourceGroup Resource group name.
     * @param options The options parameters.
     */
    checkQuotaAvailability(location: string, name: string, typeParam: CheckQuotaNameResourceTypes, resourceGroup: string, options?: NetAppResourceCheckQuotaAvailabilityOptionalParams): Promise<NetAppResourceCheckQuotaAvailabilityResponse>;
    /**
     * Provides storage to network proximity and logical zone mapping information.
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    queryRegionInfo(location: string, options?: NetAppResourceQueryRegionInfoOptionalParams): Promise<NetAppResourceQueryRegionInfoResponse>;
    /**
     * Get details of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param options The options parameters.
     */
    queryNetworkSiblingSet(location: string, networkSiblingSetId: string, subnetId: string, options?: NetAppResourceQueryNetworkSiblingSetOptionalParams): Promise<NetAppResourceQueryNetworkSiblingSetResponse>;
    /**
     * Update the network features of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param networkSiblingSetStateId Network sibling set state Id identifying the current state of the
     *                                 sibling set.
     * @param networkFeatures Network features available to the volume, some such
     * @param options The options parameters.
     */
    beginUpdateNetworkSiblingSet(location: string, networkSiblingSetId: string, subnetId: string, networkSiblingSetStateId: string, networkFeatures: NetworkFeatures, options?: NetAppResourceUpdateNetworkSiblingSetOptionalParams): Promise<SimplePollerLike<OperationState<NetAppResourceUpdateNetworkSiblingSetResponse>, NetAppResourceUpdateNetworkSiblingSetResponse>>;
    /**
     * Update the network features of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param networkSiblingSetStateId Network sibling set state Id identifying the current state of the
     *                                 sibling set.
     * @param networkFeatures Network features available to the volume, some such
     * @param options The options parameters.
     */
    beginUpdateNetworkSiblingSetAndWait(location: string, networkSiblingSetId: string, subnetId: string, networkSiblingSetStateId: string, networkFeatures: NetworkFeatures, options?: NetAppResourceUpdateNetworkSiblingSetOptionalParams): Promise<NetAppResourceUpdateNetworkSiblingSetResponse>;
}

/** Optional parameters. */
export declare interface NetAppResourceCheckFilePathAvailabilityOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the checkFilePathAvailability operation. */
export declare type NetAppResourceCheckFilePathAvailabilityResponse = CheckAvailabilityResponse;

/** Optional parameters. */
export declare interface NetAppResourceCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the checkNameAvailability operation. */
export declare type NetAppResourceCheckNameAvailabilityResponse = CheckAvailabilityResponse;

/** Optional parameters. */
export declare interface NetAppResourceCheckQuotaAvailabilityOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the checkQuotaAvailability operation. */
export declare type NetAppResourceCheckQuotaAvailabilityResponse = CheckAvailabilityResponse;

/** Optional parameters. */
export declare interface NetAppResourceQueryNetworkSiblingSetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the queryNetworkSiblingSet operation. */
export declare type NetAppResourceQueryNetworkSiblingSetResponse = NetworkSiblingSet;

/** Optional parameters. */
export declare interface NetAppResourceQueryRegionInfoOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the queryRegionInfo operation. */
export declare type NetAppResourceQueryRegionInfoResponse = RegionInfo;

/** Interface representing a NetAppResourceQuotaLimits. */
export declare interface NetAppResourceQuotaLimits {
    /**
     * Get the default and current limits for quotas
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    list(location: string, options?: NetAppResourceQuotaLimitsListOptionalParams): PagedAsyncIterableIterator<SubscriptionQuotaItem>;
    /**
     * Get the default and current subscription quota limit
     * @param location The name of Azure region.
     * @param quotaLimitName The name of the Quota Limit
     * @param options The options parameters.
     */
    get(location: string, quotaLimitName: string, options?: NetAppResourceQuotaLimitsGetOptionalParams): Promise<NetAppResourceQuotaLimitsGetResponse>;
}

/** Optional parameters. */
export declare interface NetAppResourceQuotaLimitsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type NetAppResourceQuotaLimitsGetResponse = SubscriptionQuotaItem;

/** Optional parameters. */
export declare interface NetAppResourceQuotaLimitsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type NetAppResourceQuotaLimitsListResponse = SubscriptionQuotaItemList;

/** Defines headers for NetAppResource_updateNetworkSiblingSet operation. */
export declare interface NetAppResourceUpdateNetworkSiblingSetHeaders {
    location?: string;
}

/** Optional parameters. */
export declare interface NetAppResourceUpdateNetworkSiblingSetOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the updateNetworkSiblingSet operation. */
export declare type NetAppResourceUpdateNetworkSiblingSetResponse = NetworkSiblingSet;

/**
 * Defines values for NetworkFeatures. \
 * {@link KnownNetworkFeatures} can be used interchangeably with NetworkFeatures,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Basic**: Basic network features. \
 * **Standard**: Standard network features. \
 * **Basic_Standard**: Updating from Basic to Standard network features. \
 * **Standard_Basic**: Updating from Standard to Basic network features.
 */
export declare type NetworkFeatures = string;

/** Describes the contents of a network sibling set. */
export declare interface NetworkSiblingSet {
    /** Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. */
    networkSiblingSetId?: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet} */
    subnetId?: string;
    /** Network sibling set state Id identifying the current state of the sibling set. */
    networkSiblingSetStateId?: string;
    /** Network features available to the volume, or current state of update. */
    networkFeatures?: NetworkFeatures;
    /**
     * Gets the status of the NetworkSiblingSet at the time the operation was called.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: NetworkSiblingSetProvisioningState;
    /** List of NIC information */
    nicInfoList?: NicInfo[];
}

/**
 * Defines values for NetworkSiblingSetProvisioningState. \
 * {@link KnownNetworkSiblingSetProvisioningState} can be used interchangeably with NetworkSiblingSetProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Failed** \
 * **Canceled** \
 * **Updating**
 */
export declare type NetworkSiblingSetProvisioningState = string;

/** NIC information and list of volumes for which the NIC has the primary mount ip address. */
export declare interface NicInfo {
    /**
     * ipAddress
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ipAddress?: string;
    /** Volume resource Ids */
    volumeResourceIds?: string[];
}

/** Microsoft.NetApp REST API operation definition. */
export declare interface Operation {
    /** Operation name: {provider}/{resource}/{operation} */
    name?: string;
    /** Display metadata associated with the operation. */
    display?: OperationDisplay;
    /** The origin of operations. */
    origin?: string;
    /** One property of operation, include metric specifications. */
    serviceSpecification?: ServiceSpecification;
}

/** Display metadata associated with the operation. */
export declare interface OperationDisplay {
    /** Service provider: Microsoft NetApp. */
    provider?: string;
    /** Resource on which the operation is performed etc. */
    resource?: string;
    /** Type of operation: get, read, delete, etc. */
    operation?: string;
    /** Operation description. */
    description?: string;
}

/** Result of the request to list Cloud Volume operations. It contains a list of operations and a URL link to get the next set of results. */
export declare interface OperationListResult {
    /** List of Storage operations supported by the Storage resource provider. */
    value?: Operation[];
}

/** Interface representing a Operations. */
export declare interface Operations {
    /**
     * Lists all of the available Microsoft.NetApp Rest API operations
     * @param options The options parameters.
     */
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

/** Optional parameters. */
export declare interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type OperationsListResponse = OperationListResult;

/** Application specific parameters for the placement of volumes in the volume group */
export declare interface PlacementKeyValuePairs {
    /** Key for an application specific parameter for the placement of volumes in the volume group */
    key: string;
    /** Value for an application specific parameter for the placement of volumes in the volume group */
    value: string;
}

/** Pool change request */
export declare interface PoolChangeRequest {
    /** Resource id of the pool to move volume to */
    newPoolResourceId: string;
}

/** Interface representing a Pools. */
export declare interface Pools {
    /**
     * List all capacity pools in the NetApp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName: string, accountName: string, options?: PoolsListOptionalParams): PagedAsyncIterableIterator<CapacityPool>;
    /**
     * Get details of the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsGetOptionalParams): Promise<PoolsGetResponse>;
    /**
     * Create or Update a capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPool, options?: PoolsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PoolsCreateOrUpdateResponse>, PoolsCreateOrUpdateResponse>>;
    /**
     * Create or Update a capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPool, options?: PoolsCreateOrUpdateOptionalParams): Promise<PoolsCreateOrUpdateResponse>;
    /**
     * Patch the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPoolPatch, options?: PoolsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PoolsUpdateResponse>, PoolsUpdateResponse>>;
    /**
     * Patch the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPoolPatch, options?: PoolsUpdateOptionalParams): Promise<PoolsUpdateResponse>;
    /**
     * Delete the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface PoolsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type PoolsCreateOrUpdateResponse = CapacityPool;

/** Optional parameters. */
export declare interface PoolsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface PoolsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type PoolsGetResponse = CapacityPool;

/** Optional parameters. */
export declare interface PoolsListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type PoolsListNextResponse = CapacityPoolList;

/** Optional parameters. */
export declare interface PoolsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type PoolsListResponse = CapacityPoolList;

/** Optional parameters. */
export declare interface PoolsUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type PoolsUpdateResponse = CapacityPool;

/** Defines values for ProvisioningState. */
export declare type ProvisioningState = "Accepted" | "Creating" | "Patching" | "Deleting" | "Moving" | "Failed" | "Succeeded";

/** The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location */
export declare interface ProxyResource extends Resource {
}

/**
 * Defines values for QosType. \
 * {@link KnownQosType} can be used interchangeably with QosType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Auto**: qos type Auto \
 * **Manual**: qos type Manual
 */
export declare type QosType = string;

/** Network sibling set query. */
export declare interface QueryNetworkSiblingSetRequest {
    /** Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. */
    networkSiblingSetId: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet} */
    subnetId: string;
}

/** Quota availability request content. */
export declare interface QuotaAvailabilityRequest {
    /** Name of the resource to verify. */
    name: string;
    /** Resource type used for verification. */
    type: CheckQuotaNameResourceTypes;
    /** Resource group name. */
    resourceGroup: string;
}

/** Re-establish request object supplied in the body of the operation. */
export declare interface ReestablishReplicationRequest {
    /** Resource id of the source volume for the replication */
    sourceVolumeId?: string;
}

/** Provides region specific information. */
export declare interface RegionInfo {
    /** Provides storage to network proximity information in the region. */
    storageToNetworkProximity?: RegionStorageToNetworkProximity;
    /** Provides logical availability zone mappings for the subscription for a region. */
    availabilityZoneMappings?: RegionInfoAvailabilityZoneMappingsItem[];
}

export declare interface RegionInfoAvailabilityZoneMappingsItem {
    /** Logical availability zone. */
    availabilityZone?: string;
    /** Available availability zone */
    isAvailable?: boolean;
}

/**
 * Defines values for RegionStorageToNetworkProximity. \
 * {@link KnownRegionStorageToNetworkProximity} can be used interchangeably with RegionStorageToNetworkProximity,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Default**: Basic network connectivity. \
 * **T1**: Standard T1 network connectivity. \
 * **T2**: Standard T2 network connectivity. \
 * **AcrossT2**: Standard AcrossT2 network connectivity. \
 * **T1AndT2**: Standard T1 and T2 network connectivity. \
 * **T1AndAcrossT2**: Standard T1 and AcrossT2 network connectivity. \
 * **T2AndAcrossT2**: Standard T2 and AcrossT2 network connectivity. \
 * **T1AndT2AndAcrossT2**: Standard T1, T2 and AcrossT2 network connectivity.
 */
export declare type RegionStorageToNetworkProximity = string;

/**
 * Defines values for RelationshipStatus. \
 * {@link KnownRelationshipStatus} can be used interchangeably with RelationshipStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Idle** \
 * **Transferring**
 */
export declare type RelationshipStatus = string;

/** Relocate volume request */
export declare interface RelocateVolumeRequest {
    /** New creation token for the volume that controls the mount point name */
    creationToken?: string;
}

/** Replication properties */
export declare interface Replication {
    /** Indicates whether the local volume is the source or destination for the Volume Replication */
    endpointType?: EndpointType;
    /** Schedule */
    replicationSchedule?: ReplicationSchedule;
    /** The resource ID of the remote volume. */
    remoteVolumeResourceId: string;
    /** The remote region for the other end of the Volume Replication. */
    remoteVolumeRegion?: string;
}

/** Replication properties */
export declare interface ReplicationObject {
    /**
     * Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly replicationId?: string;
    /** Indicates whether the local volume is the source or destination for the Volume Replication */
    endpointType?: EndpointType;
    /** Schedule */
    replicationSchedule?: ReplicationSchedule;
    /** The resource ID of the remote volume. */
    remoteVolumeResourceId: string;
    /** The remote region for the other end of the Volume Replication. */
    remoteVolumeRegion?: string;
}

/**
 * Defines values for ReplicationSchedule. \
 * {@link KnownReplicationSchedule} can be used interchangeably with ReplicationSchedule,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **_10minutely** \
 * **hourly** \
 * **daily**
 */
export declare type ReplicationSchedule = string;

/** Replication status */
export declare interface ReplicationStatus {
    /** Replication health check */
    healthy?: boolean;
    /** Status of the mirror relationship */
    relationshipStatus?: RelationshipStatus;
    /** The status of the replication */
    mirrorState?: MirrorState;
    /** The progress of the replication */
    totalProgress?: string;
    /** Displays error message if the replication is in an error state */
    errorMessage?: string;
}

/** Common fields that are returned in the response for all Azure Resource Manager resources */
export declare interface Resource {
    /**
     * Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly systemData?: SystemData;
}

/** Identity for the resource. */
export declare interface ResourceIdentity {
    /**
     * Object id of the identity resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly principalId?: string;
    /**
     * The tenant id of the resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly tenantId?: string;
    /** Type of Identity. Supported values are: 'None', 'SystemAssigned' */
    type?: string;
}

/** Resource name availability request content. */
export declare interface ResourceNameAvailabilityRequest {
    /** Resource name to verify. */
    name: string;
    /** Resource type used for verification. */
    type: CheckNameResourceTypes;
    /** Resource group name. */
    resourceGroup: string;
}

/** Restore status */
export declare interface RestoreStatus {
    /**
     * Restore health status
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly healthy?: boolean;
    /**
     * Status of the restore SnapMirror relationship
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly relationshipStatus?: RelationshipStatus;
    /**
     * The status of the restore
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly mirrorState?: MirrorState;
    /**
     * Reason for the unhealthy restore relationship
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly unhealthyReason?: string;
    /**
     * Displays error message if the restore is in an error state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly errorMessage?: string;
    /**
     * Displays the total bytes transferred
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly totalTransferBytes?: number;
}

/**
 * Defines values for SecurityStyle. \
 * {@link KnownSecurityStyle} can be used interchangeably with SecurityStyle,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **ntfs** \
 * **unix**
 */
export declare type SecurityStyle = string;

/**
 * Defines values for ServiceLevel. \
 * {@link KnownServiceLevel} can be used interchangeably with ServiceLevel,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Standard**: Standard service level \
 * **Premium**: Premium service level \
 * **Ultra**: Ultra service level \
 * **StandardZRS**: Zone redundant storage service level
 */
export declare type ServiceLevel = string;

/** One property of operation, include metric specifications. */
export declare interface ServiceSpecification {
    /** Metric specifications of operation. */
    metricSpecifications?: MetricSpecification[];
    /** Log specification of operation. */
    logSpecifications?: LogSpecification[];
}

/**
 * Defines values for SmbAccessBasedEnumeration. \
 * {@link KnownSmbAccessBasedEnumeration} can be used interchangeably with SmbAccessBasedEnumeration,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled**: smbAccessBasedEnumeration share setting is disabled \
 * **Enabled**: smbAccessBasedEnumeration share setting is enabled
 */
export declare type SmbAccessBasedEnumeration = string;

/**
 * Defines values for SmbNonBrowsable. \
 * {@link KnownSmbNonBrowsable} can be used interchangeably with SmbNonBrowsable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled**: smbNonBrowsable share setting is disabled \
 * **Enabled**: smbNonBrowsable share setting is enabled
 */
export declare type SmbNonBrowsable = string;

/** Snapshot of a Volume */
export declare interface Snapshot extends ProxyResource {
    /** Resource location */
    location: string;
    /**
     * UUID v4 used to identify the Snapshot
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly snapshotId?: string;
    /**
     * The creation date of the snapshot
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly created?: Date;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
}

/** Interface representing a SnapshotPolicies. */
export declare interface SnapshotPolicies {
    /**
     * List snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName: string, accountName: string, options?: SnapshotPoliciesListOptionalParams): PagedAsyncIterableIterator<SnapshotPolicy>;
    /**
     * Get a snapshot Policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesGetOptionalParams): Promise<SnapshotPoliciesGetResponse>;
    /**
     * Create a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    create(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicy, options?: SnapshotPoliciesCreateOptionalParams): Promise<SnapshotPoliciesCreateResponse>;
    /**
     * Patch a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicyPatch, options?: SnapshotPoliciesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotPoliciesUpdateResponse>, SnapshotPoliciesUpdateResponse>>;
    /**
     * Patch a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicyPatch, options?: SnapshotPoliciesUpdateOptionalParams): Promise<SnapshotPoliciesUpdateResponse>;
    /**
     * Delete snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesDeleteOptionalParams): Promise<void>;
    /**
     * Get volumes associated with snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    listVolumes(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesListVolumesOptionalParams): Promise<SnapshotPoliciesListVolumesResponse>;
}

/** Optional parameters. */
export declare interface SnapshotPoliciesCreateOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the create operation. */
export declare type SnapshotPoliciesCreateResponse = SnapshotPolicy;

/** Optional parameters. */
export declare interface SnapshotPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface SnapshotPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type SnapshotPoliciesGetResponse = SnapshotPolicy;

/** List of Snapshot Policies */
export declare interface SnapshotPoliciesList {
    /** A list of snapshot policies */
    value?: SnapshotPolicy[];
}

/** Optional parameters. */
export declare interface SnapshotPoliciesListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type SnapshotPoliciesListResponse = SnapshotPoliciesList;

/** Optional parameters. */
export declare interface SnapshotPoliciesListVolumesOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listVolumes operation. */
export declare type SnapshotPoliciesListVolumesResponse = SnapshotPolicyVolumeList;

/** Optional parameters. */
export declare interface SnapshotPoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type SnapshotPoliciesUpdateResponse = SnapshotPolicy;

/** Snapshot policy information */
export declare interface SnapshotPolicy extends TrackedResource {
    /**
     * A unique read-only string that changes whenever the resource is updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly etag?: string;
    /** Schedule for hourly snapshots */
    hourlySchedule?: HourlySchedule;
    /** Schedule for daily snapshots */
    dailySchedule?: DailySchedule;
    /** Schedule for weekly snapshots */
    weeklySchedule?: WeeklySchedule;
    /** Schedule for monthly snapshots */
    monthlySchedule?: MonthlySchedule;
    /** The property to decide policy is enabled or not */
    enabled?: boolean;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
}

/** Snapshot policy properties */
export declare interface SnapshotPolicyDetails {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** Schedule for hourly snapshots */
    hourlySchedule?: HourlySchedule;
    /** Schedule for daily snapshots */
    dailySchedule?: DailySchedule;
    /** Schedule for weekly snapshots */
    weeklySchedule?: WeeklySchedule;
    /** Schedule for monthly snapshots */
    monthlySchedule?: MonthlySchedule;
    /** The property to decide policy is enabled or not */
    enabled?: boolean;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
}

/** Snapshot policy Details for create and update */
export declare interface SnapshotPolicyPatch {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** Schedule for hourly snapshots */
    hourlySchedule?: HourlySchedule;
    /** Schedule for daily snapshots */
    dailySchedule?: DailySchedule;
    /** Schedule for weekly snapshots */
    weeklySchedule?: WeeklySchedule;
    /** Schedule for monthly snapshots */
    monthlySchedule?: MonthlySchedule;
    /** The property to decide policy is enabled or not */
    enabled?: boolean;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
}

/** Volumes associated with snapshot policy */
export declare interface SnapshotPolicyVolumeList {
    /** List of volumes */
    value?: Volume[];
}

/** Restore payload for Single File Snapshot Restore */
export declare interface SnapshotRestoreFiles {
    /** List of files to be restored */
    filePaths: string[];
    /** Destination folder where the files will be restored */
    destinationPath?: string;
}

/** Interface representing a Snapshots. */
export declare interface Snapshots {
    /**
     * List all snapshots associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    list(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SnapshotsListOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    /**
     * Get details of the specified snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsGetOptionalParams): Promise<SnapshotsGetResponse>;
    /**
     * Create the specified snapshot within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Snapshot, options?: SnapshotsCreateOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotsCreateResponse>, SnapshotsCreateResponse>>;
    /**
     * Create the specified snapshot within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Snapshot, options?: SnapshotsCreateOptionalParams): Promise<SnapshotsCreateResponse>;
    /**
     * Patch a snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Record<string, unknown>, options?: SnapshotsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotsUpdateResponse>, SnapshotsUpdateResponse>>;
    /**
     * Patch a snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Record<string, unknown>, options?: SnapshotsUpdateOptionalParams): Promise<SnapshotsUpdateResponse>;
    /**
     * Delete snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<void>;
    /**
     * Restore the specified files from the specified snapshot to the active filesystem
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Restore payload supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRestoreFiles(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotRestoreFiles, options?: SnapshotsRestoreFilesOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Restore the specified files from the specified snapshot to the active filesystem
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Restore payload supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRestoreFilesAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotRestoreFiles, options?: SnapshotsRestoreFilesOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface SnapshotsCreateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the create operation. */
export declare type SnapshotsCreateResponse = Snapshot;

/** Optional parameters. */
export declare interface SnapshotsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface SnapshotsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type SnapshotsGetResponse = Snapshot;

/** List of Snapshots */
export declare interface SnapshotsList {
    /** A list of Snapshots */
    value?: Snapshot[];
}

/** Optional parameters. */
export declare interface SnapshotsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type SnapshotsListResponse = SnapshotsList;

/** Optional parameters. */
export declare interface SnapshotsRestoreFilesOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface SnapshotsUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type SnapshotsUpdateResponse = Snapshot;

/** Information regarding Subscription Quota Item. */
export declare interface SubscriptionQuotaItem extends ProxyResource {
    /**
     * The current quota value.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly current?: number;
    /**
     * The default quota value.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly default?: number;
}

/** List of Subscription Quota Items */
export declare interface SubscriptionQuotaItemList {
    /** A list of SubscriptionQuotaItems */
    value?: SubscriptionQuotaItem[];
}

/** Subvolume Information properties */
export declare interface SubvolumeInfo extends ProxyResource {
    /** Path to the subvolume */
    path?: string;
    /** Truncate subvolume to the provided size in bytes */
    size?: number;
    /** parent path to the subvolume */
    parentPath?: string;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
}

/** Result of the post subvolume and action is to get metadata of the subvolume. */
export declare interface SubvolumeModel {
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Path to the subvolume */
    path?: string;
    /** Path to the parent subvolume */
    parentPath?: string;
    /** Size of subvolume */
    size?: number;
    /** Bytes used */
    bytesUsed?: number;
    /** Permissions of the subvolume */
    permissions?: string;
    /** Creation time and date */
    creationTimeStamp?: Date;
    /** Most recent access time and date */
    accessedTimeStamp?: Date;
    /** Most recent modification time and date */
    modifiedTimeStamp?: Date;
    /** Most recent change time and date */
    changedTimeStamp?: Date;
    /** Azure lifecycle management */
    provisioningState?: string;
}

/** Subvolume Patch Request properties */
export declare interface SubvolumePatchRequest {
    /** Truncate subvolume to the provided size in bytes */
    size?: number;
    /** path to the subvolume */
    path?: string;
}

/** Interface representing a Subvolumes. */
export declare interface Subvolumes {
    /**
     * Returns a list of the subvolumes in the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listByVolume(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SubvolumesListByVolumeOptionalParams): PagedAsyncIterableIterator<SubvolumeInfo>;
    /**
     * Returns the path associated with the subvolumeName provided
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetOptionalParams): Promise<SubvolumesGetResponse>;
    /**
     * Creates a subvolume in the path or clones the subvolume mentioned in the parentPath
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumeInfo, options?: SubvolumesCreateOptionalParams): Promise<SimplePollerLike<OperationState<SubvolumesCreateResponse>, SubvolumesCreateResponse>>;
    /**
     * Creates a subvolume in the path or clones the subvolume mentioned in the parentPath
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumeInfo, options?: SubvolumesCreateOptionalParams): Promise<SubvolumesCreateResponse>;
    /**
     * Patch a subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumePatchRequest, options?: SubvolumesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<SubvolumesUpdateResponse>, SubvolumesUpdateResponse>>;
    /**
     * Patch a subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumePatchRequest, options?: SubvolumesUpdateOptionalParams): Promise<SubvolumesUpdateResponse>;
    /**
     * Delete subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesDeleteOptionalParams): Promise<void>;
    /**
     * Get details of the specified subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginGetMetadata(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetMetadataOptionalParams): Promise<SimplePollerLike<OperationState<SubvolumesGetMetadataResponse>, SubvolumesGetMetadataResponse>>;
    /**
     * Get details of the specified subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginGetMetadataAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetMetadataOptionalParams): Promise<SubvolumesGetMetadataResponse>;
}

/** Optional parameters. */
export declare interface SubvolumesCreateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the create operation. */
export declare type SubvolumesCreateResponse = SubvolumeInfo;

/** Optional parameters. */
export declare interface SubvolumesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface SubvolumesGetMetadataOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the getMetadata operation. */
export declare type SubvolumesGetMetadataResponse = SubvolumeModel;

/** Optional parameters. */
export declare interface SubvolumesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type SubvolumesGetResponse = SubvolumeInfo;

/** List of Subvolumes */
export declare interface SubvolumesList {
    /** A list of Subvolumes */
    value?: SubvolumeInfo[];
    /** URL to get the next set of results. */
    nextLink?: string;
}

/** Optional parameters. */
export declare interface SubvolumesListByVolumeNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByVolumeNext operation. */
export declare type SubvolumesListByVolumeNextResponse = SubvolumesList;

/** Optional parameters. */
export declare interface SubvolumesListByVolumeOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByVolume operation. */
export declare type SubvolumesListByVolumeResponse = SubvolumesList;

/** Optional parameters. */
export declare interface SubvolumesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type SubvolumesUpdateResponse = SubvolumeInfo;

/** Metadata pertaining to creation and last modification of the resource. */
export declare interface SystemData {
    /** The identity that created the resource. */
    createdBy?: string;
    /** The type of identity that created the resource. */
    createdByType?: CreatedByType;
    /** The timestamp of resource creation (UTC). */
    createdAt?: Date;
    /** The identity that last modified the resource. */
    lastModifiedBy?: string;
    /** The type of identity that last modified the resource. */
    lastModifiedByType?: CreatedByType;
    /** The timestamp of resource last modification (UTC) */
    lastModifiedAt?: Date;
}

/** The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location' */
export declare interface TrackedResource extends Resource {
    /** Resource tags. */
    tags?: {
        [propertyName: string]: string;
    };
    /** The geo-location where the resource lives */
    location: string;
}

/**
 * Defines values for Type. \
 * {@link KnownType} can be used interchangeably with Type,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **DefaultUserQuota**: Default user quota \
 * **DefaultGroupQuota**: Default group quota \
 * **IndividualUserQuota**: Individual user quota \
 * **IndividualGroupQuota**: Individual group quota
 */
export declare type Type = string;

/** Network sibling set update. */
export declare interface UpdateNetworkSiblingSetRequest {
    /** Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. */
    networkSiblingSetId: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet} */
    subnetId: string;
    /** Network sibling set state Id identifying the current state of the sibling set. */
    networkSiblingSetStateId: string;
    /** Network features available to the volume, some such */
    networkFeatures: NetworkFeatures;
}

/** User assigned identity properties */
export declare interface UserAssignedIdentity {
    /**
     * The principal ID of the assigned identity.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly principalId?: string;
    /**
     * The client ID of the assigned identity.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly clientId?: string;
}

/** Volume resource */
export declare interface Volume extends TrackedResource {
    /**
     * A unique read-only string that changes whenever the resource is updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly etag?: string;
    /** Availability Zone */
    zones?: string[];
    /**
     * Unique FileSystem Identifier.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly fileSystemId?: string;
    /** A unique file path for the volume. Used when creating mount targets */
    creationToken: string;
    /** The service level of the file system */
    serviceLevel?: ServiceLevel;
    /** Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes. */
    usageThreshold: number;
    /** Set of export policy rules */
    exportPolicy?: VolumePropertiesExportPolicy;
    /** Set of protocol types, default NFSv3, CIFS for SMB protocol */
    protocolTypes?: string[];
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** UUID v4 or resource identifier used to identify the Snapshot. */
    snapshotId?: string;
    /** If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false */
    deleteBaseSnapshot?: boolean;
    /** UUID v4 or resource identifier used to identify the Backup. */
    backupId?: string;
    /**
     * Unique Baremetal Tenant Identifier.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly baremetalTenantId?: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes */
    subnetId: string;
    /** Network features available to the volume, or current state of update. */
    networkFeatures?: NetworkFeatures;
    /**
     * Network Sibling Set ID for the the group of volumes sharing networking resources.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly networkSiblingSetId?: string;
    /**
     * Provides storage to network proximity information for the volume.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    /**
     * List of mount targets
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly mountTargets?: MountTargetProperties[];
    /** What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection */
    volumeType?: string;
    /** DataProtection type volumes include an object containing details of the replication */
    dataProtection?: VolumePropertiesDataProtection;
    /** Restoring */
    isRestoring?: boolean;
    /** If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true). */
    snapshotDirectoryVisible?: boolean;
    /** Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later */
    kerberosEnabled?: boolean;
    /** The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol */
    securityStyle?: SecurityStyle;
    /** Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later */
    smbEncryption?: boolean;
    /** Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration;
    /** Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbNonBrowsable?: SmbNonBrowsable;
    /** Enables continuously available share property for smb volume. Only applicable for SMB volume */
    smbContinuouslyAvailable?: boolean;
    /** Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume */
    throughputMibps?: number;
    /**
     * Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly actualThroughputMibps?: number;
    /** Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault' */
    encryptionKeySource?: EncryptionKeySource;
    /** The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. */
    keyVaultPrivateEndpointResourceId?: string;
    /** Specifies whether LDAP is enabled or not for a given NFS volume. */
    ldapEnabled?: boolean;
    /** Specifies whether Cool Access(tiering) is enabled for the volume. */
    coolAccess?: boolean;
    /** Specifies the number of days after which data that is not accessed by clients will be tiered. */
    coolnessPeriod?: number;
    /**
     * coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
     *  Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
     *  OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
     *  Never - No client-driven data is pulled from cool tier to standard storage.
     */
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    /** UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. */
    unixPermissions?: string;
    /**
     * When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly cloneProgress?: number;
    /**
     * Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly fileAccessLogs?: FileAccessLogs;
    /** Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose */
    avsDataStore?: AvsDataStore;
    /**
     * Data store resource unique identifier
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly dataStoreResourceId?: string[];
    /** Specifies if default quota is enabled for the volume. */
    isDefaultQuotaEnabled?: boolean;
    /** Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . */
    defaultUserQuotaInKiBs?: number;
    /** Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. */
    defaultGroupQuotaInKiBs?: number;
    /**
     * Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly maximumNumberOfFiles?: number;
    /**
     * Volume Group Name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumeGroupName?: string;
    /** Pool Resource Id used in case of creating a volume through volume group */
    capacityPoolResourceId?: string;
    /** Proximity placement group associated with the volume */
    proximityPlacementGroup?: string;
    /**
     * T2 network information
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly t2Network?: string;
    /** Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log */
    volumeSpecName?: string;
    /**
     * Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly encrypted?: boolean;
    /** Application specific placement rules for the particular volume */
    placementRules?: PlacementKeyValuePairs[];
    /** Flag indicating whether subvolume operations are enabled on the volume */
    enableSubvolumes?: EnableSubvolumes;
    /**
     * The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisionedAvailabilityZone?: string;
    /** Specifies whether volume is a Large Volume or Regular Volume. */
    isLargeVolume?: boolean;
    /**
     * Id of the snapshot or backup that the volume is restored from.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly originatingResourceId?: string;
}

/** Volume details using the backup policy */
export declare interface VolumeBackups {
    /** Volume name */
    volumeName?: string;
    /** Total count of backups for volume */
    backupsCount?: number;
    /** Policy enabled */
    policyEnabled?: boolean;
}

/** Volume group resource */
export declare interface VolumeGroup {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Volume group details */
    groupMetaData?: VolumeGroupMetaData;
}

/** Volume group resource for create */
export declare interface VolumeGroupDetails {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** Volume group details */
    groupMetaData?: VolumeGroupMetaData;
    /** List of volumes from group */
    volumes?: VolumeGroupVolumeProperties[];
}

/** List of volume group resources */
export declare interface VolumeGroupList {
    /** List of volume Groups */
    value?: VolumeGroup[];
}

/** Volume group properties */
export declare interface VolumeGroupMetaData {
    /** Group Description */
    groupDescription?: string;
    /** Application Type */
    applicationType?: ApplicationType;
    /** Application specific identifier */
    applicationIdentifier?: string;
    /** Application specific placement rules for the volume group */
    globalPlacementRules?: PlacementKeyValuePairs[];
    /** Application specific identifier of deployment rules for the volume group */
    deploymentSpecId?: string;
    /**
     * Number of volumes in volume group
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumesCount?: number;
}

/** Interface representing a VolumeGroups. */
export declare interface VolumeGroups {
    /**
     * List all volume groups for given account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    listByNetAppAccount(resourceGroupName: string, accountName: string, options?: VolumeGroupsListByNetAppAccountOptionalParams): PagedAsyncIterableIterator<VolumeGroup>;
    /**
     * Get details of the specified volume group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsGetOptionalParams): Promise<VolumeGroupsGetResponse>;
    /**
     * Create a volume group along with specified volumes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param body Volume Group object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName: string, accountName: string, volumeGroupName: string, body: VolumeGroupDetails, options?: VolumeGroupsCreateOptionalParams): Promise<SimplePollerLike<OperationState<VolumeGroupsCreateResponse>, VolumeGroupsCreateResponse>>;
    /**
     * Create a volume group along with specified volumes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param body Volume Group object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName: string, accountName: string, volumeGroupName: string, body: VolumeGroupDetails, options?: VolumeGroupsCreateOptionalParams): Promise<VolumeGroupsCreateResponse>;
    /**
     * Delete the specified volume group only if there are no volumes under volume group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete the specified volume group only if there are no volumes under volume group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface VolumeGroupsCreateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the create operation. */
export declare type VolumeGroupsCreateResponse = VolumeGroupDetails;

/** Optional parameters. */
export declare interface VolumeGroupsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumeGroupsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type VolumeGroupsGetResponse = VolumeGroupDetails;

/** Optional parameters. */
export declare interface VolumeGroupsListByNetAppAccountOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByNetAppAccount operation. */
export declare type VolumeGroupsListByNetAppAccountResponse = VolumeGroupList;

/** Volume resource */
export declare interface VolumeGroupVolumeProperties {
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /** Resource name */
    name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** Availability Zone */
    zones?: string[];
    /**
     * Unique FileSystem Identifier.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly fileSystemId?: string;
    /** A unique file path for the volume. Used when creating mount targets */
    creationToken: string;
    /** The service level of the file system */
    serviceLevel?: ServiceLevel;
    /** Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes. */
    usageThreshold: number;
    /** Set of export policy rules */
    exportPolicy?: VolumePropertiesExportPolicy;
    /** Set of protocol types, default NFSv3, CIFS for SMB protocol */
    protocolTypes?: string[];
    /**
     * Azure lifecycle management
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /** UUID v4 or resource identifier used to identify the Snapshot. */
    snapshotId?: string;
    /** If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false */
    deleteBaseSnapshot?: boolean;
    /** UUID v4 or resource identifier used to identify the Backup. */
    backupId?: string;
    /**
     * Unique Baremetal Tenant Identifier.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly baremetalTenantId?: string;
    /** The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes */
    subnetId: string;
    /** Network features available to the volume, or current state of update. */
    networkFeatures?: NetworkFeatures;
    /**
     * Network Sibling Set ID for the the group of volumes sharing networking resources.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly networkSiblingSetId?: string;
    /**
     * Provides storage to network proximity information for the volume.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    /**
     * List of mount targets
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly mountTargets?: MountTargetProperties[];
    /** What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection */
    volumeType?: string;
    /** DataProtection type volumes include an object containing details of the replication */
    dataProtection?: VolumePropertiesDataProtection;
    /** Restoring */
    isRestoring?: boolean;
    /** If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true). */
    snapshotDirectoryVisible?: boolean;
    /** Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later */
    kerberosEnabled?: boolean;
    /** The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol */
    securityStyle?: SecurityStyle;
    /** Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later */
    smbEncryption?: boolean;
    /** Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration;
    /** Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbNonBrowsable?: SmbNonBrowsable;
    /** Enables continuously available share property for smb volume. Only applicable for SMB volume */
    smbContinuouslyAvailable?: boolean;
    /** Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume */
    throughputMibps?: number;
    /**
     * Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly actualThroughputMibps?: number;
    /** Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault' */
    encryptionKeySource?: EncryptionKeySource;
    /** The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. */
    keyVaultPrivateEndpointResourceId?: string;
    /** Specifies whether LDAP is enabled or not for a given NFS volume. */
    ldapEnabled?: boolean;
    /** Specifies whether Cool Access(tiering) is enabled for the volume. */
    coolAccess?: boolean;
    /** Specifies the number of days after which data that is not accessed by clients will be tiered. */
    coolnessPeriod?: number;
    /**
     * coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
     *  Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
     *  OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
     *  Never - No client-driven data is pulled from cool tier to standard storage.
     */
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    /** UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. */
    unixPermissions?: string;
    /**
     * When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly cloneProgress?: number;
    /**
     * Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly fileAccessLogs?: FileAccessLogs;
    /** Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose */
    avsDataStore?: AvsDataStore;
    /**
     * Data store resource unique identifier
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly dataStoreResourceId?: string[];
    /** Specifies if default quota is enabled for the volume. */
    isDefaultQuotaEnabled?: boolean;
    /** Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . */
    defaultUserQuotaInKiBs?: number;
    /** Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. */
    defaultGroupQuotaInKiBs?: number;
    /**
     * Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly maximumNumberOfFiles?: number;
    /**
     * Volume Group Name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly volumeGroupName?: string;
    /** Pool Resource Id used in case of creating a volume through volume group */
    capacityPoolResourceId?: string;
    /** Proximity placement group associated with the volume */
    proximityPlacementGroup?: string;
    /**
     * T2 network information
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly t2Network?: string;
    /** Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log */
    volumeSpecName?: string;
    /**
     * Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly encrypted?: boolean;
    /** Application specific placement rules for the particular volume */
    placementRules?: PlacementKeyValuePairs[];
    /** Flag indicating whether subvolume operations are enabled on the volume */
    enableSubvolumes?: EnableSubvolumes;
    /**
     * The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisionedAvailabilityZone?: string;
    /** Specifies whether volume is a Large Volume or Regular Volume. */
    isLargeVolume?: boolean;
    /**
     * Id of the snapshot or backup that the volume is restored from.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly originatingResourceId?: string;
}

/** List of volume resources */
export declare interface VolumeList {
    /** List of volumes */
    value?: Volume[];
    /** URL to get the next set of results. */
    nextLink?: string;
}

/** Volume patch resource */
export declare interface VolumePatch {
    /** Resource location */
    location?: string;
    /**
     * Resource Id
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /** The service level of the file system */
    serviceLevel?: ServiceLevel;
    /** Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes. */
    usageThreshold?: number;
    /** Set of export policy rules */
    exportPolicy?: VolumePatchPropertiesExportPolicy;
    /** Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume */
    throughputMibps?: number;
    /** DataProtection type volumes include an object containing details of the replication */
    dataProtection?: VolumePatchPropertiesDataProtection;
    /** Specifies if default quota is enabled for the volume. */
    isDefaultQuotaEnabled?: boolean;
    /** Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . */
    defaultUserQuotaInKiBs?: number;
    /** Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. */
    defaultGroupQuotaInKiBs?: number;
    /** UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. */
    unixPermissions?: string;
    /** Specifies whether Cool Access(tiering) is enabled for the volume. */
    coolAccess?: boolean;
    /** Specifies the number of days after which data that is not accessed by clients will be tiered. */
    coolnessPeriod?: number;
    /**
     * coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
     *  Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
     *  OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
     *  Never - No client-driven data is pulled from cool tier to standard storage.
     */
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    /** If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots. */
    snapshotDirectoryVisible?: boolean;
    /** Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration;
    /** Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume */
    smbNonBrowsable?: SmbNonBrowsable;
}

/** DataProtection type volumes include an object containing details of the replication */
export declare interface VolumePatchPropertiesDataProtection {
    /** Snapshot properties. */
    snapshot?: VolumeSnapshotProperties;
}

/** Set of export policy rules */
export declare interface VolumePatchPropertiesExportPolicy {
    /** Export policy rule */
    rules?: ExportPolicyRule[];
}

/** DataProtection type volumes include an object containing details of the replication */
export declare interface VolumePropertiesDataProtection {
    /** Replication properties */
    replication?: ReplicationObject;
    /** Snapshot properties. */
    snapshot?: VolumeSnapshotProperties;
    /** VolumeRelocation properties */
    volumeRelocation?: VolumeRelocationProperties;
}

/** Set of export policy rules */
export declare interface VolumePropertiesExportPolicy {
    /** Export policy rule */
    rules?: ExportPolicyRule[];
}

/** Quota Rule of a Volume */
export declare interface VolumeQuotaRule extends TrackedResource {
    /**
     * Gets the status of the VolumeQuotaRule at the time the operation was called.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: ProvisioningState;
    /** Size of quota */
    quotaSizeInKiBs?: number;
    /** Type of quota */
    quotaType?: Type;
    /** UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid> */
    quotaTarget?: string;
}

/** Patchable Quota Rule of a Volume */
export declare interface VolumeQuotaRulePatch {
    /** Resource tags */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * Gets the status of the VolumeQuotaRule at the time the operation was called.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: ProvisioningState;
    /** Size of quota */
    quotaSizeInKiBs?: number;
    /** Type of quota */
    quotaType?: Type;
    /** UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid> */
    quotaTarget?: string;
}

/** Interface representing a VolumeQuotaRules. */
export declare interface VolumeQuotaRules {
    /**
     * List all quota rules associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listByVolume(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumeQuotaRulesListByVolumeOptionalParams): PagedAsyncIterableIterator<VolumeQuotaRule>;
    /**
     * Get details of the specified quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesGetOptionalParams): Promise<VolumeQuotaRulesGetResponse>;
    /**
     * Create the specified quota rule within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRule, options?: VolumeQuotaRulesCreateOptionalParams): Promise<SimplePollerLike<OperationState<VolumeQuotaRulesCreateResponse>, VolumeQuotaRulesCreateResponse>>;
    /**
     * Create the specified quota rule within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRule, options?: VolumeQuotaRulesCreateOptionalParams): Promise<VolumeQuotaRulesCreateResponse>;
    /**
     * Patch a quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRulePatch, options?: VolumeQuotaRulesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VolumeQuotaRulesUpdateResponse>, VolumeQuotaRulesUpdateResponse>>;
    /**
     * Patch a quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRulePatch, options?: VolumeQuotaRulesUpdateOptionalParams): Promise<VolumeQuotaRulesUpdateResponse>;
    /**
     * Delete quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface VolumeQuotaRulesCreateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the create operation. */
export declare type VolumeQuotaRulesCreateResponse = VolumeQuotaRule;

/** Optional parameters. */
export declare interface VolumeQuotaRulesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumeQuotaRulesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type VolumeQuotaRulesGetResponse = VolumeQuotaRule;

/** List of Volume Quota Rules */
export declare interface VolumeQuotaRulesList {
    /** A list of Volume Quota Rules */
    value?: VolumeQuotaRule[];
}

/** Optional parameters. */
export declare interface VolumeQuotaRulesListByVolumeOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByVolume operation. */
export declare type VolumeQuotaRulesListByVolumeResponse = VolumeQuotaRulesList;

/** Optional parameters. */
export declare interface VolumeQuotaRulesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type VolumeQuotaRulesUpdateResponse = VolumeQuotaRule;

/** Volume relocation properties */
export declare interface VolumeRelocationProperties {
    /** Has relocation been requested for this volume */
    relocationRequested?: boolean;
    /**
     * Has relocation finished and is ready to be cleaned up
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly readyToBeFinalized?: boolean;
}

/** revert a volume to the snapshot */
export declare interface VolumeRevert {
    /** Resource id of the snapshot */
    snapshotId?: string;
}

/** Interface representing a Volumes. */
export declare interface Volumes {
    /**
     * List all volumes within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    list(resourceGroupName: string, accountName: string, poolName: string, options?: VolumesListOptionalParams): PagedAsyncIterableIterator<Volume>;
    /**
     * List all replications for a specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listReplications(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesListReplicationsOptionalParams): PagedAsyncIterableIterator<Replication>;
    /**
     * Get the details of the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesGetOptionalParams): Promise<VolumesGetResponse>;
    /**
     * Create or update the specified volume within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VolumesCreateOrUpdateResponse>, VolumesCreateOrUpdateResponse>>;
    /**
     * Create or update the specified volume within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<VolumesCreateOrUpdateResponse>;
    /**
     * Patch the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumePatch, options?: VolumesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VolumesUpdateResponse>, VolumesUpdateResponse>>;
    /**
     * Patch the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumePatch, options?: VolumesUpdateOptionalParams): Promise<VolumesUpdateResponse>;
    /**
     * Delete the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<void>;
    /**
     * This operation will populate availability zone information for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginPopulateAvailabilityZone(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesPopulateAvailabilityZoneOptionalParams): Promise<SimplePollerLike<OperationState<VolumesPopulateAvailabilityZoneResponse>, VolumesPopulateAvailabilityZoneResponse>>;
    /**
     * This operation will populate availability zone information for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginPopulateAvailabilityZoneAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesPopulateAvailabilityZoneOptionalParams): Promise<VolumesPopulateAvailabilityZoneResponse>;
    /**
     * Revert a volume to the snapshot specified in the body
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Object for snapshot to revert supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRevert(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumeRevert, options?: VolumesRevertOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Revert a volume to the snapshot specified in the body
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Object for snapshot to revert supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRevertAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumeRevert, options?: VolumesRevertOptionalParams): Promise<void>;
    /**
     * Reset cifs password from volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResetCifsPassword(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResetCifsPasswordOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Reset cifs password from volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResetCifsPasswordAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResetCifsPasswordOptionalParams): Promise<void>;
    /**
     * Break all the file locks on a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakFileLocks(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakFileLocksOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Break all the file locks on a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakFileLocksAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakFileLocksOptionalParams): Promise<void>;
    /**
     * Returns the list of group Ids for a specific LDAP User
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Returns group Id list for a specific LDAP user
     * @param options The options parameters.
     */
    beginListGetGroupIdListForLdapUser(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: GetGroupIdListForLdapUserRequest, options?: VolumesListGetGroupIdListForLdapUserOptionalParams): Promise<SimplePollerLike<OperationState<VolumesListGetGroupIdListForLdapUserResponse>, VolumesListGetGroupIdListForLdapUserResponse>>;
    /**
     * Returns the list of group Ids for a specific LDAP User
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Returns group Id list for a specific LDAP user
     * @param options The options parameters.
     */
    beginListGetGroupIdListForLdapUserAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: GetGroupIdListForLdapUserRequest, options?: VolumesListGetGroupIdListForLdapUserOptionalParams): Promise<VolumesListGetGroupIdListForLdapUserResponse>;
    /**
     * Break the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Break the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakReplicationOptionalParams): Promise<void>;
    /**
     * Re-establish a previously deleted replication between 2 volumes that have a common ad-hoc or
     * policy-based snapshots
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body body for the id of the source volume.
     * @param options The options parameters.
     */
    beginReestablishReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: ReestablishReplicationRequest, options?: VolumesReestablishReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Re-establish a previously deleted replication between 2 volumes that have a common ad-hoc or
     * policy-based snapshots
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body body for the id of the source volume.
     * @param options The options parameters.
     */
    beginReestablishReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: ReestablishReplicationRequest, options?: VolumesReestablishReplicationOptionalParams): Promise<void>;
    /**
     * Get the status of the replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    replicationStatus(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReplicationStatusOptionalParams): Promise<VolumesReplicationStatusResponse>;
    /**
     * Resync the connection on the destination volume. If the operation is ran on the source volume it
     * will reverse-resync the connection and sync from destination to source.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResyncReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResyncReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Resync the connection on the destination volume. If the operation is ran on the source volume it
     * will reverse-resync the connection and sync from destination to source.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResyncReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResyncReplicationOptionalParams): Promise<void>;
    /**
     * Delete the replication connection on the destination volume, and send release to the source
     * replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Delete the replication connection on the destination volume, and send release to the source
     * replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteReplicationOptionalParams): Promise<void>;
    /**
     * Authorize the replication connection on the source volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Authorize request object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginAuthorizeReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: AuthorizeRequest, options?: VolumesAuthorizeReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Authorize the replication connection on the source volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Authorize request object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginAuthorizeReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: AuthorizeRequest, options?: VolumesAuthorizeReplicationOptionalParams): Promise<void>;
    /**
     * Re-Initializes the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginReInitializeReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReInitializeReplicationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Re-Initializes the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginReInitializeReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReInitializeReplicationOptionalParams): Promise<void>;
    /**
     * Moves volume to another pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Move volume to the pool supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginPoolChange(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PoolChangeRequest, options?: VolumesPoolChangeOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Moves volume to another pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Move volume to the pool supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginPoolChangeAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PoolChangeRequest, options?: VolumesPoolChangeOptionalParams): Promise<void>;
    /**
     * Relocates volume to a new stamp
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRelocate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRelocateOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Relocates volume to a new stamp
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRelocateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRelocateOptionalParams): Promise<void>;
    /**
     * Finalizes the relocation of the volume and cleans up the old volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginFinalizeRelocation(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeRelocationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Finalizes the relocation of the volume and cleans up the old volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginFinalizeRelocationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeRelocationOptionalParams): Promise<void>;
    /**
     * Reverts the volume relocation process, cleans up the new volume and starts using the former-existing
     * volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRevertRelocation(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRevertRelocationOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Reverts the volume relocation process, cleans up the new volume and starts using the former-existing
     * volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRevertRelocationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRevertRelocationOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface VolumesAuthorizeReplicationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Defines headers for Volumes_breakFileLocks operation. */
export declare interface VolumesBreakFileLocksHeaders {
    location?: string;
}

/** Optional parameters. */
export declare interface VolumesBreakFileLocksOptionalParams extends coreClient.OperationOptions {
    /** Optional body to provide the ability to clear file locks with selected options */
    body?: BreakFileLocksRequest;
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesBreakReplicationOptionalParams extends coreClient.OperationOptions {
    /** Optional body to force break the replication. */
    body?: BreakReplicationRequest;
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type VolumesCreateOrUpdateResponse = Volume;

/** Optional parameters. */
export declare interface VolumesDeleteOptionalParams extends coreClient.OperationOptions {
    /** An option to force delete the volume. Will cleanup resources connected to the particular volume */
    forceDelete?: boolean;
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesDeleteReplicationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesFinalizeRelocationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type VolumesGetResponse = Volume;

/** Defines headers for Volumes_listGetGroupIdListForLdapUser operation. */
export declare interface VolumesListGetGroupIdListForLdapUserHeaders {
    location?: string;
}

/** Optional parameters. */
export declare interface VolumesListGetGroupIdListForLdapUserOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the listGetGroupIdListForLdapUser operation. */
export declare type VolumesListGetGroupIdListForLdapUserResponse = GetGroupIdListForLdapUserResponse;

/** Optional parameters. */
export declare interface VolumesListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type VolumesListNextResponse = VolumeList;

/** Optional parameters. */
export declare interface VolumesListOptionalParams extends coreClient.OperationOptions {
}

/** Optional parameters. */
export declare interface VolumesListReplicationsOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listReplications operation. */
export declare type VolumesListReplicationsResponse = ListReplications;

/** Contains response data for the list operation. */
export declare type VolumesListResponse = VolumeList;

/** Volume Snapshot Properties */
export declare interface VolumeSnapshotProperties {
    /** Snapshot Policy ResourceId */
    snapshotPolicyId?: string;
}

/** Optional parameters. */
export declare interface VolumesPoolChangeOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Defines headers for Volumes_populateAvailabilityZone operation. */
export declare interface VolumesPopulateAvailabilityZoneHeaders {
    location?: string;
}

/** Optional parameters. */
export declare interface VolumesPopulateAvailabilityZoneOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the populateAvailabilityZone operation. */
export declare type VolumesPopulateAvailabilityZoneResponse = Volume;

/** Optional parameters. */
export declare interface VolumesReestablishReplicationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesReInitializeReplicationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesRelocateOptionalParams extends coreClient.OperationOptions {
    /** Relocate volume request */
    body?: RelocateVolumeRequest;
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesReplicationStatusOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the replicationStatus operation. */
export declare type VolumesReplicationStatusResponse = ReplicationStatus;

/** Optional parameters. */
export declare interface VolumesResetCifsPasswordOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesResyncReplicationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesRevertOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface VolumesRevertRelocationOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/**
 * Defines values for VolumeStorageToNetworkProximity. \
 * {@link KnownVolumeStorageToNetworkProximity} can be used interchangeably with VolumeStorageToNetworkProximity,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Default**: Basic storage to network connectivity. \
 * **T1**: Standard T1 storage to network connectivity. \
 * **T2**: Standard T2 storage to network connectivity. \
 * **AcrossT2**: Standard AcrossT2 storage to network connectivity.
 */
export declare type VolumeStorageToNetworkProximity = string;

/** Optional parameters. */
export declare interface VolumesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type VolumesUpdateResponse = Volume;

/** Weekly Schedule properties, make a snapshot every week at a specific day or days */
export declare interface WeeklySchedule {
    /** Weekly snapshot count to keep */
    snapshotsToKeep?: number;
    /** Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english */
    day?: string;
    /** Indicates which hour in UTC timezone a snapshot should be taken */
    hour?: number;
    /** Indicates which minute snapshot should be taken */
    minute?: number;
    /** Resource size in bytes, current storage usage for the volume in bytes */
    usedBytes?: number;
}

export { }
