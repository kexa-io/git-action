import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { LightsailServiceException as __BaseException } from "./LightsailServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const AccessDirection: {
  readonly inbound: "inbound";
  readonly outbound: "outbound";
};
export type AccessDirection =
  (typeof AccessDirection)[keyof typeof AccessDirection];
export interface AccessKeyLastUsed {
  lastUsedDate?: Date;
  region?: string;
  serviceName?: string;
}
export declare const StatusType: {
  readonly Active: "Active";
  readonly Inactive: "Inactive";
};
export type StatusType = (typeof StatusType)[keyof typeof StatusType];
export interface AccessKey {
  accessKeyId?: string;
  secretAccessKey?: string;
  status?: StatusType;
  createdAt?: Date;
  lastUsed?: AccessKeyLastUsed;
}
export interface ResourceReceivingAccess {
  name?: string;
  resourceType?: string;
}
export declare const AccessType: {
  readonly Private: "private";
  readonly Public: "public";
};
export type AccessType = (typeof AccessType)[keyof typeof AccessType];
export interface AccessRules {
  getObject?: AccessType;
  allowPublicOverrides?: boolean;
}
export declare const BPAStatusMessage: {
  readonly DEFAULTED_FOR_SLR_MISSING: "DEFAULTED_FOR_SLR_MISSING";
  readonly DEFAULTED_FOR_SLR_MISSING_ON_HOLD: "DEFAULTED_FOR_SLR_MISSING_ON_HOLD";
  readonly SYNC_ON_HOLD: "SYNC_ON_HOLD";
  readonly Unknown: "Unknown";
};
export type BPAStatusMessage =
  (typeof BPAStatusMessage)[keyof typeof BPAStatusMessage];
export declare const AccountLevelBpaSyncStatus: {
  readonly Defaulted: "Defaulted";
  readonly Failed: "Failed";
  readonly InSync: "InSync";
  readonly NeverSynced: "NeverSynced";
};
export type AccountLevelBpaSyncStatus =
  (typeof AccountLevelBpaSyncStatus)[keyof typeof AccountLevelBpaSyncStatus];
export interface AccountLevelBpaSync {
  status?: AccountLevelBpaSyncStatus;
  lastSyncedAt?: Date;
  message?: BPAStatusMessage;
  bpaImpactsLightsail?: boolean;
}
export declare class AccountSetupInProgressException extends __BaseException {
  readonly name: "AccountSetupInProgressException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(
    opts: __ExceptionOptionType<
      AccountSetupInProgressException,
      __BaseException
    >
  );
}
export interface AddOn {
  name?: string;
  status?: string;
  snapshotTimeOfDay?: string;
  nextSnapshotTimeOfDay?: string;
  threshold?: string;
  duration?: string;
}
export declare const AddOnType: {
  readonly AutoSnapshot: "AutoSnapshot";
  readonly StopInstanceOnIdle: "StopInstanceOnIdle";
};
export type AddOnType = (typeof AddOnType)[keyof typeof AddOnType];
export interface AutoSnapshotAddOnRequest {
  snapshotTimeOfDay?: string;
}
export interface StopInstanceOnIdleRequest {
  threshold?: string;
  duration?: string;
}
export interface AddOnRequest {
  addOnType: AddOnType | undefined;
  autoSnapshotAddOnRequest?: AutoSnapshotAddOnRequest;
  stopInstanceOnIdleRequest?: StopInstanceOnIdleRequest;
}
export declare const ComparisonOperator: {
  readonly GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold";
  readonly GreaterThanThreshold: "GreaterThanThreshold";
  readonly LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold";
  readonly LessThanThreshold: "LessThanThreshold";
};
export type ComparisonOperator =
  (typeof ComparisonOperator)[keyof typeof ComparisonOperator];
export declare const ContactProtocol: {
  readonly Email: "Email";
  readonly SMS: "SMS";
};
export type ContactProtocol =
  (typeof ContactProtocol)[keyof typeof ContactProtocol];
export declare const RegionName: {
  readonly AP_NORTHEAST_1: "ap-northeast-1";
  readonly AP_NORTHEAST_2: "ap-northeast-2";
  readonly AP_SOUTHEAST_1: "ap-southeast-1";
  readonly AP_SOUTHEAST_2: "ap-southeast-2";
  readonly AP_SOUTH_1: "ap-south-1";
  readonly CA_CENTRAL_1: "ca-central-1";
  readonly EU_CENTRAL_1: "eu-central-1";
  readonly EU_NORTH_1: "eu-north-1";
  readonly EU_WEST_1: "eu-west-1";
  readonly EU_WEST_2: "eu-west-2";
  readonly EU_WEST_3: "eu-west-3";
  readonly US_EAST_1: "us-east-1";
  readonly US_EAST_2: "us-east-2";
  readonly US_WEST_1: "us-west-1";
  readonly US_WEST_2: "us-west-2";
};
export type RegionName = (typeof RegionName)[keyof typeof RegionName];
export interface ResourceLocation {
  availabilityZone?: string;
  regionName?: RegionName;
}
export declare const MetricName: {
  readonly BurstCapacityPercentage: "BurstCapacityPercentage";
  readonly BurstCapacityTime: "BurstCapacityTime";
  readonly CPUUtilization: "CPUUtilization";
  readonly ClientTLSNegotiationErrorCount: "ClientTLSNegotiationErrorCount";
  readonly DatabaseConnections: "DatabaseConnections";
  readonly DiskQueueDepth: "DiskQueueDepth";
  readonly FreeStorageSpace: "FreeStorageSpace";
  readonly HTTPCode_Instance_2XX_Count: "HTTPCode_Instance_2XX_Count";
  readonly HTTPCode_Instance_3XX_Count: "HTTPCode_Instance_3XX_Count";
  readonly HTTPCode_Instance_4XX_Count: "HTTPCode_Instance_4XX_Count";
  readonly HTTPCode_Instance_5XX_Count: "HTTPCode_Instance_5XX_Count";
  readonly HTTPCode_LB_4XX_Count: "HTTPCode_LB_4XX_Count";
  readonly HTTPCode_LB_5XX_Count: "HTTPCode_LB_5XX_Count";
  readonly HealthyHostCount: "HealthyHostCount";
  readonly InstanceResponseTime: "InstanceResponseTime";
  readonly NetworkIn: "NetworkIn";
  readonly NetworkOut: "NetworkOut";
  readonly NetworkReceiveThroughput: "NetworkReceiveThroughput";
  readonly NetworkTransmitThroughput: "NetworkTransmitThroughput";
  readonly RejectedConnectionCount: "RejectedConnectionCount";
  readonly RequestCount: "RequestCount";
  readonly StatusCheckFailed: "StatusCheckFailed";
  readonly StatusCheckFailed_Instance: "StatusCheckFailed_Instance";
  readonly StatusCheckFailed_System: "StatusCheckFailed_System";
  readonly UnhealthyHostCount: "UnhealthyHostCount";
};
export type MetricName = (typeof MetricName)[keyof typeof MetricName];
export declare const ResourceType: {
  readonly Alarm: "Alarm";
  readonly Bucket: "Bucket";
  readonly Certificate: "Certificate";
  readonly CloudFormationStackRecord: "CloudFormationStackRecord";
  readonly ContactMethod: "ContactMethod";
  readonly ContainerService: "ContainerService";
  readonly Disk: "Disk";
  readonly DiskSnapshot: "DiskSnapshot";
  readonly Distribution: "Distribution";
  readonly Domain: "Domain";
  readonly ExportSnapshotRecord: "ExportSnapshotRecord";
  readonly Instance: "Instance";
  readonly InstanceSnapshot: "InstanceSnapshot";
  readonly KeyPair: "KeyPair";
  readonly LoadBalancer: "LoadBalancer";
  readonly LoadBalancerTlsCertificate: "LoadBalancerTlsCertificate";
  readonly PeeredVpc: "PeeredVpc";
  readonly RelationalDatabase: "RelationalDatabase";
  readonly RelationalDatabaseSnapshot: "RelationalDatabaseSnapshot";
  readonly StaticIp: "StaticIp";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface MonitoredResourceInfo {
  arn?: string;
  name?: string;
  resourceType?: ResourceType;
}
export declare const AlarmState: {
  readonly ALARM: "ALARM";
  readonly INSUFFICIENT_DATA: "INSUFFICIENT_DATA";
  readonly OK: "OK";
};
export type AlarmState = (typeof AlarmState)[keyof typeof AlarmState];
export declare const MetricStatistic: {
  readonly Average: "Average";
  readonly Maximum: "Maximum";
  readonly Minimum: "Minimum";
  readonly SampleCount: "SampleCount";
  readonly Sum: "Sum";
};
export type MetricStatistic =
  (typeof MetricStatistic)[keyof typeof MetricStatistic];
export declare const TreatMissingData: {
  readonly Breaching: "breaching";
  readonly Ignore: "ignore";
  readonly Missing: "missing";
  readonly NotBreaching: "notBreaching";
};
export type TreatMissingData =
  (typeof TreatMissingData)[keyof typeof TreatMissingData];
export declare const MetricUnit: {
  readonly Bits: "Bits";
  readonly BitsSecond: "Bits/Second";
  readonly Bytes: "Bytes";
  readonly BytesSecond: "Bytes/Second";
  readonly Count: "Count";
  readonly CountSecond: "Count/Second";
  readonly Gigabits: "Gigabits";
  readonly GigabitsSecond: "Gigabits/Second";
  readonly Gigabytes: "Gigabytes";
  readonly GigabytesSecond: "Gigabytes/Second";
  readonly Kilobits: "Kilobits";
  readonly KilobitsSecond: "Kilobits/Second";
  readonly Kilobytes: "Kilobytes";
  readonly KilobytesSecond: "Kilobytes/Second";
  readonly Megabits: "Megabits";
  readonly MegabitsSecond: "Megabits/Second";
  readonly Megabytes: "Megabytes";
  readonly MegabytesSecond: "Megabytes/Second";
  readonly Microseconds: "Microseconds";
  readonly Milliseconds: "Milliseconds";
  readonly None: "None";
  readonly Percent: "Percent";
  readonly Seconds: "Seconds";
  readonly Terabits: "Terabits";
  readonly TerabitsSecond: "Terabits/Second";
  readonly Terabytes: "Terabytes";
  readonly TerabytesSecond: "Terabytes/Second";
};
export type MetricUnit = (typeof MetricUnit)[keyof typeof MetricUnit];
export interface Alarm {
  name?: string;
  arn?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  supportCode?: string;
  monitoredResourceInfo?: MonitoredResourceInfo;
  comparisonOperator?: ComparisonOperator;
  evaluationPeriods?: number;
  period?: number;
  threshold?: number;
  datapointsToAlarm?: number;
  treatMissingData?: TreatMissingData;
  statistic?: MetricStatistic;
  metricName?: MetricName;
  state?: AlarmState;
  unit?: MetricUnit;
  contactProtocols?: ContactProtocol[];
  notificationTriggers?: AlarmState[];
  notificationEnabled?: boolean;
}
export interface AllocateStaticIpRequest {
  staticIpName: string | undefined;
}
export declare const OperationType: {
  readonly AllocateStaticIp: "AllocateStaticIp";
  readonly AttachCertificateToDistribution: "AttachCertificateToDistribution";
  readonly AttachDisk: "AttachDisk";
  readonly AttachInstancesToLoadBalancer: "AttachInstancesToLoadBalancer";
  readonly AttachLoadBalancerTlsCertificate: "AttachLoadBalancerTlsCertificate";
  readonly AttachStaticIp: "AttachStaticIp";
  readonly CloseInstancePublicPorts: "CloseInstancePublicPorts";
  readonly CreateBucket: "CreateBucket";
  readonly CreateBucketAccessKey: "CreateBucketAccessKey";
  readonly CreateCertificate: "CreateCertificate";
  readonly CreateContactMethod: "CreateContactMethod";
  readonly CreateContainerService: "CreateContainerService";
  readonly CreateContainerServiceDeployment: "CreateContainerServiceDeployment";
  readonly CreateContainerServiceRegistryLogin: "CreateContainerServiceRegistryLogin";
  readonly CreateDisk: "CreateDisk";
  readonly CreateDiskFromSnapshot: "CreateDiskFromSnapshot";
  readonly CreateDiskSnapshot: "CreateDiskSnapshot";
  readonly CreateDistribution: "CreateDistribution";
  readonly CreateDomain: "CreateDomain";
  readonly CreateInstance: "CreateInstance";
  readonly CreateInstanceSnapshot: "CreateInstanceSnapshot";
  readonly CreateInstancesFromSnapshot: "CreateInstancesFromSnapshot";
  readonly CreateLoadBalancer: "CreateLoadBalancer";
  readonly CreateLoadBalancerTlsCertificate: "CreateLoadBalancerTlsCertificate";
  readonly CreateRelationalDatabase: "CreateRelationalDatabase";
  readonly CreateRelationalDatabaseFromSnapshot: "CreateRelationalDatabaseFromSnapshot";
  readonly CreateRelationalDatabaseSnapshot: "CreateRelationalDatabaseSnapshot";
  readonly DeleteAlarm: "DeleteAlarm";
  readonly DeleteBucket: "DeleteBucket";
  readonly DeleteBucketAccessKey: "DeleteBucketAccessKey";
  readonly DeleteCertificate: "DeleteCertificate";
  readonly DeleteContactMethod: "DeleteContactMethod";
  readonly DeleteContainerImage: "DeleteContainerImage";
  readonly DeleteContainerService: "DeleteContainerService";
  readonly DeleteDisk: "DeleteDisk";
  readonly DeleteDiskSnapshot: "DeleteDiskSnapshot";
  readonly DeleteDistribution: "DeleteDistribution";
  readonly DeleteDomain: "DeleteDomain";
  readonly DeleteDomainEntry: "DeleteDomainEntry";
  readonly DeleteInstance: "DeleteInstance";
  readonly DeleteInstanceSnapshot: "DeleteInstanceSnapshot";
  readonly DeleteKnownHostKeys: "DeleteKnownHostKeys";
  readonly DeleteLoadBalancer: "DeleteLoadBalancer";
  readonly DeleteLoadBalancerTlsCertificate: "DeleteLoadBalancerTlsCertificate";
  readonly DeleteRelationalDatabase: "DeleteRelationalDatabase";
  readonly DeleteRelationalDatabaseSnapshot: "DeleteRelationalDatabaseSnapshot";
  readonly DetachCertificateFromDistribution: "DetachCertificateFromDistribution";
  readonly DetachDisk: "DetachDisk";
  readonly DetachInstancesFromLoadBalancer: "DetachInstancesFromLoadBalancer";
  readonly DetachStaticIp: "DetachStaticIp";
  readonly DisableAddOn: "DisableAddOn";
  readonly EnableAddOn: "EnableAddOn";
  readonly GetAlarms: "GetAlarms";
  readonly GetContactMethods: "GetContactMethods";
  readonly OpenInstancePublicPorts: "OpenInstancePublicPorts";
  readonly PutAlarm: "PutAlarm";
  readonly PutInstancePublicPorts: "PutInstancePublicPorts";
  readonly RebootInstance: "RebootInstance";
  readonly RebootRelationalDatabase: "RebootRelationalDatabase";
  readonly RegisterContainerImage: "RegisterContainerImage";
  readonly ReleaseStaticIp: "ReleaseStaticIp";
  readonly ResetDistributionCache: "ResetDistributionCache";
  readonly SendContactMethodVerification: "SendContactMethodVerification";
  readonly SetIpAddressType: "SetIpAddressType";
  readonly SetResourceAccessForBucket: "SetResourceAccessForBucket";
  readonly SetupInstanceHttps: "SetupInstanceHttps";
  readonly StartGUISession: "StartGUISession";
  readonly StartInstance: "StartInstance";
  readonly StartRelationalDatabase: "StartRelationalDatabase";
  readonly StopGUISession: "StopGUISession";
  readonly StopInstance: "StopInstance";
  readonly StopRelationalDatabase: "StopRelationalDatabase";
  readonly TestAlarm: "TestAlarm";
  readonly UpdateBucket: "UpdateBucket";
  readonly UpdateBucketBundle: "UpdateBucketBundle";
  readonly UpdateContainerService: "UpdateContainerService";
  readonly UpdateDistribution: "UpdateDistribution";
  readonly UpdateDistributionBundle: "UpdateDistributionBundle";
  readonly UpdateDomainEntry: "UpdateDomainEntry";
  readonly UpdateInstanceMetadataOptions: "UpdateInstanceMetadataOptions";
  readonly UpdateLoadBalancerAttribute: "UpdateLoadBalancerAttribute";
  readonly UpdateRelationalDatabase: "UpdateRelationalDatabase";
  readonly UpdateRelationalDatabaseParameters: "UpdateRelationalDatabaseParameters";
};
export type OperationType = (typeof OperationType)[keyof typeof OperationType];
export declare const OperationStatus: {
  readonly Completed: "Completed";
  readonly Failed: "Failed";
  readonly NotStarted: "NotStarted";
  readonly Started: "Started";
  readonly Succeeded: "Succeeded";
};
export type OperationStatus =
  (typeof OperationStatus)[keyof typeof OperationStatus];
export interface Operation {
  id?: string;
  resourceName?: string;
  resourceType?: ResourceType;
  createdAt?: Date;
  location?: ResourceLocation;
  isTerminal?: boolean;
  operationDetails?: string;
  operationType?: OperationType;
  status?: OperationStatus;
  statusChangedAt?: Date;
  errorCode?: string;
  errorDetails?: string;
}
export interface AllocateStaticIpResult {
  operations?: Operation[];
}
export declare class InvalidInputException extends __BaseException {
  readonly name: "InvalidInputException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidInputException, __BaseException>
  );
}
export declare class NotFoundException extends __BaseException {
  readonly name: "NotFoundException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
}
export declare class OperationFailureException extends __BaseException {
  readonly name: "OperationFailureException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(
    opts: __ExceptionOptionType<OperationFailureException, __BaseException>
  );
}
export declare class ServiceException extends __BaseException {
  readonly name: "ServiceException";
  readonly $fault: "server";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(opts: __ExceptionOptionType<ServiceException, __BaseException>);
}
export declare class UnauthenticatedException extends __BaseException {
  readonly name: "UnauthenticatedException";
  readonly $fault: "client";
  code?: string;
  docs?: string;
  tip?: string;
  constructor(
    opts: __ExceptionOptionType<UnauthenticatedException, __BaseException>
  );
}
export declare const AppCategory: {
  readonly LfR: "LfR";
};
export type AppCategory = (typeof AppCategory)[keyof typeof AppCategory];
export interface AttachCertificateToDistributionRequest {
  distributionName: string | undefined;
  certificateName: string | undefined;
}
export interface AttachCertificateToDistributionResult {
  operation?: Operation;
}
export interface AttachDiskRequest {
  diskName: string | undefined;
  instanceName: string | undefined;
  diskPath: string | undefined;
  autoMounting?: boolean;
}
export interface AttachDiskResult {
  operations?: Operation[];
}
export interface AttachedDisk {
  path?: string;
  sizeInGb?: number;
}
export interface DiskMap {
  originalDiskPath?: string;
  newDiskName?: string;
}
export interface AttachInstancesToLoadBalancerRequest {
  loadBalancerName: string | undefined;
  instanceNames: string[] | undefined;
}
export interface AttachInstancesToLoadBalancerResult {
  operations?: Operation[];
}
export interface AttachLoadBalancerTlsCertificateRequest {
  loadBalancerName: string | undefined;
  certificateName: string | undefined;
}
export interface AttachLoadBalancerTlsCertificateResult {
  operations?: Operation[];
}
export interface AttachStaticIpRequest {
  staticIpName: string | undefined;
  instanceName: string | undefined;
}
export interface AttachStaticIpResult {
  operations?: Operation[];
}
export declare const AutoMountStatus: {
  readonly Failed: "Failed";
  readonly Mounted: "Mounted";
  readonly NotMounted: "NotMounted";
  readonly Pending: "Pending";
};
export type AutoMountStatus =
  (typeof AutoMountStatus)[keyof typeof AutoMountStatus];
export declare const AutoSnapshotStatus: {
  readonly FAILED: "Failed";
  readonly IN_PROGRESS: "InProgress";
  readonly NOT_FOUND: "NotFound";
  readonly SUCCESS: "Success";
};
export type AutoSnapshotStatus =
  (typeof AutoSnapshotStatus)[keyof typeof AutoSnapshotStatus];
export interface AutoSnapshotDetails {
  date?: string;
  createdAt?: Date;
  status?: AutoSnapshotStatus;
  fromAttachedDisks?: AttachedDisk[];
}
export interface AvailabilityZone {
  zoneName?: string;
  state?: string;
}
export declare const BehaviorEnum: {
  readonly CacheSetting: "cache";
  readonly DontCacheSetting: "dont-cache";
};
export type BehaviorEnum = (typeof BehaviorEnum)[keyof typeof BehaviorEnum];
export declare const InstancePlatform: {
  readonly LinuxUnix: "LINUX_UNIX";
  readonly Windows: "WINDOWS";
};
export type InstancePlatform =
  (typeof InstancePlatform)[keyof typeof InstancePlatform];
export declare const BlueprintType: {
  readonly app: "app";
  readonly os: "os";
};
export type BlueprintType = (typeof BlueprintType)[keyof typeof BlueprintType];
export interface Blueprint {
  blueprintId?: string;
  name?: string;
  group?: string;
  type?: BlueprintType;
  description?: string;
  isActive?: boolean;
  minPower?: number;
  version?: string;
  versionCode?: string;
  productUrl?: string;
  licenseUrl?: string;
  platform?: InstancePlatform;
  appCategory?: AppCategory;
}
export interface BucketAccessLogConfig {
  enabled: boolean | undefined;
  destination?: string;
  prefix?: string;
}
export interface BucketState {
  code?: string;
  message?: string;
}
export interface Tag {
  key?: string;
  value?: string;
}
export interface Bucket {
  resourceType?: string;
  accessRules?: AccessRules;
  arn?: string;
  bundleId?: string;
  createdAt?: Date;
  url?: string;
  location?: ResourceLocation;
  name?: string;
  supportCode?: string;
  tags?: Tag[];
  objectVersioning?: string;
  ableToUpdateBundle?: boolean;
  readonlyAccessAccounts?: string[];
  resourcesReceivingAccess?: ResourceReceivingAccess[];
  state?: BucketState;
  accessLogConfig?: BucketAccessLogConfig;
}
export interface BucketBundle {
  bundleId?: string;
  name?: string;
  price?: number;
  storagePerMonthInGb?: number;
  transferPerMonthInGb?: number;
  isActive?: boolean;
}
export declare const BucketMetricName: {
  readonly BucketSizeBytes: "BucketSizeBytes";
  readonly NumberOfObjects: "NumberOfObjects";
};
export type BucketMetricName =
  (typeof BucketMetricName)[keyof typeof BucketMetricName];
export interface Bundle {
  price?: number;
  cpuCount?: number;
  diskSizeInGb?: number;
  bundleId?: string;
  instanceType?: string;
  isActive?: boolean;
  name?: string;
  power?: number;
  ramSizeInGb?: number;
  transferPerMonthInGb?: number;
  supportedPlatforms?: InstancePlatform[];
  supportedAppCategories?: AppCategory[];
  publicIpv4AddressCount?: number;
}
export interface CacheBehavior {
  behavior?: BehaviorEnum;
}
export interface CacheBehaviorPerPath {
  path?: string;
  behavior?: BehaviorEnum;
}
export declare const ForwardValues: {
  readonly all: "all";
  readonly allowList: "allow-list";
  readonly none: "none";
};
export type ForwardValues = (typeof ForwardValues)[keyof typeof ForwardValues];
export interface CookieObject {
  option?: ForwardValues;
  cookiesAllowList?: string[];
}
export declare const HeaderEnum: {
  readonly accept: "Accept";
  readonly acceptCharset: "Accept-Charset";
  readonly acceptDatetime: "Accept-Datetime";
  readonly acceptEncoding: "Accept-Encoding";
  readonly acceptLanguage: "Accept-Language";
  readonly authorization: "Authorization";
  readonly cloudFrontForwardedProto: "CloudFront-Forwarded-Proto";
  readonly cloudFrontIsDesktopViewer: "CloudFront-Is-Desktop-Viewer";
  readonly cloudFrontIsMobileViewer: "CloudFront-Is-Mobile-Viewer";
  readonly cloudFrontIsSmartTVViewer: "CloudFront-Is-SmartTV-Viewer";
  readonly cloudFrontIsTabletViewer: "CloudFront-Is-Tablet-Viewer";
  readonly cloudFrontViewerCountry: "CloudFront-Viewer-Country";
  readonly host: "Host";
  readonly origin: "Origin";
  readonly referer: "Referer";
};
export type HeaderEnum = (typeof HeaderEnum)[keyof typeof HeaderEnum];
export interface HeaderObject {
  option?: ForwardValues;
  headersAllowList?: HeaderEnum[];
}
export interface QueryStringObject {
  option?: boolean;
  queryStringsAllowList?: string[];
}
export interface CacheSettings {
  defaultTTL?: number;
  minimumTTL?: number;
  maximumTTL?: number;
  allowedHTTPMethods?: string;
  cachedHTTPMethods?: string;
  forwardedCookies?: CookieObject;
  forwardedHeaders?: HeaderObject;
  forwardedQueryStrings?: QueryStringObject;
}
export declare const DnsRecordCreationStateCode: {
  readonly Failed: "FAILED";
  readonly Started: "STARTED";
  readonly Succeeded: "SUCCEEDED";
};
export type DnsRecordCreationStateCode =
  (typeof DnsRecordCreationStateCode)[keyof typeof DnsRecordCreationStateCode];
export interface DnsRecordCreationState {
  code?: DnsRecordCreationStateCode;
  message?: string;
}
export interface ResourceRecord {
  name?: string;
  type?: string;
  value?: string;
}
export declare const CertificateDomainValidationStatus: {
  readonly Failed: "FAILED";
  readonly PendingValidation: "PENDING_VALIDATION";
  readonly Success: "SUCCESS";
};
export type CertificateDomainValidationStatus =
  (typeof CertificateDomainValidationStatus)[keyof typeof CertificateDomainValidationStatus];
export interface DomainValidationRecord {
  domainName?: string;
  resourceRecord?: ResourceRecord;
  dnsRecordCreationState?: DnsRecordCreationState;
  validationStatus?: CertificateDomainValidationStatus;
}
export declare const RenewalStatus: {
  readonly Failed: "Failed";
  readonly PendingAutoRenewal: "PendingAutoRenewal";
  readonly PendingValidation: "PendingValidation";
  readonly Success: "Success";
};
export type RenewalStatus = (typeof RenewalStatus)[keyof typeof RenewalStatus];
export interface RenewalSummary {
  domainValidationRecords?: DomainValidationRecord[];
  renewalStatus?: RenewalStatus;
  renewalStatusReason?: string;
  updatedAt?: Date;
}
export declare const CertificateStatus: {
  readonly Expired: "EXPIRED";
  readonly Failed: "FAILED";
  readonly Inactive: "INACTIVE";
  readonly Issued: "ISSUED";
  readonly PendingValidation: "PENDING_VALIDATION";
  readonly Revoked: "REVOKED";
  readonly ValidationTimedOut: "VALIDATION_TIMED_OUT";
};
export type CertificateStatus =
  (typeof CertificateStatus)[keyof typeof CertificateStatus];
export interface Certificate {
  arn?: string;
  name?: string;
  domainName?: string;
  status?: CertificateStatus;
  serialNumber?: string;
  subjectAlternativeNames?: string[];
  domainValidationRecords?: DomainValidationRecord[];
  requestFailureReason?: string;
  inUseResourceCount?: number;
  keyAlgorithm?: string;
  createdAt?: Date;
  issuedAt?: Date;
  issuerCA?: string;
  notBefore?: Date;
  notAfter?: Date;
  eligibleToRenew?: string;
  renewalSummary?: RenewalSummary;
  revokedAt?: Date;
  revocationReason?: string;
  tags?: Tag[];
  supportCode?: string;
}
export declare const CertificateProvider: {
  readonly LetsEncrypt: "LetsEncrypt";
};
export type CertificateProvider =
  (typeof CertificateProvider)[keyof typeof CertificateProvider];
export interface CertificateSummary {
  certificateArn?: string;
  certificateName?: string;
  domainName?: string;
  certificateDetail?: Certificate;
  tags?: Tag[];
}
export declare const NetworkProtocol: {
  readonly ALL: "all";
  readonly ICMP: "icmp";
  readonly TCP: "tcp";
  readonly UDP: "udp";
};
export type NetworkProtocol =
  (typeof NetworkProtocol)[keyof typeof NetworkProtocol];
export interface PortInfo {
  fromPort?: number;
  toPort?: number;
  protocol?: NetworkProtocol;
  cidrs?: string[];
  ipv6Cidrs?: string[];
  cidrListAliases?: string[];
}
export interface CloseInstancePublicPortsRequest {
  portInfo: PortInfo | undefined;
  instanceName: string | undefined;
}
export interface CloseInstancePublicPortsResult {
  operation?: Operation;
}
export interface DestinationInfo {
  id?: string;
  service?: string;
}
export declare const CloudFormationStackRecordSourceType: {
  readonly ExportSnapshotRecord: "ExportSnapshotRecord";
};
export type CloudFormationStackRecordSourceType =
  (typeof CloudFormationStackRecordSourceType)[keyof typeof CloudFormationStackRecordSourceType];
export interface CloudFormationStackRecordSourceInfo {
  resourceType?: CloudFormationStackRecordSourceType;
  name?: string;
  arn?: string;
}
export declare const RecordState: {
  readonly Failed: "Failed";
  readonly Started: "Started";
  readonly Succeeded: "Succeeded";
};
export type RecordState = (typeof RecordState)[keyof typeof RecordState];
export interface CloudFormationStackRecord {
  name?: string;
  arn?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  state?: RecordState;
  sourceInfo?: CloudFormationStackRecordSourceInfo[];
  destinationInfo?: DestinationInfo;
}
export declare const ContactMethodStatus: {
  readonly Invalid: "Invalid";
  readonly PendingVerification: "PendingVerification";
  readonly Valid: "Valid";
};
export type ContactMethodStatus =
  (typeof ContactMethodStatus)[keyof typeof ContactMethodStatus];
export interface ContactMethod {
  contactEndpoint?: string;
  status?: ContactMethodStatus;
  protocol?: ContactProtocol;
  name?: string;
  arn?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  supportCode?: string;
}
export declare const ContactMethodVerificationProtocol: {
  readonly Email: "Email";
};
export type ContactMethodVerificationProtocol =
  (typeof ContactMethodVerificationProtocol)[keyof typeof ContactMethodVerificationProtocol];
export declare const ContainerServiceProtocol: {
  readonly HTTP: "HTTP";
  readonly HTTPS: "HTTPS";
  readonly TCP: "TCP";
  readonly UDP: "UDP";
};
export type ContainerServiceProtocol =
  (typeof ContainerServiceProtocol)[keyof typeof ContainerServiceProtocol];
export interface Container {
  image?: string;
  command?: string[];
  environment?: Record<string, string>;
  ports?: Record<string, ContainerServiceProtocol>;
}
export interface ContainerImage {
  image?: string;
  digest?: string;
  createdAt?: Date;
}
export interface ContainerServiceHealthCheckConfig {
  healthyThreshold?: number;
  unhealthyThreshold?: number;
  timeoutSeconds?: number;
  intervalSeconds?: number;
  path?: string;
  successCodes?: string;
}
export interface ContainerServiceEndpoint {
  containerName?: string;
  containerPort?: number;
  healthCheck?: ContainerServiceHealthCheckConfig;
}
export declare const ContainerServiceDeploymentState: {
  readonly ACTIVATING: "ACTIVATING";
  readonly ACTIVE: "ACTIVE";
  readonly FAILED: "FAILED";
  readonly INACTIVE: "INACTIVE";
};
export type ContainerServiceDeploymentState =
  (typeof ContainerServiceDeploymentState)[keyof typeof ContainerServiceDeploymentState];
export interface ContainerServiceDeployment {
  version?: number;
  state?: ContainerServiceDeploymentState;
  containers?: Record<string, Container>;
  publicEndpoint?: ContainerServiceEndpoint;
  createdAt?: Date;
}
export declare const ContainerServicePowerName: {
  readonly large: "large";
  readonly medium: "medium";
  readonly micro: "micro";
  readonly nano: "nano";
  readonly small: "small";
  readonly xlarge: "xlarge";
};
export type ContainerServicePowerName =
  (typeof ContainerServicePowerName)[keyof typeof ContainerServicePowerName];
export interface ContainerServiceECRImagePullerRole {
  isActive?: boolean;
  principalArn?: string;
}
export interface PrivateRegistryAccess {
  ecrImagePullerRole?: ContainerServiceECRImagePullerRole;
}
export declare const ContainerServiceState: {
  readonly DELETING: "DELETING";
  readonly DEPLOYING: "DEPLOYING";
  readonly DISABLED: "DISABLED";
  readonly PENDING: "PENDING";
  readonly READY: "READY";
  readonly RUNNING: "RUNNING";
  readonly UPDATING: "UPDATING";
};
export type ContainerServiceState =
  (typeof ContainerServiceState)[keyof typeof ContainerServiceState];
export declare const ContainerServiceStateDetailCode: {
  readonly ACTIVATING_DEPLOYMENT: "ACTIVATING_DEPLOYMENT";
  readonly CERTIFICATE_LIMIT_EXCEEDED: "CERTIFICATE_LIMIT_EXCEEDED";
  readonly CREATING_DEPLOYMENT: "CREATING_DEPLOYMENT";
  readonly CREATING_NETWORK_INFRASTRUCTURE: "CREATING_NETWORK_INFRASTRUCTURE";
  readonly CREATING_SYSTEM_RESOURCES: "CREATING_SYSTEM_RESOURCES";
  readonly EVALUATING_HEALTH_CHECK: "EVALUATING_HEALTH_CHECK";
  readonly PROVISIONING_CERTIFICATE: "PROVISIONING_CERTIFICATE";
  readonly PROVISIONING_SERVICE: "PROVISIONING_SERVICE";
  readonly UNKNOWN_ERROR: "UNKNOWN_ERROR";
};
export type ContainerServiceStateDetailCode =
  (typeof ContainerServiceStateDetailCode)[keyof typeof ContainerServiceStateDetailCode];
export interface ContainerServiceStateDetail {
  code?: ContainerServiceStateDetailCode;
  message?: string;
}
export interface ContainerService {
  containerServiceName?: string;
  arn?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  tags?: Tag[];
  power?: ContainerServicePowerName;
  powerId?: string;
  state?: ContainerServiceState;
  stateDetail?: ContainerServiceStateDetail;
  scale?: number;
  currentDeployment?: ContainerServiceDeployment;
  nextDeployment?: ContainerServiceDeployment;
  isDisabled?: boolean;
  principalArn?: string;
  privateDomainName?: string;
  publicDomainNames?: Record<string, string[]>;
  url?: string;
  privateRegistryAccess?: PrivateRegistryAccess;
}
export interface EndpointRequest {
  containerName: string | undefined;
  containerPort: number | undefined;
  healthCheck?: ContainerServiceHealthCheckConfig;
}
export interface ContainerServiceDeploymentRequest {
  containers?: Record<string, Container>;
  publicEndpoint?: EndpointRequest;
}
export interface ContainerServiceECRImagePullerRoleRequest {
  isActive?: boolean;
}
export interface ContainerServiceLogEvent {
  createdAt?: Date;
  message?: string;
}
export declare const ContainerServiceMetricName: {
  readonly CPUUtilization: "CPUUtilization";
  readonly MemoryUtilization: "MemoryUtilization";
};
export type ContainerServiceMetricName =
  (typeof ContainerServiceMetricName)[keyof typeof ContainerServiceMetricName];
export interface ContainerServicePower {
  powerId?: string;
  price?: number;
  cpuCount?: number;
  ramSizeInGb?: number;
  name?: string;
  isActive?: boolean;
}
export interface ContainerServiceRegistryLogin {
  username?: string;
  password?: string;
  expiresAt?: Date;
  registry?: string;
}
export interface ContainerServicesListResult {
  containerServices?: ContainerService[];
}
export interface CopySnapshotRequest {
  sourceSnapshotName?: string;
  sourceResourceName?: string;
  restoreDate?: string;
  useLatestRestorableAutoSnapshot?: boolean;
  targetSnapshotName: string | undefined;
  sourceRegion: RegionName | undefined;
}
export interface CopySnapshotResult {
  operations?: Operation[];
}
export declare const Currency: {
  readonly USD: "USD";
};
export type Currency = (typeof Currency)[keyof typeof Currency];
export declare const PricingUnit: {
  readonly Bundles: "Bundles";
  readonly GB: "GB";
  readonly GBMo: "GB-Mo";
  readonly Hrs: "Hrs";
  readonly Queries: "Queries";
};
export type PricingUnit = (typeof PricingUnit)[keyof typeof PricingUnit];
export interface TimePeriod {
  start?: Date;
  end?: Date;
}
export interface EstimateByTime {
  usageCost?: number;
  pricingUnit?: PricingUnit;
  unit?: number;
  currency?: Currency;
  timePeriod?: TimePeriod;
}
export interface CostEstimate {
  usageType?: string;
  resultsByTime?: EstimateByTime[];
}
export interface CreateBucketRequest {
  bucketName: string | undefined;
  bundleId: string | undefined;
  tags?: Tag[];
  enableObjectVersioning?: boolean;
}
export interface CreateBucketResult {
  bucket?: Bucket;
  operations?: Operation[];
}
export interface CreateBucketAccessKeyRequest {
  bucketName: string | undefined;
}
export interface CreateBucketAccessKeyResult {
  accessKey?: AccessKey;
  operations?: Operation[];
}
export interface CreateCertificateRequest {
  certificateName: string | undefined;
  domainName: string | undefined;
  subjectAlternativeNames?: string[];
  tags?: Tag[];
}
export interface CreateCertificateResult {
  certificate?: CertificateSummary;
  operations?: Operation[];
}
export declare const PortInfoSourceType: {
  readonly Closed: "CLOSED";
  readonly Default: "DEFAULT";
  readonly Instance: "INSTANCE";
  readonly None: "NONE";
};
export type PortInfoSourceType =
  (typeof PortInfoSourceType)[keyof typeof PortInfoSourceType];
export interface InstanceEntry {
  sourceName: string | undefined;
  instanceType: string | undefined;
  portInfoSource: PortInfoSourceType | undefined;
  userData?: string;
  availabilityZone: string | undefined;
}
export interface CreateCloudFormationStackRequest {
  instances: InstanceEntry[] | undefined;
}
export interface CreateCloudFormationStackResult {
  operations?: Operation[];
}
export interface CreateContactMethodRequest {
  protocol: ContactProtocol | undefined;
  contactEndpoint: string | undefined;
}
export interface CreateContactMethodResult {
  operations?: Operation[];
}
export interface PrivateRegistryAccessRequest {
  ecrImagePullerRole?: ContainerServiceECRImagePullerRoleRequest;
}
export interface CreateContainerServiceRequest {
  serviceName: string | undefined;
  power: ContainerServicePowerName | undefined;
  scale: number | undefined;
  tags?: Tag[];
  publicDomainNames?: Record<string, string[]>;
  deployment?: ContainerServiceDeploymentRequest;
  privateRegistryAccess?: PrivateRegistryAccessRequest;
}
export interface CreateContainerServiceResult {
  containerService?: ContainerService;
}
export interface CreateContainerServiceDeploymentRequest {
  serviceName: string | undefined;
  containers?: Record<string, Container>;
  publicEndpoint?: EndpointRequest;
}
export interface CreateContainerServiceDeploymentResult {
  containerService?: ContainerService;
}
export interface CreateContainerServiceRegistryLoginRequest {}
export interface CreateContainerServiceRegistryLoginResult {
  registryLogin?: ContainerServiceRegistryLogin;
}
export interface CreateDiskRequest {
  diskName: string | undefined;
  availabilityZone: string | undefined;
  sizeInGb: number | undefined;
  tags?: Tag[];
  addOns?: AddOnRequest[];
}
export interface CreateDiskResult {
  operations?: Operation[];
}
export interface CreateDiskFromSnapshotRequest {
  diskName: string | undefined;
  diskSnapshotName?: string;
  availabilityZone: string | undefined;
  sizeInGb: number | undefined;
  tags?: Tag[];
  addOns?: AddOnRequest[];
  sourceDiskName?: string;
  restoreDate?: string;
  useLatestRestorableAutoSnapshot?: boolean;
}
export interface CreateDiskFromSnapshotResult {
  operations?: Operation[];
}
export interface CreateDiskSnapshotRequest {
  diskName?: string;
  diskSnapshotName: string | undefined;
  instanceName?: string;
  tags?: Tag[];
}
export interface CreateDiskSnapshotResult {
  operations?: Operation[];
}
export declare const IpAddressType: {
  readonly DUALSTACK: "dualstack";
  readonly IPV4: "ipv4";
};
export type IpAddressType = (typeof IpAddressType)[keyof typeof IpAddressType];
export declare const OriginProtocolPolicyEnum: {
  readonly HTTPOnly: "http-only";
  readonly HTTPSOnly: "https-only";
};
export type OriginProtocolPolicyEnum =
  (typeof OriginProtocolPolicyEnum)[keyof typeof OriginProtocolPolicyEnum];
export interface InputOrigin {
  name?: string;
  regionName?: RegionName;
  protocolPolicy?: OriginProtocolPolicyEnum;
  responseTimeout?: number;
}
export declare const ViewerMinimumTlsProtocolVersionEnum: {
  readonly TLSv11_2016: "TLSv1.1_2016";
  readonly TLSv12_2018: "TLSv1.2_2018";
  readonly TLSv12_2019: "TLSv1.2_2019";
  readonly TLSv12_2021: "TLSv1.2_2021";
};
export type ViewerMinimumTlsProtocolVersionEnum =
  (typeof ViewerMinimumTlsProtocolVersionEnum)[keyof typeof ViewerMinimumTlsProtocolVersionEnum];
export interface CreateDistributionRequest {
  distributionName: string | undefined;
  origin: InputOrigin | undefined;
  defaultCacheBehavior: CacheBehavior | undefined;
  cacheBehaviorSettings?: CacheSettings;
  cacheBehaviors?: CacheBehaviorPerPath[];
  bundleId: string | undefined;
  ipAddressType?: IpAddressType;
  tags?: Tag[];
  certificateName?: string;
  viewerMinimumTlsProtocolVersion?: ViewerMinimumTlsProtocolVersionEnum;
}
export interface Origin {
  name?: string;
  resourceType?: ResourceType;
  regionName?: RegionName;
  protocolPolicy?: OriginProtocolPolicyEnum;
  responseTimeout?: number;
}
export interface LightsailDistribution {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  alternativeDomainNames?: string[];
  status?: string;
  isEnabled?: boolean;
  domainName?: string;
  bundleId?: string;
  certificateName?: string;
  origin?: Origin;
  originPublicDNS?: string;
  defaultCacheBehavior?: CacheBehavior;
  cacheBehaviorSettings?: CacheSettings;
  cacheBehaviors?: CacheBehaviorPerPath[];
  ableToUpdateBundle?: boolean;
  ipAddressType?: IpAddressType;
  tags?: Tag[];
  viewerMinimumTlsProtocolVersion?: string;
}
export interface CreateDistributionResult {
  distribution?: LightsailDistribution;
  operation?: Operation;
}
export interface CreateDomainRequest {
  domainName: string | undefined;
  tags?: Tag[];
}
export interface CreateDomainResult {
  operation?: Operation;
}
export interface DomainEntry {
  id?: string;
  name?: string;
  target?: string;
  isAlias?: boolean;
  type?: string;
  options?: Record<string, string>;
}
export interface CreateDomainEntryRequest {
  domainName: string | undefined;
  domainEntry: DomainEntry | undefined;
}
export interface CreateDomainEntryResult {
  operation?: Operation;
}
export interface CreateGUISessionAccessDetailsRequest {
  resourceName: string | undefined;
}
export interface Session {
  name?: string;
  url?: string;
  isPrimary?: boolean;
}
export declare const Status: {
  readonly FailedInstanceCreation: "failedInstanceCreation";
  readonly FailedStartingGUISession: "failedStartingGUISession";
  readonly FailedStoppingGUISession: "failedStoppingGUISession";
  readonly NotStarted: "notStarted";
  readonly SettingUpInstance: "settingUpInstance";
  readonly StartExpired: "startExpired";
  readonly Started: "started";
  readonly Starting: "starting";
  readonly Stopped: "stopped";
  readonly Stopping: "stopping";
};
export type Status = (typeof Status)[keyof typeof Status];
export interface CreateGUISessionAccessDetailsResult {
  resourceName?: string;
  status?: Status;
  percentageComplete?: number;
  failureReason?: string;
  sessions?: Session[];
}
export interface CreateInstancesRequest {
  instanceNames: string[] | undefined;
  availabilityZone: string | undefined;
  customImageName?: string;
  blueprintId: string | undefined;
  bundleId: string | undefined;
  userData?: string;
  keyPairName?: string;
  tags?: Tag[];
  addOns?: AddOnRequest[];
  ipAddressType?: IpAddressType;
}
export interface CreateInstancesResult {
  operations?: Operation[];
}
export interface CreateInstancesFromSnapshotRequest {
  instanceNames: string[] | undefined;
  attachedDiskMapping?: Record<string, DiskMap[]>;
  availabilityZone: string | undefined;
  instanceSnapshotName?: string;
  bundleId: string | undefined;
  userData?: string;
  keyPairName?: string;
  tags?: Tag[];
  addOns?: AddOnRequest[];
  ipAddressType?: IpAddressType;
  sourceInstanceName?: string;
  restoreDate?: string;
  useLatestRestorableAutoSnapshot?: boolean;
}
export interface CreateInstancesFromSnapshotResult {
  operations?: Operation[];
}
export interface CreateInstanceSnapshotRequest {
  instanceSnapshotName: string | undefined;
  instanceName: string | undefined;
  tags?: Tag[];
}
export interface CreateInstanceSnapshotResult {
  operations?: Operation[];
}
export interface CreateKeyPairRequest {
  keyPairName: string | undefined;
  tags?: Tag[];
}
export interface KeyPair {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  tags?: Tag[];
  fingerprint?: string;
}
export interface CreateKeyPairResult {
  keyPair?: KeyPair;
  publicKeyBase64?: string;
  privateKeyBase64?: string;
  operation?: Operation;
}
export interface CreateLoadBalancerRequest {
  loadBalancerName: string | undefined;
  instancePort: number | undefined;
  healthCheckPath?: string;
  certificateName?: string;
  certificateDomainName?: string;
  certificateAlternativeNames?: string[];
  tags?: Tag[];
  ipAddressType?: IpAddressType;
  tlsPolicyName?: string;
}
export interface CreateLoadBalancerResult {
  operations?: Operation[];
}
export interface CreateLoadBalancerTlsCertificateRequest {
  loadBalancerName: string | undefined;
  certificateName: string | undefined;
  certificateDomainName: string | undefined;
  certificateAlternativeNames?: string[];
  tags?: Tag[];
}
export interface CreateLoadBalancerTlsCertificateResult {
  operations?: Operation[];
}
export interface CreateRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
  availabilityZone?: string;
  relationalDatabaseBlueprintId: string | undefined;
  relationalDatabaseBundleId: string | undefined;
  masterDatabaseName: string | undefined;
  masterUsername: string | undefined;
  masterUserPassword?: string;
  preferredBackupWindow?: string;
  preferredMaintenanceWindow?: string;
  publiclyAccessible?: boolean;
  tags?: Tag[];
}
export interface CreateRelationalDatabaseResult {
  operations?: Operation[];
}
export interface CreateRelationalDatabaseFromSnapshotRequest {
  relationalDatabaseName: string | undefined;
  availabilityZone?: string;
  publiclyAccessible?: boolean;
  relationalDatabaseSnapshotName?: string;
  relationalDatabaseBundleId?: string;
  sourceRelationalDatabaseName?: string;
  restoreTime?: Date;
  useLatestRestorableTime?: boolean;
  tags?: Tag[];
}
export interface CreateRelationalDatabaseFromSnapshotResult {
  operations?: Operation[];
}
export interface CreateRelationalDatabaseSnapshotRequest {
  relationalDatabaseName: string | undefined;
  relationalDatabaseSnapshotName: string | undefined;
  tags?: Tag[];
}
export interface CreateRelationalDatabaseSnapshotResult {
  operations?: Operation[];
}
export interface DeleteAlarmRequest {
  alarmName: string | undefined;
}
export interface DeleteAlarmResult {
  operations?: Operation[];
}
export interface DeleteAutoSnapshotRequest {
  resourceName: string | undefined;
  date: string | undefined;
}
export interface DeleteAutoSnapshotResult {
  operations?: Operation[];
}
export interface DeleteBucketRequest {
  bucketName: string | undefined;
  forceDelete?: boolean;
}
export interface DeleteBucketResult {
  operations?: Operation[];
}
export interface DeleteBucketAccessKeyRequest {
  bucketName: string | undefined;
  accessKeyId: string | undefined;
}
export interface DeleteBucketAccessKeyResult {
  operations?: Operation[];
}
export interface DeleteCertificateRequest {
  certificateName: string | undefined;
}
export interface DeleteCertificateResult {
  operations?: Operation[];
}
export interface DeleteContactMethodRequest {
  protocol: ContactProtocol | undefined;
}
export interface DeleteContactMethodResult {
  operations?: Operation[];
}
export interface DeleteContainerImageRequest {
  serviceName: string | undefined;
  image: string | undefined;
}
export interface DeleteContainerImageResult {}
export interface DeleteContainerServiceRequest {
  serviceName: string | undefined;
}
export interface DeleteContainerServiceResult {}
export interface DeleteDiskRequest {
  diskName: string | undefined;
  forceDeleteAddOns?: boolean;
}
export interface DeleteDiskResult {
  operations?: Operation[];
}
export interface DeleteDiskSnapshotRequest {
  diskSnapshotName: string | undefined;
}
export interface DeleteDiskSnapshotResult {
  operations?: Operation[];
}
export interface DeleteDistributionRequest {
  distributionName?: string;
}
export interface DeleteDistributionResult {
  operation?: Operation;
}
export interface DeleteDomainRequest {
  domainName: string | undefined;
}
export interface DeleteDomainResult {
  operation?: Operation;
}
export interface DeleteDomainEntryRequest {
  domainName: string | undefined;
  domainEntry: DomainEntry | undefined;
}
export interface DeleteDomainEntryResult {
  operation?: Operation;
}
export interface DeleteInstanceRequest {
  instanceName: string | undefined;
  forceDeleteAddOns?: boolean;
}
export interface DeleteInstanceResult {
  operations?: Operation[];
}
export interface DeleteInstanceSnapshotRequest {
  instanceSnapshotName: string | undefined;
}
export interface DeleteInstanceSnapshotResult {
  operations?: Operation[];
}
export interface DeleteKeyPairRequest {
  keyPairName: string | undefined;
  expectedFingerprint?: string;
}
export interface DeleteKeyPairResult {
  operation?: Operation;
}
export interface DeleteKnownHostKeysRequest {
  instanceName: string | undefined;
}
export interface DeleteKnownHostKeysResult {
  operations?: Operation[];
}
export interface DeleteLoadBalancerRequest {
  loadBalancerName: string | undefined;
}
export interface DeleteLoadBalancerResult {
  operations?: Operation[];
}
export interface DeleteLoadBalancerTlsCertificateRequest {
  loadBalancerName: string | undefined;
  certificateName: string | undefined;
  force?: boolean;
}
export interface DeleteLoadBalancerTlsCertificateResult {
  operations?: Operation[];
}
export interface DeleteRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
  skipFinalSnapshot?: boolean;
  finalRelationalDatabaseSnapshotName?: string;
}
export interface DeleteRelationalDatabaseResult {
  operations?: Operation[];
}
export interface DeleteRelationalDatabaseSnapshotRequest {
  relationalDatabaseSnapshotName: string | undefined;
}
export interface DeleteRelationalDatabaseSnapshotResult {
  operations?: Operation[];
}
export interface DetachCertificateFromDistributionRequest {
  distributionName: string | undefined;
}
export interface DetachCertificateFromDistributionResult {
  operation?: Operation;
}
export interface DetachDiskRequest {
  diskName: string | undefined;
}
export interface DetachDiskResult {
  operations?: Operation[];
}
export interface DetachInstancesFromLoadBalancerRequest {
  loadBalancerName: string | undefined;
  instanceNames: string[] | undefined;
}
export interface DetachInstancesFromLoadBalancerResult {
  operations?: Operation[];
}
export interface DetachStaticIpRequest {
  staticIpName: string | undefined;
}
export interface DetachStaticIpResult {
  operations?: Operation[];
}
export interface DisableAddOnRequest {
  addOnType: AddOnType | undefined;
  resourceName: string | undefined;
}
export interface DisableAddOnResult {
  operations?: Operation[];
}
export declare const DiskState: {
  readonly Available: "available";
  readonly Error: "error";
  readonly InUse: "in-use";
  readonly Pending: "pending";
  readonly Unknown: "unknown";
};
export type DiskState = (typeof DiskState)[keyof typeof DiskState];
export interface Disk {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  tags?: Tag[];
  addOns?: AddOn[];
  sizeInGb?: number;
  isSystemDisk?: boolean;
  iops?: number;
  path?: string;
  state?: DiskState;
  attachedTo?: string;
  isAttached?: boolean;
  attachmentState?: string;
  gbInUse?: number;
  autoMountStatus?: AutoMountStatus;
}
export interface DiskInfo {
  name?: string;
  path?: string;
  sizeInGb?: number;
  isSystemDisk?: boolean;
}
export declare const DiskSnapshotState: {
  readonly Completed: "completed";
  readonly Error: "error";
  readonly Pending: "pending";
  readonly Unknown: "unknown";
};
export type DiskSnapshotState =
  (typeof DiskSnapshotState)[keyof typeof DiskSnapshotState];
export interface DiskSnapshot {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  tags?: Tag[];
  sizeInGb?: number;
  state?: DiskSnapshotState;
  progress?: string;
  fromDiskName?: string;
  fromDiskArn?: string;
  fromInstanceName?: string;
  fromInstanceArn?: string;
  isFromAutoSnapshot?: boolean;
}
export interface DiskSnapshotInfo {
  sizeInGb?: number;
}
export interface DistributionBundle {
  bundleId?: string;
  name?: string;
  price?: number;
  transferPerMonthInGb?: number;
  isActive?: boolean;
}
export declare const DistributionMetricName: {
  readonly BytesDownloaded: "BytesDownloaded";
  readonly BytesUploaded: "BytesUploaded";
  readonly Http4xxErrorRate: "Http4xxErrorRate";
  readonly Http5xxErrorRate: "Http5xxErrorRate";
  readonly Requests: "Requests";
  readonly TotalErrorRate: "TotalErrorRate";
};
export type DistributionMetricName =
  (typeof DistributionMetricName)[keyof typeof DistributionMetricName];
export declare const NameServersUpdateStateCode: {
  readonly Failed: "FAILED";
  readonly Pending: "PENDING";
  readonly Started: "STARTED";
  readonly Succeeded: "SUCCEEDED";
};
export type NameServersUpdateStateCode =
  (typeof NameServersUpdateStateCode)[keyof typeof NameServersUpdateStateCode];
export interface NameServersUpdateState {
  code?: NameServersUpdateStateCode;
  message?: string;
}
export declare const R53HostedZoneDeletionStateCode: {
  readonly Failed: "FAILED";
  readonly Pending: "PENDING";
  readonly Started: "STARTED";
  readonly Succeeded: "SUCCEEDED";
};
export type R53HostedZoneDeletionStateCode =
  (typeof R53HostedZoneDeletionStateCode)[keyof typeof R53HostedZoneDeletionStateCode];
export interface R53HostedZoneDeletionState {
  code?: R53HostedZoneDeletionStateCode;
  message?: string;
}
export interface RegisteredDomainDelegationInfo {
  nameServersUpdateState?: NameServersUpdateState;
  r53HostedZoneDeletionState?: R53HostedZoneDeletionState;
}
export interface Domain {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  tags?: Tag[];
  domainEntries?: DomainEntry[];
  registeredDomainDelegationInfo?: RegisteredDomainDelegationInfo;
}
export interface DownloadDefaultKeyPairRequest {}
export interface DownloadDefaultKeyPairResult {
  publicKeyBase64?: string;
  privateKeyBase64?: string;
  createdAt?: Date;
}
export interface EnableAddOnRequest {
  resourceName: string | undefined;
  addOnRequest: AddOnRequest | undefined;
}
export interface EnableAddOnResult {
  operations?: Operation[];
}
export interface ExportSnapshotRequest {
  sourceSnapshotName: string | undefined;
}
export interface ExportSnapshotResult {
  operations?: Operation[];
}
export interface InstanceSnapshotInfo {
  fromBundleId?: string;
  fromBlueprintId?: string;
  fromDiskInfo?: DiskInfo[];
}
export declare const ExportSnapshotRecordSourceType: {
  readonly DiskSnapshot: "DiskSnapshot";
  readonly InstanceSnapshot: "InstanceSnapshot";
};
export type ExportSnapshotRecordSourceType =
  (typeof ExportSnapshotRecordSourceType)[keyof typeof ExportSnapshotRecordSourceType];
export interface ExportSnapshotRecordSourceInfo {
  resourceType?: ExportSnapshotRecordSourceType;
  createdAt?: Date;
  name?: string;
  arn?: string;
  fromResourceName?: string;
  fromResourceArn?: string;
  instanceSnapshotInfo?: InstanceSnapshotInfo;
  diskSnapshotInfo?: DiskSnapshotInfo;
}
export interface ExportSnapshotRecord {
  name?: string;
  arn?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType;
  state?: RecordState;
  sourceInfo?: ExportSnapshotRecordSourceInfo;
  destinationInfo?: DestinationInfo;
}
export interface GetActiveNamesRequest {
  pageToken?: string;
}
export interface GetActiveNamesResult {
  activeNames?: string[];
  nextPageToken?: string;
}
export interface GetAlarmsRequest {
  alarmName?: string;
  pageToken?: string;
  monitoredResourceName?: string;
}
export interface GetAlarmsResult {
  alarms?: Alarm[];
  nextPageToken?: string;
}
export interface GetAutoSnapshotsRequest {
  resourceName: string | undefined;
}
export interface GetAutoSnapshotsResult {
  resourceName?: string;
  resourceType?: ResourceType;
  autoSnapshots?: AutoSnapshotDetails[];
}
export interface GetBlueprintsRequest {
  includeInactive?: boolean;
  pageToken?: string;
  appCategory?: AppCategory;
}
export interface GetBlueprintsResult {
  blueprints?: Blueprint[];
  nextPageToken?: string;
}
export interface GetBucketAccessKeysRequest {
  bucketName: string | undefined;
}
export interface GetBucketAccessKeysResult {
  accessKeys?: AccessKey[];
}
export interface GetBucketBundlesRequest {
  includeInactive?: boolean;
}
export interface GetBucketBundlesResult {
  bundles?: BucketBundle[];
}
export interface GetBucketMetricDataRequest {
  bucketName: string | undefined;
  metricName: BucketMetricName | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  period: number | undefined;
  statistics: MetricStatistic[] | undefined;
  unit: MetricUnit | undefined;
}
export interface MetricDatapoint {
  average?: number;
  maximum?: number;
  minimum?: number;
  sampleCount?: number;
  sum?: number;
  timestamp?: Date;
  unit?: MetricUnit;
}
export interface GetBucketMetricDataResult {
  metricName?: BucketMetricName;
  metricData?: MetricDatapoint[];
}
export interface GetBucketsRequest {
  bucketName?: string;
  pageToken?: string;
  includeConnectedResources?: boolean;
}
export interface GetBucketsResult {
  buckets?: Bucket[];
  nextPageToken?: string;
  accountLevelBpaSync?: AccountLevelBpaSync;
}
export interface GetBundlesRequest {
  includeInactive?: boolean;
  pageToken?: string;
  appCategory?: AppCategory;
}
export interface GetBundlesResult {
  bundles?: Bundle[];
  nextPageToken?: string;
}
export interface GetCertificatesRequest {
  certificateStatuses?: CertificateStatus[];
  includeCertificateDetails?: boolean;
  certificateName?: string;
  pageToken?: string;
}
export interface GetCertificatesResult {
  certificates?: CertificateSummary[];
  nextPageToken?: string;
}
export interface GetCloudFormationStackRecordsRequest {
  pageToken?: string;
}
export interface GetCloudFormationStackRecordsResult {
  cloudFormationStackRecords?: CloudFormationStackRecord[];
  nextPageToken?: string;
}
export interface GetContactMethodsRequest {
  protocols?: ContactProtocol[];
}
export interface GetContactMethodsResult {
  contactMethods?: ContactMethod[];
}
export interface GetContainerAPIMetadataRequest {}
export interface GetContainerAPIMetadataResult {
  metadata?: Record<string, string>[];
}
export interface GetContainerImagesRequest {
  serviceName: string | undefined;
}
export interface GetContainerImagesResult {
  containerImages?: ContainerImage[];
}
export interface GetContainerLogRequest {
  serviceName: string | undefined;
  containerName: string | undefined;
  startTime?: Date;
  endTime?: Date;
  filterPattern?: string;
  pageToken?: string;
}
export interface GetContainerLogResult {
  logEvents?: ContainerServiceLogEvent[];
  nextPageToken?: string;
}
export interface GetContainerServiceDeploymentsRequest {
  serviceName: string | undefined;
}
export interface GetContainerServiceDeploymentsResult {
  deployments?: ContainerServiceDeployment[];
}
export interface GetContainerServiceMetricDataRequest {
  serviceName: string | undefined;
  metricName: ContainerServiceMetricName | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  period: number | undefined;
  statistics: MetricStatistic[] | undefined;
}
export interface GetContainerServiceMetricDataResult {
  metricName?: ContainerServiceMetricName;
  metricData?: MetricDatapoint[];
}
export interface GetContainerServicePowersRequest {}
export declare const AccessKeyFilterSensitiveLog: (obj: AccessKey) => any;
export declare const CreateBucketAccessKeyResultFilterSensitiveLog: (
  obj: CreateBucketAccessKeyResult
) => any;
export declare const SessionFilterSensitiveLog: (obj: Session) => any;
export declare const CreateGUISessionAccessDetailsResultFilterSensitiveLog: (
  obj: CreateGUISessionAccessDetailsResult
) => any;
export declare const CreateRelationalDatabaseRequestFilterSensitiveLog: (
  obj: CreateRelationalDatabaseRequest
) => any;
export declare const GetBucketAccessKeysResultFilterSensitiveLog: (
  obj: GetBucketAccessKeysResult
) => any;
