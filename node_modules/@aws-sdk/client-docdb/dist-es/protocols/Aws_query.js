import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, strictParseInt32 as __strictParseInt32, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { DocDBServiceException as __BaseException } from "../models/DocDBServiceException";
import { AuthorizationNotFoundFault, CertificateNotFoundFault, DBClusterAlreadyExistsFault, DBClusterNotFoundFault, DBClusterParameterGroupNotFoundFault, DBClusterQuotaExceededFault, DBClusterSnapshotAlreadyExistsFault, DBClusterSnapshotNotFoundFault, DBInstanceAlreadyExistsFault, DBInstanceNotFoundFault, DBParameterGroupAlreadyExistsFault, DBParameterGroupNotFoundFault, DBParameterGroupQuotaExceededFault, DBSecurityGroupNotFoundFault, DBSnapshotAlreadyExistsFault, DBSnapshotNotFoundFault, DBSubnetGroupAlreadyExistsFault, DBSubnetGroupDoesNotCoverEnoughAZs, DBSubnetGroupNotFoundFault, DBSubnetGroupQuotaExceededFault, DBSubnetQuotaExceededFault, DBUpgradeDependencyFailureFault, EventSubscriptionQuotaExceededFault, GlobalClusterAlreadyExistsFault, GlobalClusterNotFoundFault, GlobalClusterQuotaExceededFault, InstanceQuotaExceededFault, InsufficientDBClusterCapacityFault, InsufficientDBInstanceCapacityFault, InsufficientStorageClusterCapacityFault, InvalidDBClusterSnapshotStateFault, InvalidDBClusterStateFault, InvalidDBInstanceStateFault, InvalidDBParameterGroupStateFault, InvalidDBSecurityGroupStateFault, InvalidDBSnapshotStateFault, InvalidDBSubnetGroupStateFault, InvalidDBSubnetStateFault, InvalidEventSubscriptionStateFault, InvalidGlobalClusterStateFault, InvalidRestoreFault, InvalidSubnet, InvalidVPCNetworkStateFault, KMSKeyNotAccessibleFault, ResourceNotFoundFault, SharedSnapshotQuotaExceededFault, SnapshotQuotaExceededFault, SNSInvalidTopicFault, SNSNoAuthorizationFault, SNSTopicArnNotFoundFault, SourceNotFoundFault, StorageQuotaExceededFault, StorageTypeNotSupportedFault, SubnetAlreadyInUse, SubscriptionAlreadyExistFault, SubscriptionCategoryNotFoundFault, SubscriptionNotFoundFault, } from "../models/models_0";
export const se_AddSourceIdentifierToSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddSourceIdentifierToSubscriptionMessage(input, context),
        [_A]: _ASITS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddTagsToResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTagsToResourceMessage(input, context),
        [_A]: _ATTR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ApplyPendingMaintenanceActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ApplyPendingMaintenanceActionMessage(input, context),
        [_A]: _APMA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyDBClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyDBClusterParameterGroupMessage(input, context),
        [_A]: _CDBCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyDBClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyDBClusterSnapshotMessage(input, context),
        [_A]: _CDBCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDBClusterMessage(input, context),
        [_A]: _CDBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDBClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDBClusterParameterGroupMessage(input, context),
        [_A]: _CDBCPGr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDBClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDBClusterSnapshotMessage(input, context),
        [_A]: _CDBCSr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDBInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDBInstanceMessage(input, context),
        [_A]: _CDBI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDBSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDBSubnetGroupMessage(input, context),
        [_A]: _CDBSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateEventSubscriptionMessage(input, context),
        [_A]: _CES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateGlobalClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateGlobalClusterMessage(input, context),
        [_A]: _CGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDBClusterMessage(input, context),
        [_A]: _DDBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDBClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDBClusterParameterGroupMessage(input, context),
        [_A]: _DDBCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDBClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDBClusterSnapshotMessage(input, context),
        [_A]: _DDBCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDBInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDBInstanceMessage(input, context),
        [_A]: _DDBI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDBSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDBSubnetGroupMessage(input, context),
        [_A]: _DDBSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteEventSubscriptionMessage(input, context),
        [_A]: _DES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteGlobalClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGlobalClusterMessage(input, context),
        [_A]: _DGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCertificatesMessage(input, context),
        [_A]: _DC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBClusterParameterGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBClusterParameterGroupsMessage(input, context),
        [_A]: _DDBCPGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBClusterParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBClusterParametersMessage(input, context),
        [_A]: _DDBCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBClustersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBClustersMessage(input, context),
        [_A]: _DDBCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBClusterSnapshotAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBClusterSnapshotAttributesMessage(input, context),
        [_A]: _DDBCSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBClusterSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBClusterSnapshotsMessage(input, context),
        [_A]: _DDBCSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBEngineVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBEngineVersionsMessage(input, context),
        [_A]: _DDBEV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBInstancesMessage(input, context),
        [_A]: _DDBIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDBSubnetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDBSubnetGroupsMessage(input, context),
        [_A]: _DDBSGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEngineDefaultClusterParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEngineDefaultClusterParametersMessage(input, context),
        [_A]: _DEDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventCategoriesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventCategoriesMessage(input, context),
        [_A]: _DEC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventsMessage(input, context),
        [_A]: _DE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventSubscriptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventSubscriptionsMessage(input, context),
        [_A]: _DESe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeGlobalClustersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeGlobalClustersMessage(input, context),
        [_A]: _DGCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeOrderableDBInstanceOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeOrderableDBInstanceOptionsMessage(input, context),
        [_A]: _DODBIO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePendingMaintenanceActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePendingMaintenanceActionsMessage(input, context),
        [_A]: _DPMA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_FailoverDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_FailoverDBClusterMessage(input, context),
        [_A]: _FDBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListTagsForResourceMessage(input, context),
        [_A]: _LTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDBClusterMessage(input, context),
        [_A]: _MDBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDBClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDBClusterParameterGroupMessage(input, context),
        [_A]: _MDBCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDBClusterSnapshotAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDBClusterSnapshotAttributeMessage(input, context),
        [_A]: _MDBCSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDBInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDBInstanceMessage(input, context),
        [_A]: _MDBI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDBSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDBSubnetGroupMessage(input, context),
        [_A]: _MDBSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyEventSubscriptionMessage(input, context),
        [_A]: _MES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyGlobalClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyGlobalClusterMessage(input, context),
        [_A]: _MGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RebootDBInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RebootDBInstanceMessage(input, context),
        [_A]: _RDBI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveFromGlobalClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveFromGlobalClusterMessage(input, context),
        [_A]: _RFGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveSourceIdentifierFromSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveSourceIdentifierFromSubscriptionMessage(input, context),
        [_A]: _RSIFS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTagsFromResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTagsFromResourceMessage(input, context),
        [_A]: _RTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetDBClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetDBClusterParameterGroupMessage(input, context),
        [_A]: _RDBCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreDBClusterFromSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreDBClusterFromSnapshotMessage(input, context),
        [_A]: _RDBCFS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreDBClusterToPointInTimeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreDBClusterToPointInTimeMessage(input, context),
        [_A]: _RDBCTPIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartDBClusterMessage(input, context),
        [_A]: _SDBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopDBClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StopDBClusterMessage(input, context),
        [_A]: _SDBCt,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddSourceIdentifierToSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddSourceIdentifierToSubscriptionResult(data.AddSourceIdentifierToSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AddTagsToResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ApplyPendingMaintenanceActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ApplyPendingMaintenanceActionResult(data.ApplyPendingMaintenanceActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyDBClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyDBClusterParameterGroupResult(data.CopyDBClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyDBClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyDBClusterSnapshotResult(data.CopyDBClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDBClusterResult(data.CreateDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDBClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDBClusterParameterGroupResult(data.CreateDBClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDBClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDBClusterSnapshotResult(data.CreateDBClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDBInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDBInstanceResult(data.CreateDBInstanceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDBSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDBSubnetGroupResult(data.CreateDBSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateEventSubscriptionResult(data.CreateEventSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateGlobalClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGlobalClusterResult(data.CreateGlobalClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDBClusterResult(data.DeleteDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDBClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteDBClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDBClusterSnapshotResult(data.DeleteDBClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDBInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDBInstanceResult(data.DeleteDBInstanceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDBSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteEventSubscriptionResult(data.DeleteEventSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteGlobalClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteGlobalClusterResult(data.DeleteGlobalClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CertificateMessage(data.DescribeCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBClusterParameterGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterParameterGroupsMessage(data.DescribeDBClusterParameterGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBClusterParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterParameterGroupDetails(data.DescribeDBClusterParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterMessage(data.DescribeDBClustersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBClusterSnapshotAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDBClusterSnapshotAttributesResult(data.DescribeDBClusterSnapshotAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBClusterSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterSnapshotMessage(data.DescribeDBClusterSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBEngineVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBEngineVersionMessage(data.DescribeDBEngineVersionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBInstanceMessage(data.DescribeDBInstancesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDBSubnetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBSubnetGroupMessage(data.DescribeDBSubnetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEngineDefaultClusterParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEngineDefaultClusterParametersResult(data.DescribeEngineDefaultClusterParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventCategoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventCategoriesMessage(data.DescribeEventCategoriesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventsMessage(data.DescribeEventsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventSubscriptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventSubscriptionsMessage(data.DescribeEventSubscriptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeGlobalClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GlobalClustersMessage(data.DescribeGlobalClustersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeOrderableDBInstanceOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_OrderableDBInstanceOptionsMessage(data.DescribeOrderableDBInstanceOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePendingMaintenanceActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PendingMaintenanceActionsMessage(data.DescribePendingMaintenanceActionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_FailoverDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_FailoverDBClusterResult(data.FailoverDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagListMessage(data.ListTagsForResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDBClusterResult(data.ModifyDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDBClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterParameterGroupNameMessage(data.ModifyDBClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDBClusterSnapshotAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDBClusterSnapshotAttributeResult(data.ModifyDBClusterSnapshotAttributeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDBInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDBInstanceResult(data.ModifyDBInstanceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDBSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDBSubnetGroupResult(data.ModifyDBSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyEventSubscriptionResult(data.ModifyEventSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyGlobalClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyGlobalClusterResult(data.ModifyGlobalClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RebootDBInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RebootDBInstanceResult(data.RebootDBInstanceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveFromGlobalClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveFromGlobalClusterResult(data.RemoveFromGlobalClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveSourceIdentifierFromSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveSourceIdentifierFromSubscriptionResult(data.RemoveSourceIdentifierFromSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveTagsFromResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ResetDBClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DBClusterParameterGroupNameMessage(data.ResetDBClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreDBClusterFromSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreDBClusterFromSnapshotResult(data.RestoreDBClusterFromSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreDBClusterToPointInTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreDBClusterToPointInTimeResult(data.RestoreDBClusterToPointInTimeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartDBClusterResult(data.StartDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StopDBClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopDBClusterResult(data.StopDBClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "SourceNotFound":
        case "com.amazonaws.docdb#SourceNotFoundFault":
            throw await de_SourceNotFoundFaultRes(parsedOutput, context);
        case "SubscriptionNotFound":
        case "com.amazonaws.docdb#SubscriptionNotFoundFault":
            throw await de_SubscriptionNotFoundFaultRes(parsedOutput, context);
        case "DBClusterNotFoundFault":
        case "com.amazonaws.docdb#DBClusterNotFoundFault":
            throw await de_DBClusterNotFoundFaultRes(parsedOutput, context);
        case "DBInstanceNotFound":
        case "com.amazonaws.docdb#DBInstanceNotFoundFault":
            throw await de_DBInstanceNotFoundFaultRes(parsedOutput, context);
        case "DBSnapshotNotFound":
        case "com.amazonaws.docdb#DBSnapshotNotFoundFault":
            throw await de_DBSnapshotNotFoundFaultRes(parsedOutput, context);
        case "InvalidDBClusterStateFault":
        case "com.amazonaws.docdb#InvalidDBClusterStateFault":
            throw await de_InvalidDBClusterStateFaultRes(parsedOutput, context);
        case "InvalidDBInstanceState":
        case "com.amazonaws.docdb#InvalidDBInstanceStateFault":
            throw await de_InvalidDBInstanceStateFaultRes(parsedOutput, context);
        case "ResourceNotFoundFault":
        case "com.amazonaws.docdb#ResourceNotFoundFault":
            throw await de_ResourceNotFoundFaultRes(parsedOutput, context);
        case "DBParameterGroupAlreadyExists":
        case "com.amazonaws.docdb#DBParameterGroupAlreadyExistsFault":
            throw await de_DBParameterGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "DBParameterGroupNotFound":
        case "com.amazonaws.docdb#DBParameterGroupNotFoundFault":
            throw await de_DBParameterGroupNotFoundFaultRes(parsedOutput, context);
        case "DBParameterGroupQuotaExceeded":
        case "com.amazonaws.docdb#DBParameterGroupQuotaExceededFault":
            throw await de_DBParameterGroupQuotaExceededFaultRes(parsedOutput, context);
        case "DBClusterSnapshotAlreadyExistsFault":
        case "com.amazonaws.docdb#DBClusterSnapshotAlreadyExistsFault":
            throw await de_DBClusterSnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "DBClusterSnapshotNotFoundFault":
        case "com.amazonaws.docdb#DBClusterSnapshotNotFoundFault":
            throw await de_DBClusterSnapshotNotFoundFaultRes(parsedOutput, context);
        case "InvalidDBClusterSnapshotStateFault":
        case "com.amazonaws.docdb#InvalidDBClusterSnapshotStateFault":
            throw await de_InvalidDBClusterSnapshotStateFaultRes(parsedOutput, context);
        case "KMSKeyNotAccessibleFault":
        case "com.amazonaws.docdb#KMSKeyNotAccessibleFault":
            throw await de_KMSKeyNotAccessibleFaultRes(parsedOutput, context);
        case "SnapshotQuotaExceeded":
        case "com.amazonaws.docdb#SnapshotQuotaExceededFault":
            throw await de_SnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "DBClusterAlreadyExistsFault":
        case "com.amazonaws.docdb#DBClusterAlreadyExistsFault":
            throw await de_DBClusterAlreadyExistsFaultRes(parsedOutput, context);
        case "DBClusterParameterGroupNotFound":
        case "com.amazonaws.docdb#DBClusterParameterGroupNotFoundFault":
            throw await de_DBClusterParameterGroupNotFoundFaultRes(parsedOutput, context);
        case "DBClusterQuotaExceededFault":
        case "com.amazonaws.docdb#DBClusterQuotaExceededFault":
            throw await de_DBClusterQuotaExceededFaultRes(parsedOutput, context);
        case "DBSubnetGroupDoesNotCoverEnoughAZs":
        case "com.amazonaws.docdb#DBSubnetGroupDoesNotCoverEnoughAZs":
            throw await de_DBSubnetGroupDoesNotCoverEnoughAZsRes(parsedOutput, context);
        case "DBSubnetGroupNotFoundFault":
        case "com.amazonaws.docdb#DBSubnetGroupNotFoundFault":
            throw await de_DBSubnetGroupNotFoundFaultRes(parsedOutput, context);
        case "GlobalClusterNotFoundFault":
        case "com.amazonaws.docdb#GlobalClusterNotFoundFault":
            throw await de_GlobalClusterNotFoundFaultRes(parsedOutput, context);
        case "InsufficientStorageClusterCapacity":
        case "com.amazonaws.docdb#InsufficientStorageClusterCapacityFault":
            throw await de_InsufficientStorageClusterCapacityFaultRes(parsedOutput, context);
        case "InvalidDBSubnetGroupStateFault":
        case "com.amazonaws.docdb#InvalidDBSubnetGroupStateFault":
            throw await de_InvalidDBSubnetGroupStateFaultRes(parsedOutput, context);
        case "InvalidGlobalClusterStateFault":
        case "com.amazonaws.docdb#InvalidGlobalClusterStateFault":
            throw await de_InvalidGlobalClusterStateFaultRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.docdb#InvalidSubnet":
            throw await de_InvalidSubnetRes(parsedOutput, context);
        case "InvalidVPCNetworkStateFault":
        case "com.amazonaws.docdb#InvalidVPCNetworkStateFault":
            throw await de_InvalidVPCNetworkStateFaultRes(parsedOutput, context);
        case "StorageQuotaExceeded":
        case "com.amazonaws.docdb#StorageQuotaExceededFault":
            throw await de_StorageQuotaExceededFaultRes(parsedOutput, context);
        case "AuthorizationNotFound":
        case "com.amazonaws.docdb#AuthorizationNotFoundFault":
            throw await de_AuthorizationNotFoundFaultRes(parsedOutput, context);
        case "DBInstanceAlreadyExists":
        case "com.amazonaws.docdb#DBInstanceAlreadyExistsFault":
            throw await de_DBInstanceAlreadyExistsFaultRes(parsedOutput, context);
        case "DBSecurityGroupNotFound":
        case "com.amazonaws.docdb#DBSecurityGroupNotFoundFault":
            throw await de_DBSecurityGroupNotFoundFaultRes(parsedOutput, context);
        case "InstanceQuotaExceeded":
        case "com.amazonaws.docdb#InstanceQuotaExceededFault":
            throw await de_InstanceQuotaExceededFaultRes(parsedOutput, context);
        case "InsufficientDBInstanceCapacity":
        case "com.amazonaws.docdb#InsufficientDBInstanceCapacityFault":
            throw await de_InsufficientDBInstanceCapacityFaultRes(parsedOutput, context);
        case "StorageTypeNotSupported":
        case "com.amazonaws.docdb#StorageTypeNotSupportedFault":
            throw await de_StorageTypeNotSupportedFaultRes(parsedOutput, context);
        case "DBSubnetGroupAlreadyExists":
        case "com.amazonaws.docdb#DBSubnetGroupAlreadyExistsFault":
            throw await de_DBSubnetGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "DBSubnetGroupQuotaExceeded":
        case "com.amazonaws.docdb#DBSubnetGroupQuotaExceededFault":
            throw await de_DBSubnetGroupQuotaExceededFaultRes(parsedOutput, context);
        case "DBSubnetQuotaExceededFault":
        case "com.amazonaws.docdb#DBSubnetQuotaExceededFault":
            throw await de_DBSubnetQuotaExceededFaultRes(parsedOutput, context);
        case "EventSubscriptionQuotaExceeded":
        case "com.amazonaws.docdb#EventSubscriptionQuotaExceededFault":
            throw await de_EventSubscriptionQuotaExceededFaultRes(parsedOutput, context);
        case "SNSInvalidTopic":
        case "com.amazonaws.docdb#SNSInvalidTopicFault":
            throw await de_SNSInvalidTopicFaultRes(parsedOutput, context);
        case "SNSNoAuthorization":
        case "com.amazonaws.docdb#SNSNoAuthorizationFault":
            throw await de_SNSNoAuthorizationFaultRes(parsedOutput, context);
        case "SNSTopicArnNotFound":
        case "com.amazonaws.docdb#SNSTopicArnNotFoundFault":
            throw await de_SNSTopicArnNotFoundFaultRes(parsedOutput, context);
        case "SubscriptionAlreadyExist":
        case "com.amazonaws.docdb#SubscriptionAlreadyExistFault":
            throw await de_SubscriptionAlreadyExistFaultRes(parsedOutput, context);
        case "SubscriptionCategoryNotFound":
        case "com.amazonaws.docdb#SubscriptionCategoryNotFoundFault":
            throw await de_SubscriptionCategoryNotFoundFaultRes(parsedOutput, context);
        case "GlobalClusterAlreadyExistsFault":
        case "com.amazonaws.docdb#GlobalClusterAlreadyExistsFault":
            throw await de_GlobalClusterAlreadyExistsFaultRes(parsedOutput, context);
        case "GlobalClusterQuotaExceededFault":
        case "com.amazonaws.docdb#GlobalClusterQuotaExceededFault":
            throw await de_GlobalClusterQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidDBParameterGroupState":
        case "com.amazonaws.docdb#InvalidDBParameterGroupStateFault":
            throw await de_InvalidDBParameterGroupStateFaultRes(parsedOutput, context);
        case "DBSnapshotAlreadyExists":
        case "com.amazonaws.docdb#DBSnapshotAlreadyExistsFault":
            throw await de_DBSnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "InvalidDBSubnetStateFault":
        case "com.amazonaws.docdb#InvalidDBSubnetStateFault":
            throw await de_InvalidDBSubnetStateFaultRes(parsedOutput, context);
        case "InvalidEventSubscriptionState":
        case "com.amazonaws.docdb#InvalidEventSubscriptionStateFault":
            throw await de_InvalidEventSubscriptionStateFaultRes(parsedOutput, context);
        case "CertificateNotFound":
        case "com.amazonaws.docdb#CertificateNotFoundFault":
            throw await de_CertificateNotFoundFaultRes(parsedOutput, context);
        case "InvalidDBSecurityGroupState":
        case "com.amazonaws.docdb#InvalidDBSecurityGroupStateFault":
            throw await de_InvalidDBSecurityGroupStateFaultRes(parsedOutput, context);
        case "SharedSnapshotQuotaExceeded":
        case "com.amazonaws.docdb#SharedSnapshotQuotaExceededFault":
            throw await de_SharedSnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "DBUpgradeDependencyFailure":
        case "com.amazonaws.docdb#DBUpgradeDependencyFailureFault":
            throw await de_DBUpgradeDependencyFailureFaultRes(parsedOutput, context);
        case "SubnetAlreadyInUse":
        case "com.amazonaws.docdb#SubnetAlreadyInUse":
            throw await de_SubnetAlreadyInUseRes(parsedOutput, context);
        case "InsufficientDBClusterCapacityFault":
        case "com.amazonaws.docdb#InsufficientDBClusterCapacityFault":
            throw await de_InsufficientDBClusterCapacityFaultRes(parsedOutput, context);
        case "InvalidDBSnapshotState":
        case "com.amazonaws.docdb#InvalidDBSnapshotStateFault":
            throw await de_InvalidDBSnapshotStateFaultRes(parsedOutput, context);
        case "InvalidRestoreFault":
        case "com.amazonaws.docdb#InvalidRestoreFault":
            throw await de_InvalidRestoreFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AuthorizationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationNotFoundFault(body.Error, context);
    const exception = new AuthorizationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CertificateNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CertificateNotFoundFault(body.Error, context);
    const exception = new CertificateNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterAlreadyExistsFault(body.Error, context);
    const exception = new DBClusterAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterNotFoundFault(body.Error, context);
    const exception = new DBClusterNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterParameterGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterParameterGroupNotFoundFault(body.Error, context);
    const exception = new DBClusterParameterGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterQuotaExceededFault(body.Error, context);
    const exception = new DBClusterQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterSnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterSnapshotAlreadyExistsFault(body.Error, context);
    const exception = new DBClusterSnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBClusterSnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBClusterSnapshotNotFoundFault(body.Error, context);
    const exception = new DBClusterSnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBInstanceAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBInstanceAlreadyExistsFault(body.Error, context);
    const exception = new DBInstanceAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBInstanceNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBInstanceNotFoundFault(body.Error, context);
    const exception = new DBInstanceNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBParameterGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBParameterGroupAlreadyExistsFault(body.Error, context);
    const exception = new DBParameterGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBParameterGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBParameterGroupNotFoundFault(body.Error, context);
    const exception = new DBParameterGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBParameterGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBParameterGroupQuotaExceededFault(body.Error, context);
    const exception = new DBParameterGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSecurityGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSecurityGroupNotFoundFault(body.Error, context);
    const exception = new DBSecurityGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSnapshotAlreadyExistsFault(body.Error, context);
    const exception = new DBSnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSnapshotNotFoundFault(body.Error, context);
    const exception = new DBSnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSubnetGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSubnetGroupAlreadyExistsFault(body.Error, context);
    const exception = new DBSubnetGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSubnetGroupDoesNotCoverEnoughAZsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSubnetGroupDoesNotCoverEnoughAZs(body.Error, context);
    const exception = new DBSubnetGroupDoesNotCoverEnoughAZs({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSubnetGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSubnetGroupNotFoundFault(body.Error, context);
    const exception = new DBSubnetGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSubnetGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSubnetGroupQuotaExceededFault(body.Error, context);
    const exception = new DBSubnetGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBSubnetQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBSubnetQuotaExceededFault(body.Error, context);
    const exception = new DBSubnetQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DBUpgradeDependencyFailureFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DBUpgradeDependencyFailureFault(body.Error, context);
    const exception = new DBUpgradeDependencyFailureFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EventSubscriptionQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EventSubscriptionQuotaExceededFault(body.Error, context);
    const exception = new EventSubscriptionQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_GlobalClusterAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalClusterAlreadyExistsFault(body.Error, context);
    const exception = new GlobalClusterAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_GlobalClusterNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalClusterNotFoundFault(body.Error, context);
    const exception = new GlobalClusterNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_GlobalClusterQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_GlobalClusterQuotaExceededFault(body.Error, context);
    const exception = new GlobalClusterQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InstanceQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InstanceQuotaExceededFault(body.Error, context);
    const exception = new InstanceQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientDBClusterCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientDBClusterCapacityFault(body.Error, context);
    const exception = new InsufficientDBClusterCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientDBInstanceCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientDBInstanceCapacityFault(body.Error, context);
    const exception = new InsufficientDBInstanceCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientStorageClusterCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientStorageClusterCapacityFault(body.Error, context);
    const exception = new InsufficientStorageClusterCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBClusterSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBClusterSnapshotStateFault(body.Error, context);
    const exception = new InvalidDBClusterSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBClusterStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBClusterStateFault(body.Error, context);
    const exception = new InvalidDBClusterStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBInstanceStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBInstanceStateFault(body.Error, context);
    const exception = new InvalidDBInstanceStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBParameterGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBParameterGroupStateFault(body.Error, context);
    const exception = new InvalidDBParameterGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBSecurityGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBSecurityGroupStateFault(body.Error, context);
    const exception = new InvalidDBSecurityGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBSnapshotStateFault(body.Error, context);
    const exception = new InvalidDBSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBSubnetGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBSubnetGroupStateFault(body.Error, context);
    const exception = new InvalidDBSubnetGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDBSubnetStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDBSubnetStateFault(body.Error, context);
    const exception = new InvalidDBSubnetStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidEventSubscriptionStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidEventSubscriptionStateFault(body.Error, context);
    const exception = new InvalidEventSubscriptionStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidGlobalClusterStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidGlobalClusterStateFault(body.Error, context);
    const exception = new InvalidGlobalClusterStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRestoreFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRestoreFault(body.Error, context);
    const exception = new InvalidRestoreFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnet(body.Error, context);
    const exception = new InvalidSubnet({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidVPCNetworkStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidVPCNetworkStateFault(body.Error, context);
    const exception = new InvalidVPCNetworkStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_KMSKeyNotAccessibleFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_KMSKeyNotAccessibleFault(body.Error, context);
    const exception = new KMSKeyNotAccessibleFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundFault(body.Error, context);
    const exception = new ResourceNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SharedSnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SharedSnapshotQuotaExceededFault(body.Error, context);
    const exception = new SharedSnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotQuotaExceededFault(body.Error, context);
    const exception = new SnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSInvalidTopicFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSInvalidTopicFault(body.Error, context);
    const exception = new SNSInvalidTopicFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSNoAuthorizationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSNoAuthorizationFault(body.Error, context);
    const exception = new SNSNoAuthorizationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSTopicArnNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSTopicArnNotFoundFault(body.Error, context);
    const exception = new SNSTopicArnNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SourceNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SourceNotFoundFault(body.Error, context);
    const exception = new SourceNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_StorageQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_StorageQuotaExceededFault(body.Error, context);
    const exception = new StorageQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_StorageTypeNotSupportedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_StorageTypeNotSupportedFault(body.Error, context);
    const exception = new StorageTypeNotSupportedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetAlreadyInUseRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetAlreadyInUse(body.Error, context);
    const exception = new SubnetAlreadyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionAlreadyExistFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionAlreadyExistFault(body.Error, context);
    const exception = new SubscriptionAlreadyExistFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionCategoryNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionCategoryNotFoundFault(body.Error, context);
    const exception = new SubscriptionCategoryNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionNotFoundFault(body.Error, context);
    const exception = new SubscriptionNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AddSourceIdentifierToSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    return entries;
};
const se_AddTagsToResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ApplyPendingMaintenanceActionMessage = (input, context) => {
    const entries = {};
    if (input[_RI] != null) {
        entries[_RI] = input[_RI];
    }
    if (input[_AA] != null) {
        entries[_AA] = input[_AA];
    }
    if (input[_OIT] != null) {
        entries[_OIT] = input[_OIT];
    }
    return entries;
};
const se_AttributeValueList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AttributeValue.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AvailabilityZones = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AvailabilityZone.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CloudwatchLogsExportConfiguration = (input, context) => {
    const entries = {};
    if (input[_ELT] != null) {
        const memberEntries = se_LogTypeList(input[_ELT], context);
        if (input[_ELT]?.length === 0) {
            entries.EnableLogTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableLogTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DLT] != null) {
        const memberEntries = se_LogTypeList(input[_DLT], context);
        if (input[_DLT]?.length === 0) {
            entries.DisableLogTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DisableLogTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CopyDBClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_SDBCPGI] != null) {
        entries[_SDBCPGI] = input[_SDBCPGI];
    }
    if (input[_TDBCPGI] != null) {
        entries[_TDBCPGI] = input[_TDBCPGI];
    }
    if (input[_TDBCPGD] != null) {
        entries[_TDBCPGD] = input[_TDBCPGD];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CopyDBClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SDBCSI] != null) {
        entries[_SDBCSI] = input[_SDBCSI];
    }
    if (input[_TDBCSI] != null) {
        entries[_TDBCSI] = input[_TDBCSI];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_PSU] != null) {
        entries[_PSU] = input[_PSU];
    }
    if (input[_CT] != null) {
        entries[_CT] = input[_CT];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BRP] != null) {
        entries[_BRP] = input[_BRP];
    }
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_MU] != null) {
        entries[_MU] = input[_MU];
    }
    if (input[_MUP] != null) {
        entries[_MUP] = input[_MUP];
    }
    if (input[_PBW] != null) {
        entries[_PBW] = input[_PBW];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_PSU] != null) {
        entries[_PSU] = input[_PSU];
    }
    if (input[_ECLE] != null) {
        const memberEntries = se_LogTypeList(input[_ECLE], context);
        if (input[_ECLE]?.length === 0) {
            entries.EnableCloudwatchLogsExports = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableCloudwatchLogsExports.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    return entries;
};
const se_CreateDBClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_DBPGF] != null) {
        entries[_DBPGF] = input[_DBPGF];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateDBClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_DBCSI] != null) {
        entries[_DBCSI] = input[_DBCSI];
    }
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateDBInstanceMessage = (input, context) => {
    const entries = {};
    if (input[_DBII] != null) {
        entries[_DBII] = input[_DBII];
    }
    if (input[_DBIC] != null) {
        entries[_DBIC] = input[_DBIC];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_AZv] != null) {
        entries[_AZv] = input[_AZv];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_CTTS] != null) {
        entries[_CTTS] = input[_CTTS];
    }
    if (input[_PT] != null) {
        entries[_PT] = input[_PT];
    }
    if (input[_EPI] != null) {
        entries[_EPI] = input[_EPI];
    }
    if (input[_PIKMSKI] != null) {
        entries[_PIKMSKI] = input[_PIKMSKI];
    }
    if (input[_CACI] != null) {
        entries[_CACI] = input[_CACI];
    }
    return entries;
};
const se_CreateDBSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_DBSGD] != null) {
        entries[_DBSGD] = input[_DBSGD];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SIu], context);
        if (input[_SIu]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_STA] != null) {
        entries[_STA] = input[_STA];
    }
    if (input[_STo] != null) {
        entries[_STo] = input[_STo];
    }
    if (input[_EC] != null) {
        const memberEntries = se_EventCategoriesList(input[_EC], context);
        if (input[_EC]?.length === 0) {
            entries.EventCategories = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EventCategories.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIo] != null) {
        const memberEntries = se_SourceIdsList(input[_SIo], context);
        if (input[_SIo]?.length === 0) {
            entries.SourceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateGlobalClusterMessage = (input, context) => {
    const entries = {};
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    if (input[_SDBCI] != null) {
        entries[_SDBCI] = input[_SDBCI];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    return entries;
};
const se_DeleteDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_SFS] != null) {
        entries[_SFS] = input[_SFS];
    }
    if (input[_FDBSI] != null) {
        entries[_FDBSI] = input[_FDBSI];
    }
    return entries;
};
const se_DeleteDBClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    return entries;
};
const se_DeleteDBClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_DBCSI] != null) {
        entries[_DBCSI] = input[_DBCSI];
    }
    return entries;
};
const se_DeleteDBInstanceMessage = (input, context) => {
    const entries = {};
    if (input[_DBII] != null) {
        entries[_DBII] = input[_DBII];
    }
    return entries;
};
const se_DeleteDBSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    return entries;
};
const se_DeleteEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_DeleteGlobalClusterMessage = (input, context) => {
    const entries = {};
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    return entries;
};
const se_DescribeCertificatesMessage = (input, context) => {
    const entries = {};
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDBClusterParameterGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDBClusterParametersMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDBClustersMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDBClusterSnapshotAttributesMessage = (input, context) => {
    const entries = {};
    if (input[_DBCSI] != null) {
        entries[_DBCSI] = input[_DBCSI];
    }
    return entries;
};
const se_DescribeDBClusterSnapshotsMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_DBCSI] != null) {
        entries[_DBCSI] = input[_DBCSI];
    }
    if (input[_STn] != null) {
        entries[_STn] = input[_STn];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_IS] != null) {
        entries[_IS] = input[_IS];
    }
    if (input[_IP] != null) {
        entries[_IP] = input[_IP];
    }
    return entries;
};
const se_DescribeDBEngineVersionsMessage = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_DBPGF] != null) {
        entries[_DBPGF] = input[_DBPGF];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_DO] != null) {
        entries[_DO] = input[_DO];
    }
    if (input[_LSCS] != null) {
        entries[_LSCS] = input[_LSCS];
    }
    if (input[_LST] != null) {
        entries[_LST] = input[_LST];
    }
    return entries;
};
const se_DescribeDBInstancesMessage = (input, context) => {
    const entries = {};
    if (input[_DBII] != null) {
        entries[_DBII] = input[_DBII];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDBSubnetGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEngineDefaultClusterParametersMessage = (input, context) => {
    const entries = {};
    if (input[_DBPGF] != null) {
        entries[_DBPGF] = input[_DBPGF];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEventCategoriesMessage = (input, context) => {
    const entries = {};
    if (input[_STo] != null) {
        entries[_STo] = input[_STo];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeEventsMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_STo] != null) {
        entries[_STo] = input[_STo];
    }
    if (input[_STt] != null) {
        entries[_STt] = input[_STt].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_Du] != null) {
        entries[_Du] = input[_Du];
    }
    if (input[_EC] != null) {
        const memberEntries = se_EventCategoriesList(input[_EC], context);
        if (input[_EC]?.length === 0) {
            entries.EventCategories = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EventCategories.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEventSubscriptionsMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeGlobalClustersMessage = (input, context) => {
    const entries = {};
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeOrderableDBInstanceOptionsMessage = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_DBIC] != null) {
        entries[_DBIC] = input[_DBIC];
    }
    if (input[_LM] != null) {
        entries[_LM] = input[_LM];
    }
    if (input[_Vp] != null) {
        entries[_Vp] = input[_Vp];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribePendingMaintenanceActionsMessage = (input, context) => {
    const entries = {};
    if (input[_RI] != null) {
        entries[_RI] = input[_RI];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_EventCategoriesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`EventCategory.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FailoverDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_TDBII] != null) {
        entries[_TDBII] = input[_TDBII];
    }
    return entries;
};
const se_Filter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_Va] != null) {
        const memberEntries = se_FilterValueList(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Filter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Filter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FilterValueList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Value.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_KeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ListTagsForResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_F] != null) {
        const memberEntries = se_FilterList(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LogTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ModifyDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_NDBCI] != null) {
        entries[_NDBCI] = input[_NDBCI];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_BRP] != null) {
        entries[_BRP] = input[_BRP];
    }
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_MUP] != null) {
        entries[_MUP] = input[_MUP];
    }
    if (input[_PBW] != null) {
        entries[_PBW] = input[_PBW];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_CLEC] != null) {
        const memberEntries = se_CloudwatchLogsExportConfiguration(input[_CLEC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CloudwatchLogsExportConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_AMVUl] != null) {
        entries[_AMVUl] = input[_AMVUl];
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    return entries;
};
const se_ModifyDBClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_Pa] != null) {
        const memberEntries = se_ParametersList(input[_Pa], context);
        if (input[_Pa]?.length === 0) {
            entries.Parameters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Parameters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyDBClusterSnapshotAttributeMessage = (input, context) => {
    const entries = {};
    if (input[_DBCSI] != null) {
        entries[_DBCSI] = input[_DBCSI];
    }
    if (input[_AN] != null) {
        entries[_AN] = input[_AN];
    }
    if (input[_VTA] != null) {
        const memberEntries = se_AttributeValueList(input[_VTA], context);
        if (input[_VTA]?.length === 0) {
            entries.ValuesToAdd = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ValuesToAdd.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VTR] != null) {
        const memberEntries = se_AttributeValueList(input[_VTR], context);
        if (input[_VTR]?.length === 0) {
            entries.ValuesToRemove = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ValuesToRemove.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyDBInstanceMessage = (input, context) => {
    const entries = {};
    if (input[_DBII] != null) {
        entries[_DBII] = input[_DBII];
    }
    if (input[_DBIC] != null) {
        entries[_DBIC] = input[_DBIC];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_AMVU] != null) {
        entries[_AMVU] = input[_AMVU];
    }
    if (input[_NDBII] != null) {
        entries[_NDBII] = input[_NDBII];
    }
    if (input[_CACI] != null) {
        entries[_CACI] = input[_CACI];
    }
    if (input[_CTTS] != null) {
        entries[_CTTS] = input[_CTTS];
    }
    if (input[_PT] != null) {
        entries[_PT] = input[_PT];
    }
    if (input[_EPI] != null) {
        entries[_EPI] = input[_EPI];
    }
    if (input[_PIKMSKI] != null) {
        entries[_PIKMSKI] = input[_PIKMSKI];
    }
    if (input[_CRR] != null) {
        entries[_CRR] = input[_CRR];
    }
    return entries;
};
const se_ModifyDBSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_DBSGD] != null) {
        entries[_DBSGD] = input[_DBSGD];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SIu], context);
        if (input[_SIu]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_STA] != null) {
        entries[_STA] = input[_STA];
    }
    if (input[_STo] != null) {
        entries[_STo] = input[_STo];
    }
    if (input[_EC] != null) {
        const memberEntries = se_EventCategoriesList(input[_EC], context);
        if (input[_EC]?.length === 0) {
            entries.EventCategories = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EventCategories.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_ModifyGlobalClusterMessage = (input, context) => {
    const entries = {};
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    if (input[_NGCI] != null) {
        entries[_NGCI] = input[_NGCI];
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    return entries;
};
const se_Parameter = (input, context) => {
    const entries = {};
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PV] != null) {
        entries[_PV] = input[_PV];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_DT] != null) {
        entries[_DT] = input[_DT];
    }
    if (input[_AV] != null) {
        entries[_AV] = input[_AV];
    }
    if (input[_IM] != null) {
        entries[_IM] = input[_IM];
    }
    if (input[_MEV] != null) {
        entries[_MEV] = input[_MEV];
    }
    if (input[_AM] != null) {
        entries[_AM] = input[_AM];
    }
    return entries;
};
const se_ParametersList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Parameter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Parameter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RebootDBInstanceMessage = (input, context) => {
    const entries = {};
    if (input[_DBII] != null) {
        entries[_DBII] = input[_DBII];
    }
    if (input[_FF] != null) {
        entries[_FF] = input[_FF];
    }
    return entries;
};
const se_RemoveFromGlobalClusterMessage = (input, context) => {
    const entries = {};
    if (input[_GCI] != null) {
        entries[_GCI] = input[_GCI];
    }
    if (input[_DCI] != null) {
        entries[_DCI] = input[_DCI];
    }
    return entries;
};
const se_RemoveSourceIdentifierFromSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    return entries;
};
const se_RemoveTagsFromResourceMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_KeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ResetDBClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_RAP] != null) {
        entries[_RAP] = input[_RAP];
    }
    if (input[_Pa] != null) {
        const memberEntries = se_ParametersList(input[_Pa], context);
        if (input[_Pa]?.length === 0) {
            entries.Parameters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Parameters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RestoreDBClusterFromSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_ECLE] != null) {
        const memberEntries = se_LogTypeList(input[_ECLE], context);
        if (input[_ECLE]?.length === 0) {
            entries.EnableCloudwatchLogsExports = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableCloudwatchLogsExports.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    if (input[_DBCPGN] != null) {
        entries[_DBCPGN] = input[_DBCPGN];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    return entries;
};
const se_RestoreDBClusterToPointInTimeMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_SDBCI] != null) {
        entries[_SDBCI] = input[_SDBCI];
    }
    if (input[_RTT] != null) {
        entries[_RTT] = input[_RTT].toISOString().split(".")[0] + "Z";
    }
    if (input[_ULRT] != null) {
        entries[_ULRT] = input[_ULRT];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DBSGN] != null) {
        entries[_DBSGN] = input[_DBSGN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_ECLE] != null) {
        const memberEntries = se_LogTypeList(input[_ECLE], context);
        if (input[_ECLE]?.length === 0) {
            entries.EnableCloudwatchLogsExports = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableCloudwatchLogsExports.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    return entries;
};
const se_SourceIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SourceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_StartDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    return entries;
};
const se_StopDBClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBCI] != null) {
        entries[_DBCI] = input[_DBCI];
    }
    return entries;
};
const se_SubnetIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SubnetIdentifier.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Tag.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_VpcSecurityGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpcSecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const de_AddSourceIdentifierToSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_ApplyPendingMaintenanceActionResult = (output, context) => {
    const contents = {};
    if (output[_RPMA] != null) {
        contents[_RPMA] = de_ResourcePendingMaintenanceActions(output[_RPMA], context);
    }
    return contents;
};
const de_AttributeValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AuthorizationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    return contents;
};
const de_AvailabilityZoneList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZone(entry, context);
    });
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CACertificateIdentifiersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Certificate = (output, context) => {
    const contents = {};
    if (output[_CI] != null) {
        contents[_CI] = __expectString(output[_CI]);
    }
    if (output[_CTe] != null) {
        contents[_CTe] = __expectString(output[_CTe]);
    }
    if (output[_Th] != null) {
        contents[_Th] = __expectString(output[_Th]);
    }
    if (output[_VF] != null) {
        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_VF]));
    }
    if (output[_VT] != null) {
        contents[_VT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_VT]));
    }
    if (output[_CA] != null) {
        contents[_CA] = __expectString(output[_CA]);
    }
    return contents;
};
const de_CertificateDetails = (output, context) => {
    const contents = {};
    if (output[_CAI] != null) {
        contents[_CAI] = __expectString(output[_CAI]);
    }
    if (output[_VT] != null) {
        contents[_VT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_VT]));
    }
    return contents;
};
const de_CertificateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Certificate(entry, context);
    });
};
const de_CertificateMessage = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents[_C] = [];
    }
    else if (output[_C] != null && output[_C][_Ce] != null) {
        contents[_C] = de_CertificateList(__getArrayIfSingleItem(output[_C][_Ce]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_CertificateNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CopyDBClusterParameterGroupResult = (output, context) => {
    const contents = {};
    if (output[_DBCPG] != null) {
        contents[_DBCPG] = de_DBClusterParameterGroup(output[_DBCPG], context);
    }
    return contents;
};
const de_CopyDBClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_DBCS] != null) {
        contents[_DBCS] = de_DBClusterSnapshot(output[_DBCS], context);
    }
    return contents;
};
const de_CreateDBClusterParameterGroupResult = (output, context) => {
    const contents = {};
    if (output[_DBCPG] != null) {
        contents[_DBCPG] = de_DBClusterParameterGroup(output[_DBCPG], context);
    }
    return contents;
};
const de_CreateDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_CreateDBClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_DBCS] != null) {
        contents[_DBCS] = de_DBClusterSnapshot(output[_DBCS], context);
    }
    return contents;
};
const de_CreateDBInstanceResult = (output, context) => {
    const contents = {};
    if (output[_DBI] != null) {
        contents[_DBI] = de_DBInstance(output[_DBI], context);
    }
    return contents;
};
const de_CreateDBSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_DBSG] != null) {
        contents[_DBSG] = de_DBSubnetGroup(output[_DBSG], context);
    }
    return contents;
};
const de_CreateEventSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_CreateGlobalClusterResult = (output, context) => {
    const contents = {};
    if (output[_GC] != null) {
        contents[_GC] = de_GlobalCluster(output[_GC], context);
    }
    return contents;
};
const de_DBCluster = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_AZv] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_AZv]), context);
    }
    if (output[_BRP] != null) {
        contents[_BRP] = __strictParseInt32(output[_BRP]);
    }
    if (output[_DBCI] != null) {
        contents[_DBCI] = __expectString(output[_DBCI]);
    }
    if (output[_DBCPG] != null) {
        contents[_DBCPG] = __expectString(output[_DBCPG]);
    }
    if (output[_DBSG] != null) {
        contents[_DBSG] = __expectString(output[_DBSG]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_PP] != null) {
        contents[_PP] = __expectString(output[_PP]);
    }
    if (output[_ERT] != null) {
        contents[_ERT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ERT]));
    }
    if (output[_End] != null) {
        contents[_End] = __expectString(output[_End]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __expectString(output[_RE]);
    }
    if (output[_MAZ] != null) {
        contents[_MAZ] = __parseBoolean(output[_MAZ]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_LRT] != null) {
        contents[_LRT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LRT]));
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_MU] != null) {
        contents[_MU] = __expectString(output[_MU]);
    }
    if (output[_PBW] != null) {
        contents[_PBW] = __expectString(output[_PBW]);
    }
    if (output[_PMW] != null) {
        contents[_PMW] = __expectString(output[_PMW]);
    }
    if (output[_RSI] != null) {
        contents[_RSI] = __expectString(output[_RSI]);
    }
    if (output.ReadReplicaIdentifiers === "") {
        contents[_RRI] = [];
    }
    else if (output[_RRI] != null && output[_RRI][_RRIe] != null) {
        contents[_RRI] = de_ReadReplicaIdentifierList(__getArrayIfSingleItem(output[_RRI][_RRIe]), context);
    }
    if (output.DBClusterMembers === "") {
        contents[_DBCM] = [];
    }
    else if (output[_DBCM] != null && output[_DBCM][_DBCMl] != null) {
        contents[_DBCM] = de_DBClusterMemberList(__getArrayIfSingleItem(output[_DBCM][_DBCMl]), context);
    }
    if (output.VpcSecurityGroups === "") {
        contents[_VSG] = [];
    }
    else if (output[_VSG] != null && output[_VSG][_VSGM] != null) {
        contents[_VSG] = de_VpcSecurityGroupMembershipList(__getArrayIfSingleItem(output[_VSG][_VSGM]), context);
    }
    if (output[_HZI] != null) {
        contents[_HZI] = __expectString(output[_HZI]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_DCRI] != null) {
        contents[_DCRI] = __expectString(output[_DCRI]);
    }
    if (output[_DBCA] != null) {
        contents[_DBCA] = __expectString(output[_DBCA]);
    }
    if (output.AssociatedRoles === "") {
        contents[_AR] = [];
    }
    else if (output[_AR] != null && output[_AR][_DBCR] != null) {
        contents[_AR] = de_DBClusterRoles(__getArrayIfSingleItem(output[_AR][_DBCR]), context);
    }
    if (output[_CGI] != null) {
        contents[_CGI] = __expectString(output[_CGI]);
    }
    if (output[_CCT] != null) {
        contents[_CCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCT]));
    }
    if (output.EnabledCloudwatchLogsExports === "") {
        contents[_ECLEn] = [];
    }
    else if (output[_ECLEn] != null && output[_ECLEn][_me] != null) {
        contents[_ECLEn] = de_LogTypeList(__getArrayIfSingleItem(output[_ECLEn][_me]), context);
    }
    if (output[_DP] != null) {
        contents[_DP] = __parseBoolean(output[_DP]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    return contents;
};
const de_DBClusterAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBClusterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBCluster(entry, context);
    });
};
const de_DBClusterMember = (output, context) => {
    const contents = {};
    if (output[_DBII] != null) {
        contents[_DBII] = __expectString(output[_DBII]);
    }
    if (output[_ICW] != null) {
        contents[_ICW] = __parseBoolean(output[_ICW]);
    }
    if (output[_DBCPGS] != null) {
        contents[_DBCPGS] = __expectString(output[_DBCPGS]);
    }
    if (output[_PT] != null) {
        contents[_PT] = __strictParseInt32(output[_PT]);
    }
    return contents;
};
const de_DBClusterMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBClusterMember(entry, context);
    });
};
const de_DBClusterMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBClusters === "") {
        contents[_DBCl] = [];
    }
    else if (output[_DBCl] != null && output[_DBCl][_DBC] != null) {
        contents[_DBCl] = de_DBClusterList(__getArrayIfSingleItem(output[_DBCl][_DBC]), context);
    }
    return contents;
};
const de_DBClusterNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBClusterParameterGroup = (output, context) => {
    const contents = {};
    if (output[_DBCPGN] != null) {
        contents[_DBCPGN] = __expectString(output[_DBCPGN]);
    }
    if (output[_DBPGF] != null) {
        contents[_DBPGF] = __expectString(output[_DBPGF]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_DBCPGA] != null) {
        contents[_DBCPGA] = __expectString(output[_DBCPGA]);
    }
    return contents;
};
const de_DBClusterParameterGroupDetails = (output, context) => {
    const contents = {};
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DBClusterParameterGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBClusterParameterGroup(entry, context);
    });
};
const de_DBClusterParameterGroupNameMessage = (output, context) => {
    const contents = {};
    if (output[_DBCPGN] != null) {
        contents[_DBCPGN] = __expectString(output[_DBCPGN]);
    }
    return contents;
};
const de_DBClusterParameterGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBClusterParameterGroupsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBClusterParameterGroups === "") {
        contents[_DBCPGl] = [];
    }
    else if (output[_DBCPGl] != null && output[_DBCPGl][_DBCPG] != null) {
        contents[_DBCPGl] = de_DBClusterParameterGroupList(__getArrayIfSingleItem(output[_DBCPGl][_DBCPG]), context);
    }
    return contents;
};
const de_DBClusterQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBClusterRole = (output, context) => {
    const contents = {};
    if (output[_RA] != null) {
        contents[_RA] = __expectString(output[_RA]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_DBClusterRoles = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBClusterRole(entry, context);
    });
};
const de_DBClusterSnapshot = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_AZv] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_AZv]), context);
    }
    if (output[_DBCSI] != null) {
        contents[_DBCSI] = __expectString(output[_DBCSI]);
    }
    if (output[_DBCI] != null) {
        contents[_DBCI] = __expectString(output[_DBCI]);
    }
    if (output[_SCT] != null) {
        contents[_SCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SCT]));
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_CCT] != null) {
        contents[_CCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCT]));
    }
    if (output[_MU] != null) {
        contents[_MU] = __expectString(output[_MU]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_STn] != null) {
        contents[_STn] = __expectString(output[_STn]);
    }
    if (output[_PP] != null) {
        contents[_PP] = __strictParseInt32(output[_PP]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_DBCSA] != null) {
        contents[_DBCSA] = __expectString(output[_DBCSA]);
    }
    if (output[_SDBCSA] != null) {
        contents[_SDBCSA] = __expectString(output[_SDBCSA]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    return contents;
};
const de_DBClusterSnapshotAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBClusterSnapshotAttribute = (output, context) => {
    const contents = {};
    if (output[_AN] != null) {
        contents[_AN] = __expectString(output[_AN]);
    }
    if (output.AttributeValues === "") {
        contents[_AVt] = [];
    }
    else if (output[_AVt] != null && output[_AVt][_AVtt] != null) {
        contents[_AVt] = de_AttributeValueList(__getArrayIfSingleItem(output[_AVt][_AVtt]), context);
    }
    return contents;
};
const de_DBClusterSnapshotAttributeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBClusterSnapshotAttribute(entry, context);
    });
};
const de_DBClusterSnapshotAttributesResult = (output, context) => {
    const contents = {};
    if (output[_DBCSI] != null) {
        contents[_DBCSI] = __expectString(output[_DBCSI]);
    }
    if (output.DBClusterSnapshotAttributes === "") {
        contents[_DBCSAl] = [];
    }
    else if (output[_DBCSAl] != null && output[_DBCSAl][_DBCSAlu] != null) {
        contents[_DBCSAl] = de_DBClusterSnapshotAttributeList(__getArrayIfSingleItem(output[_DBCSAl][_DBCSAlu]), context);
    }
    return contents;
};
const de_DBClusterSnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBClusterSnapshot(entry, context);
    });
};
const de_DBClusterSnapshotMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBClusterSnapshots === "") {
        contents[_DBCSl] = [];
    }
    else if (output[_DBCSl] != null && output[_DBCSl][_DBCS] != null) {
        contents[_DBCSl] = de_DBClusterSnapshotList(__getArrayIfSingleItem(output[_DBCSl][_DBCS]), context);
    }
    return contents;
};
const de_DBClusterSnapshotNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBEngineVersion = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_DBPGF] != null) {
        contents[_DBPGF] = __expectString(output[_DBPGF]);
    }
    if (output[_DBED] != null) {
        contents[_DBED] = __expectString(output[_DBED]);
    }
    if (output[_DBEVD] != null) {
        contents[_DBEVD] = __expectString(output[_DBEVD]);
    }
    if (output.ValidUpgradeTarget === "") {
        contents[_VUT] = [];
    }
    else if (output[_VUT] != null && output[_VUT][_UT] != null) {
        contents[_VUT] = de_ValidUpgradeTargetList(__getArrayIfSingleItem(output[_VUT][_UT]), context);
    }
    if (output.ExportableLogTypes === "") {
        contents[_ELTx] = [];
    }
    else if (output[_ELTx] != null && output[_ELTx][_me] != null) {
        contents[_ELTx] = de_LogTypeList(__getArrayIfSingleItem(output[_ELTx][_me]), context);
    }
    if (output[_SLETCL] != null) {
        contents[_SLETCL] = __parseBoolean(output[_SLETCL]);
    }
    if (output.SupportedCACertificateIdentifiers === "") {
        contents[_SCACI] = [];
    }
    else if (output[_SCACI] != null && output[_SCACI][_me] != null) {
        contents[_SCACI] = de_CACertificateIdentifiersList(__getArrayIfSingleItem(output[_SCACI][_me]), context);
    }
    if (output[_SCRWR] != null) {
        contents[_SCRWR] = __parseBoolean(output[_SCRWR]);
    }
    return contents;
};
const de_DBEngineVersionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBEngineVersion(entry, context);
    });
};
const de_DBEngineVersionMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBEngineVersions === "") {
        contents[_DBEV] = [];
    }
    else if (output[_DBEV] != null && output[_DBEV][_DBEVn] != null) {
        contents[_DBEV] = de_DBEngineVersionList(__getArrayIfSingleItem(output[_DBEV][_DBEVn]), context);
    }
    return contents;
};
const de_DBInstance = (output, context) => {
    const contents = {};
    if (output[_DBII] != null) {
        contents[_DBII] = __expectString(output[_DBII]);
    }
    if (output[_DBIC] != null) {
        contents[_DBIC] = __expectString(output[_DBIC]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_DBIS] != null) {
        contents[_DBIS] = __expectString(output[_DBIS]);
    }
    if (output[_End] != null) {
        contents[_End] = de_Endpoint(output[_End], context);
    }
    if (output[_ICT] != null) {
        contents[_ICT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ICT]));
    }
    if (output[_PBW] != null) {
        contents[_PBW] = __expectString(output[_PBW]);
    }
    if (output[_BRP] != null) {
        contents[_BRP] = __strictParseInt32(output[_BRP]);
    }
    if (output.VpcSecurityGroups === "") {
        contents[_VSG] = [];
    }
    else if (output[_VSG] != null && output[_VSG][_VSGM] != null) {
        contents[_VSG] = de_VpcSecurityGroupMembershipList(__getArrayIfSingleItem(output[_VSG][_VSGM]), context);
    }
    if (output[_AZv] != null) {
        contents[_AZv] = __expectString(output[_AZv]);
    }
    if (output[_DBSG] != null) {
        contents[_DBSG] = de_DBSubnetGroup(output[_DBSG], context);
    }
    if (output[_PMW] != null) {
        contents[_PMW] = __expectString(output[_PMW]);
    }
    if (output[_PMV] != null) {
        contents[_PMV] = de_PendingModifiedValues(output[_PMV], context);
    }
    if (output[_LRT] != null) {
        contents[_LRT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LRT]));
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_AMVU] != null) {
        contents[_AMVU] = __parseBoolean(output[_AMVU]);
    }
    if (output[_PA] != null) {
        contents[_PA] = __parseBoolean(output[_PA]);
    }
    if (output.StatusInfos === "") {
        contents[_SIt] = [];
    }
    else if (output[_SIt] != null && output[_SIt][_DBISI] != null) {
        contents[_SIt] = de_DBInstanceStatusInfoList(__getArrayIfSingleItem(output[_SIt][_DBISI]), context);
    }
    if (output[_DBCI] != null) {
        contents[_DBCI] = __expectString(output[_DBCI]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_DRI] != null) {
        contents[_DRI] = __expectString(output[_DRI]);
    }
    if (output[_CACI] != null) {
        contents[_CACI] = __expectString(output[_CACI]);
    }
    if (output[_CTTS] != null) {
        contents[_CTTS] = __parseBoolean(output[_CTTS]);
    }
    if (output[_PT] != null) {
        contents[_PT] = __strictParseInt32(output[_PT]);
    }
    if (output[_DBIA] != null) {
        contents[_DBIA] = __expectString(output[_DBIA]);
    }
    if (output.EnabledCloudwatchLogsExports === "") {
        contents[_ECLEn] = [];
    }
    else if (output[_ECLEn] != null && output[_ECLEn][_me] != null) {
        contents[_ECLEn] = de_LogTypeList(__getArrayIfSingleItem(output[_ECLEn][_me]), context);
    }
    if (output[_CD] != null) {
        contents[_CD] = de_CertificateDetails(output[_CD], context);
    }
    if (output[_PIE] != null) {
        contents[_PIE] = __parseBoolean(output[_PIE]);
    }
    if (output[_PIKMSKI] != null) {
        contents[_PIKMSKI] = __expectString(output[_PIKMSKI]);
    }
    return contents;
};
const de_DBInstanceAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBInstanceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBInstance(entry, context);
    });
};
const de_DBInstanceMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBInstances === "") {
        contents[_DBIn] = [];
    }
    else if (output[_DBIn] != null && output[_DBIn][_DBI] != null) {
        contents[_DBIn] = de_DBInstanceList(__getArrayIfSingleItem(output[_DBIn][_DBI]), context);
    }
    return contents;
};
const de_DBInstanceNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBInstanceStatusInfo = (output, context) => {
    const contents = {};
    if (output[_STta] != null) {
        contents[_STta] = __expectString(output[_STta]);
    }
    if (output[_No] != null) {
        contents[_No] = __parseBoolean(output[_No]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DBInstanceStatusInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBInstanceStatusInfo(entry, context);
    });
};
const de_DBParameterGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBParameterGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBParameterGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSecurityGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSnapshotAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSnapshotNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSubnetGroup = (output, context) => {
    const contents = {};
    if (output[_DBSGN] != null) {
        contents[_DBSGN] = __expectString(output[_DBSGN]);
    }
    if (output[_DBSGD] != null) {
        contents[_DBSGD] = __expectString(output[_DBSGD]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_SGS] != null) {
        contents[_SGS] = __expectString(output[_SGS]);
    }
    if (output.Subnets === "") {
        contents[_Su] = [];
    }
    else if (output[_Su] != null && output[_Su][_Sub] != null) {
        contents[_Su] = de_SubnetList(__getArrayIfSingleItem(output[_Su][_Sub]), context);
    }
    if (output[_DBSGA] != null) {
        contents[_DBSGA] = __expectString(output[_DBSGA]);
    }
    return contents;
};
const de_DBSubnetGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSubnetGroupDoesNotCoverEnoughAZs = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSubnetGroupMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.DBSubnetGroups === "") {
        contents[_DBSGu] = [];
    }
    else if (output[_DBSGu] != null && output[_DBSGu][_DBSG] != null) {
        contents[_DBSGu] = de_DBSubnetGroups(__getArrayIfSingleItem(output[_DBSGu][_DBSG]), context);
    }
    return contents;
};
const de_DBSubnetGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSubnetGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBSubnetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DBSubnetGroup(entry, context);
    });
};
const de_DBSubnetQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DBUpgradeDependencyFailureFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DeleteDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_DeleteDBClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_DBCS] != null) {
        contents[_DBCS] = de_DBClusterSnapshot(output[_DBCS], context);
    }
    return contents;
};
const de_DeleteDBInstanceResult = (output, context) => {
    const contents = {};
    if (output[_DBI] != null) {
        contents[_DBI] = de_DBInstance(output[_DBI], context);
    }
    return contents;
};
const de_DeleteEventSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_DeleteGlobalClusterResult = (output, context) => {
    const contents = {};
    if (output[_GC] != null) {
        contents[_GC] = de_GlobalCluster(output[_GC], context);
    }
    return contents;
};
const de_DescribeDBClusterSnapshotAttributesResult = (output, context) => {
    const contents = {};
    if (output[_DBCSAR] != null) {
        contents[_DBCSAR] = de_DBClusterSnapshotAttributesResult(output[_DBCSAR], context);
    }
    return contents;
};
const de_DescribeEngineDefaultClusterParametersResult = (output, context) => {
    const contents = {};
    if (output[_ED] != null) {
        contents[_ED] = de_EngineDefaults(output[_ED], context);
    }
    return contents;
};
const de_Endpoint = (output, context) => {
    const contents = {};
    if (output[_Ad] != null) {
        contents[_Ad] = __expectString(output[_Ad]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_HZI] != null) {
        contents[_HZI] = __expectString(output[_HZI]);
    }
    return contents;
};
const de_EngineDefaults = (output, context) => {
    const contents = {};
    if (output[_DBPGF] != null) {
        contents[_DBPGF] = __expectString(output[_DBPGF]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    return contents;
};
const de_Event = (output, context) => {
    const contents = {};
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_STo] != null) {
        contents[_STo] = __expectString(output[_STo]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output.EventCategories === "") {
        contents[_EC] = [];
    }
    else if (output[_EC] != null && output[_EC][_ECv] != null) {
        contents[_EC] = de_EventCategoriesList(__getArrayIfSingleItem(output[_EC][_ECv]), context);
    }
    if (output[_Da] != null) {
        contents[_Da] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Da]));
    }
    if (output[_SA] != null) {
        contents[_SA] = __expectString(output[_SA]);
    }
    return contents;
};
const de_EventCategoriesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_EventCategoriesMap = (output, context) => {
    const contents = {};
    if (output[_STo] != null) {
        contents[_STo] = __expectString(output[_STo]);
    }
    if (output.EventCategories === "") {
        contents[_EC] = [];
    }
    else if (output[_EC] != null && output[_EC][_ECv] != null) {
        contents[_EC] = de_EventCategoriesList(__getArrayIfSingleItem(output[_EC][_ECv]), context);
    }
    return contents;
};
const de_EventCategoriesMapList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventCategoriesMap(entry, context);
    });
};
const de_EventCategoriesMessage = (output, context) => {
    const contents = {};
    if (output.EventCategoriesMapList === "") {
        contents[_ECML] = [];
    }
    else if (output[_ECML] != null && output[_ECML][_ECM] != null) {
        contents[_ECML] = de_EventCategoriesMapList(__getArrayIfSingleItem(output[_ECML][_ECM]), context);
    }
    return contents;
};
const de_EventList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Event(entry, context);
    });
};
const de_EventsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Events === "") {
        contents[_Ev] = [];
    }
    else if (output[_Ev] != null && output[_Ev][_Eve] != null) {
        contents[_Ev] = de_EventList(__getArrayIfSingleItem(output[_Ev][_Eve]), context);
    }
    return contents;
};
const de_EventSubscription = (output, context) => {
    const contents = {};
    if (output[_CAIu] != null) {
        contents[_CAIu] = __expectString(output[_CAIu]);
    }
    if (output[_CSI] != null) {
        contents[_CSI] = __expectString(output[_CSI]);
    }
    if (output[_STA] != null) {
        contents[_STA] = __expectString(output[_STA]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SCTu] != null) {
        contents[_SCTu] = __expectString(output[_SCTu]);
    }
    if (output[_STo] != null) {
        contents[_STo] = __expectString(output[_STo]);
    }
    if (output.SourceIdsList === "") {
        contents[_SIL] = [];
    }
    else if (output[_SIL] != null && output[_SIL][_SIou] != null) {
        contents[_SIL] = de_SourceIdsList(__getArrayIfSingleItem(output[_SIL][_SIou]), context);
    }
    if (output.EventCategoriesList === "") {
        contents[_ECL] = [];
    }
    else if (output[_ECL] != null && output[_ECL][_ECv] != null) {
        contents[_ECL] = de_EventCategoriesList(__getArrayIfSingleItem(output[_ECL][_ECv]), context);
    }
    if (output[_En] != null) {
        contents[_En] = __parseBoolean(output[_En]);
    }
    if (output[_ESA] != null) {
        contents[_ESA] = __expectString(output[_ESA]);
    }
    return contents;
};
const de_EventSubscriptionQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EventSubscriptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventSubscription(entry, context);
    });
};
const de_EventSubscriptionsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.EventSubscriptionsList === "") {
        contents[_ESL] = [];
    }
    else if (output[_ESL] != null && output[_ESL][_ES] != null) {
        contents[_ESL] = de_EventSubscriptionsList(__getArrayIfSingleItem(output[_ESL][_ES]), context);
    }
    return contents;
};
const de_FailoverDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_GlobalCluster = (output, context) => {
    const contents = {};
    if (output[_GCI] != null) {
        contents[_GCI] = __expectString(output[_GCI]);
    }
    if (output[_GCRI] != null) {
        contents[_GCRI] = __expectString(output[_GCRI]);
    }
    if (output[_GCA] != null) {
        contents[_GCA] = __expectString(output[_GCA]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_DN] != null) {
        contents[_DN] = __expectString(output[_DN]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_DP] != null) {
        contents[_DP] = __parseBoolean(output[_DP]);
    }
    if (output.GlobalClusterMembers === "") {
        contents[_GCM] = [];
    }
    else if (output[_GCM] != null && output[_GCM][_GCMl] != null) {
        contents[_GCM] = de_GlobalClusterMemberList(__getArrayIfSingleItem(output[_GCM][_GCMl]), context);
    }
    return contents;
};
const de_GlobalClusterAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_GlobalClusterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalCluster(entry, context);
    });
};
const de_GlobalClusterMember = (output, context) => {
    const contents = {};
    if (output[_DBCA] != null) {
        contents[_DBCA] = __expectString(output[_DBCA]);
    }
    if (output.Readers === "") {
        contents[_R] = [];
    }
    else if (output[_R] != null && output[_R][_me] != null) {
        contents[_R] = de_ReadersArnList(__getArrayIfSingleItem(output[_R][_me]), context);
    }
    if (output[_IW] != null) {
        contents[_IW] = __parseBoolean(output[_IW]);
    }
    return contents;
};
const de_GlobalClusterMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GlobalClusterMember(entry, context);
    });
};
const de_GlobalClusterNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_GlobalClusterQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_GlobalClustersMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.GlobalClusters === "") {
        contents[_GCl] = [];
    }
    else if (output[_GCl] != null && output[_GCl][_GCMl] != null) {
        contents[_GCl] = de_GlobalClusterList(__getArrayIfSingleItem(output[_GCl][_GCMl]), context);
    }
    return contents;
};
const de_InstanceQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InsufficientDBClusterCapacityFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InsufficientDBInstanceCapacityFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InsufficientStorageClusterCapacityFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBClusterSnapshotStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBClusterStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBInstanceStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBParameterGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBSecurityGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBSnapshotStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBSubnetGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDBSubnetStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidEventSubscriptionStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidGlobalClusterStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidRestoreFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidSubnet = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidVPCNetworkStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_KMSKeyNotAccessibleFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_LogTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ModifyDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_ModifyDBClusterSnapshotAttributeResult = (output, context) => {
    const contents = {};
    if (output[_DBCSAR] != null) {
        contents[_DBCSAR] = de_DBClusterSnapshotAttributesResult(output[_DBCSAR], context);
    }
    return contents;
};
const de_ModifyDBInstanceResult = (output, context) => {
    const contents = {};
    if (output[_DBI] != null) {
        contents[_DBI] = de_DBInstance(output[_DBI], context);
    }
    return contents;
};
const de_ModifyDBSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_DBSG] != null) {
        contents[_DBSG] = de_DBSubnetGroup(output[_DBSG], context);
    }
    return contents;
};
const de_ModifyEventSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_ModifyGlobalClusterResult = (output, context) => {
    const contents = {};
    if (output[_GC] != null) {
        contents[_GC] = de_GlobalCluster(output[_GC], context);
    }
    return contents;
};
const de_OrderableDBInstanceOption = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_DBIC] != null) {
        contents[_DBIC] = __expectString(output[_DBIC]);
    }
    if (output[_LM] != null) {
        contents[_LM] = __expectString(output[_LM]);
    }
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_AZv] != null) {
        contents[_AZ] = de_AvailabilityZoneList(__getArrayIfSingleItem(output[_AZ][_AZv]), context);
    }
    if (output[_Vp] != null) {
        contents[_Vp] = __parseBoolean(output[_Vp]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    return contents;
};
const de_OrderableDBInstanceOptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OrderableDBInstanceOption(entry, context);
    });
};
const de_OrderableDBInstanceOptionsMessage = (output, context) => {
    const contents = {};
    if (output.OrderableDBInstanceOptions === "") {
        contents[_ODBIO] = [];
    }
    else if (output[_ODBIO] != null && output[_ODBIO][_ODBIOr] != null) {
        contents[_ODBIO] = de_OrderableDBInstanceOptionsList(__getArrayIfSingleItem(output[_ODBIO][_ODBIOr]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_Parameter = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PV] != null) {
        contents[_PV] = __expectString(output[_PV]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_AT] != null) {
        contents[_AT] = __expectString(output[_AT]);
    }
    if (output[_DT] != null) {
        contents[_DT] = __expectString(output[_DT]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __expectString(output[_AV]);
    }
    if (output[_IM] != null) {
        contents[_IM] = __parseBoolean(output[_IM]);
    }
    if (output[_MEV] != null) {
        contents[_MEV] = __expectString(output[_MEV]);
    }
    if (output[_AM] != null) {
        contents[_AM] = __expectString(output[_AM]);
    }
    return contents;
};
const de_ParametersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Parameter(entry, context);
    });
};
const de_PendingCloudwatchLogsExports = (output, context) => {
    const contents = {};
    if (output.LogTypesToEnable === "") {
        contents[_LTTE] = [];
    }
    else if (output[_LTTE] != null && output[_LTTE][_me] != null) {
        contents[_LTTE] = de_LogTypeList(__getArrayIfSingleItem(output[_LTTE][_me]), context);
    }
    if (output.LogTypesToDisable === "") {
        contents[_LTTD] = [];
    }
    else if (output[_LTTD] != null && output[_LTTD][_me] != null) {
        contents[_LTTD] = de_LogTypeList(__getArrayIfSingleItem(output[_LTTD][_me]), context);
    }
    return contents;
};
const de_PendingMaintenanceAction = (output, context) => {
    const contents = {};
    if (output[_A] != null) {
        contents[_A] = __expectString(output[_A]);
    }
    if (output[_AAAD] != null) {
        contents[_AAAD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_AAAD]));
    }
    if (output[_FAD] != null) {
        contents[_FAD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_FAD]));
    }
    if (output[_OIS] != null) {
        contents[_OIS] = __expectString(output[_OIS]);
    }
    if (output[_CAD] != null) {
        contents[_CAD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CAD]));
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_PendingMaintenanceActionDetails = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PendingMaintenanceAction(entry, context);
    });
};
const de_PendingMaintenanceActions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourcePendingMaintenanceActions(entry, context);
    });
};
const de_PendingMaintenanceActionsMessage = (output, context) => {
    const contents = {};
    if (output.PendingMaintenanceActions === "") {
        contents[_PMA] = [];
    }
    else if (output[_PMA] != null && output[_PMA][_RPMA] != null) {
        contents[_PMA] = de_PendingMaintenanceActions(__getArrayIfSingleItem(output[_PMA][_RPMA]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_PendingModifiedValues = (output, context) => {
    const contents = {};
    if (output[_DBIC] != null) {
        contents[_DBIC] = __expectString(output[_DBIC]);
    }
    if (output[_AS] != null) {
        contents[_AS] = __strictParseInt32(output[_AS]);
    }
    if (output[_MUP] != null) {
        contents[_MUP] = __expectString(output[_MUP]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_BRP] != null) {
        contents[_BRP] = __strictParseInt32(output[_BRP]);
    }
    if (output[_MAZ] != null) {
        contents[_MAZ] = __parseBoolean(output[_MAZ]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_LM] != null) {
        contents[_LM] = __expectString(output[_LM]);
    }
    if (output[_I] != null) {
        contents[_I] = __strictParseInt32(output[_I]);
    }
    if (output[_DBII] != null) {
        contents[_DBII] = __expectString(output[_DBII]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output[_CACI] != null) {
        contents[_CACI] = __expectString(output[_CACI]);
    }
    if (output[_DBSGN] != null) {
        contents[_DBSGN] = __expectString(output[_DBSGN]);
    }
    if (output[_PCLE] != null) {
        contents[_PCLE] = de_PendingCloudwatchLogsExports(output[_PCLE], context);
    }
    return contents;
};
const de_ReadersArnList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ReadReplicaIdentifierList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_RebootDBInstanceResult = (output, context) => {
    const contents = {};
    if (output[_DBI] != null) {
        contents[_DBI] = de_DBInstance(output[_DBI], context);
    }
    return contents;
};
const de_RemoveFromGlobalClusterResult = (output, context) => {
    const contents = {};
    if (output[_GC] != null) {
        contents[_GC] = de_GlobalCluster(output[_GC], context);
    }
    return contents;
};
const de_RemoveSourceIdentifierFromSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_ResourceNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ResourcePendingMaintenanceActions = (output, context) => {
    const contents = {};
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    if (output.PendingMaintenanceActionDetails === "") {
        contents[_PMAD] = [];
    }
    else if (output[_PMAD] != null && output[_PMAD][_PMAe] != null) {
        contents[_PMAD] = de_PendingMaintenanceActionDetails(__getArrayIfSingleItem(output[_PMAD][_PMAe]), context);
    }
    return contents;
};
const de_RestoreDBClusterFromSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_RestoreDBClusterToPointInTimeResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_SharedSnapshotQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSInvalidTopicFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSNoAuthorizationFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSTopicArnNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SourceIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SourceNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_StartDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_StopDBClusterResult = (output, context) => {
    const contents = {};
    if (output[_DBC] != null) {
        contents[_DBC] = de_DBCluster(output[_DBC], context);
    }
    return contents;
};
const de_StorageQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_StorageTypeNotSupportedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_Subnet = (output, context) => {
    const contents = {};
    if (output[_SIub] != null) {
        contents[_SIub] = __expectString(output[_SIub]);
    }
    if (output[_SAZ] != null) {
        contents[_SAZ] = de_AvailabilityZone(output[_SAZ], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = __expectString(output[_SS]);
    }
    return contents;
};
const de_SubnetAlreadyInUse = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubnetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Subnet(entry, context);
    });
};
const de_SubscriptionAlreadyExistFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionCategoryNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TagListMessage = (output, context) => {
    const contents = {};
    if (output.TagList === "") {
        contents[_TL] = [];
    }
    else if (output[_TL] != null && output[_TL][_Ta] != null) {
        contents[_TL] = de_TagList(__getArrayIfSingleItem(output[_TL][_Ta]), context);
    }
    return contents;
};
const de_UpgradeTarget = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_AU] != null) {
        contents[_AU] = __parseBoolean(output[_AU]);
    }
    if (output[_IMVU] != null) {
        contents[_IMVU] = __parseBoolean(output[_IMVU]);
    }
    return contents;
};
const de_ValidUpgradeTargetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UpgradeTarget(entry, context);
    });
};
const de_VpcSecurityGroupMembership = (output, context) => {
    const contents = {};
    if (output[_VSGIp] != null) {
        contents[_VSGIp] = __expectString(output[_VSGIp]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_VpcSecurityGroupMembershipList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcSecurityGroupMembership(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2014-10-31";
const _A = "Action";
const _AA = "ApplyAction";
const _AAAD = "AutoAppliedAfterDate";
const _AI = "ApplyImmediately";
const _AM = "ApplyMethod";
const _AMVU = "AutoMinorVersionUpgrade";
const _AMVUl = "AllowMajorVersionUpgrade";
const _AN = "AttributeName";
const _APMA = "ApplyPendingMaintenanceAction";
const _AR = "AssociatedRoles";
const _AS = "AllocatedStorage";
const _ASITS = "AddSourceIdentifierToSubscription";
const _AT = "ApplyType";
const _ATTR = "AddTagsToResource";
const _AU = "AutoUpgrade";
const _AV = "AllowedValues";
const _AVt = "AttributeValues";
const _AVtt = "AttributeValue";
const _AZ = "AvailabilityZones";
const _AZv = "AvailabilityZone";
const _Ad = "Address";
const _BRP = "BackupRetentionPeriod";
const _C = "Certificates";
const _CA = "CertificateArn";
const _CACI = "CACertificateIdentifier";
const _CAD = "CurrentApplyDate";
const _CAI = "CAIdentifier";
const _CAIu = "CustomerAwsId";
const _CCT = "ClusterCreateTime";
const _CD = "CertificateDetails";
const _CDBC = "CreateDBCluster";
const _CDBCPG = "CopyDBClusterParameterGroup";
const _CDBCPGr = "CreateDBClusterParameterGroup";
const _CDBCS = "CopyDBClusterSnapshot";
const _CDBCSr = "CreateDBClusterSnapshot";
const _CDBI = "CreateDBInstance";
const _CDBSG = "CreateDBSubnetGroup";
const _CES = "CreateEventSubscription";
const _CGC = "CreateGlobalCluster";
const _CGI = "CloneGroupId";
const _CI = "CertificateIdentifier";
const _CLEC = "CloudwatchLogsExportConfiguration";
const _CRR = "CertificateRotationRestart";
const _CSI = "CustSubscriptionId";
const _CT = "CopyTags";
const _CTTS = "CopyTagsToSnapshot";
const _CTe = "CertificateType";
const _Ce = "Certificate";
const _D = "Description";
const _DBC = "DBCluster";
const _DBCA = "DBClusterArn";
const _DBCI = "DBClusterIdentifier";
const _DBCM = "DBClusterMembers";
const _DBCMl = "DBClusterMember";
const _DBCPG = "DBClusterParameterGroup";
const _DBCPGA = "DBClusterParameterGroupArn";
const _DBCPGN = "DBClusterParameterGroupName";
const _DBCPGS = "DBClusterParameterGroupStatus";
const _DBCPGl = "DBClusterParameterGroups";
const _DBCR = "DBClusterRole";
const _DBCS = "DBClusterSnapshot";
const _DBCSA = "DBClusterSnapshotArn";
const _DBCSAR = "DBClusterSnapshotAttributesResult";
const _DBCSAl = "DBClusterSnapshotAttributes";
const _DBCSAlu = "DBClusterSnapshotAttribute";
const _DBCSI = "DBClusterSnapshotIdentifier";
const _DBCSl = "DBClusterSnapshots";
const _DBCl = "DBClusters";
const _DBED = "DBEngineDescription";
const _DBEV = "DBEngineVersions";
const _DBEVD = "DBEngineVersionDescription";
const _DBEVn = "DBEngineVersion";
const _DBI = "DBInstance";
const _DBIA = "DBInstanceArn";
const _DBIC = "DBInstanceClass";
const _DBII = "DBInstanceIdentifier";
const _DBIS = "DBInstanceStatus";
const _DBISI = "DBInstanceStatusInfo";
const _DBIn = "DBInstances";
const _DBPGF = "DBParameterGroupFamily";
const _DBSG = "DBSubnetGroup";
const _DBSGA = "DBSubnetGroupArn";
const _DBSGD = "DBSubnetGroupDescription";
const _DBSGN = "DBSubnetGroupName";
const _DBSGu = "DBSubnetGroups";
const _DC = "DescribeCertificates";
const _DCI = "DbClusterIdentifier";
const _DCRI = "DbClusterResourceId";
const _DDBC = "DeleteDBCluster";
const _DDBCP = "DescribeDBClusterParameters";
const _DDBCPG = "DeleteDBClusterParameterGroup";
const _DDBCPGe = "DescribeDBClusterParameterGroups";
const _DDBCS = "DeleteDBClusterSnapshot";
const _DDBCSA = "DescribeDBClusterSnapshotAttributes";
const _DDBCSe = "DescribeDBClusterSnapshots";
const _DDBCe = "DescribeDBClusters";
const _DDBEV = "DescribeDBEngineVersions";
const _DDBI = "DeleteDBInstance";
const _DDBIe = "DescribeDBInstances";
const _DDBSG = "DeleteDBSubnetGroup";
const _DDBSGe = "DescribeDBSubnetGroups";
const _DE = "DescribeEvents";
const _DEC = "DescribeEventCategories";
const _DEDCP = "DescribeEngineDefaultClusterParameters";
const _DES = "DeleteEventSubscription";
const _DESe = "DescribeEventSubscriptions";
const _DGC = "DeleteGlobalCluster";
const _DGCe = "DescribeGlobalClusters";
const _DLT = "DisableLogTypes";
const _DN = "DatabaseName";
const _DO = "DefaultOnly";
const _DODBIO = "DescribeOrderableDBInstanceOptions";
const _DP = "DeletionProtection";
const _DPMA = "DescribePendingMaintenanceActions";
const _DRI = "DbiResourceId";
const _DT = "DataType";
const _Da = "Date";
const _Du = "Duration";
const _E = "Engine";
const _EC = "EventCategories";
const _ECL = "EventCategoriesList";
const _ECLE = "EnableCloudwatchLogsExports";
const _ECLEn = "EnabledCloudwatchLogsExports";
const _ECM = "EventCategoriesMap";
const _ECML = "EventCategoriesMapList";
const _ECv = "EventCategory";
const _ED = "EngineDefaults";
const _ELT = "EnableLogTypes";
const _ELTx = "ExportableLogTypes";
const _EPI = "EnablePerformanceInsights";
const _ERT = "EarliestRestorableTime";
const _ES = "EventSubscription";
const _ESA = "EventSubscriptionArn";
const _ESL = "EventSubscriptionsList";
const _ET = "EndTime";
const _EV = "EngineVersion";
const _En = "Enabled";
const _End = "Endpoint";
const _Ev = "Events";
const _Eve = "Event";
const _F = "Filters";
const _FAD = "ForcedApplyDate";
const _FDBC = "FailoverDBCluster";
const _FDBSI = "FinalDBSnapshotIdentifier";
const _FF = "ForceFailover";
const _GC = "GlobalCluster";
const _GCA = "GlobalClusterArn";
const _GCI = "GlobalClusterIdentifier";
const _GCM = "GlobalClusterMembers";
const _GCMl = "GlobalClusterMember";
const _GCRI = "GlobalClusterResourceId";
const _GCl = "GlobalClusters";
const _HZI = "HostedZoneId";
const _I = "Iops";
const _ICT = "InstanceCreateTime";
const _ICW = "IsClusterWriter";
const _IM = "IsModifiable";
const _IMVU = "IsMajorVersionUpgrade";
const _IP = "IncludePublic";
const _IS = "IncludeShared";
const _IW = "IsWriter";
const _K = "Key";
const _KKI = "KmsKeyId";
const _LM = "LicenseModel";
const _LRT = "LatestRestorableTime";
const _LSCS = "ListSupportedCharacterSets";
const _LST = "ListSupportedTimezones";
const _LTFR = "ListTagsForResource";
const _LTTD = "LogTypesToDisable";
const _LTTE = "LogTypesToEnable";
const _M = "Marker";
const _MAZ = "MultiAZ";
const _MDBC = "ModifyDBCluster";
const _MDBCPG = "ModifyDBClusterParameterGroup";
const _MDBCSA = "ModifyDBClusterSnapshotAttribute";
const _MDBI = "ModifyDBInstance";
const _MDBSG = "ModifyDBSubnetGroup";
const _MES = "ModifyEventSubscription";
const _MEV = "MinimumEngineVersion";
const _MGC = "ModifyGlobalCluster";
const _MR = "MaxRecords";
const _MU = "MasterUsername";
const _MUP = "MasterUserPassword";
const _Me = "Message";
const _N = "Name";
const _NDBCI = "NewDBClusterIdentifier";
const _NDBII = "NewDBInstanceIdentifier";
const _NGCI = "NewGlobalClusterIdentifier";
const _No = "Normal";
const _ODBIO = "OrderableDBInstanceOptions";
const _ODBIOr = "OrderableDBInstanceOption";
const _OIS = "OptInStatus";
const _OIT = "OptInType";
const _P = "Port";
const _PA = "PubliclyAccessible";
const _PBW = "PreferredBackupWindow";
const _PCLE = "PendingCloudwatchLogsExports";
const _PIE = "PerformanceInsightsEnabled";
const _PIKMSKI = "PerformanceInsightsKMSKeyId";
const _PMA = "PendingMaintenanceActions";
const _PMAD = "PendingMaintenanceActionDetails";
const _PMAe = "PendingMaintenanceAction";
const _PMV = "PendingModifiedValues";
const _PMW = "PreferredMaintenanceWindow";
const _PN = "ParameterName";
const _PP = "PercentProgress";
const _PSU = "PreSignedUrl";
const _PT = "PromotionTier";
const _PV = "ParameterValue";
const _Pa = "Parameters";
const _Par = "Parameter";
const _R = "Readers";
const _RA = "RoleArn";
const _RAP = "ResetAllParameters";
const _RDBCFS = "RestoreDBClusterFromSnapshot";
const _RDBCPG = "ResetDBClusterParameterGroup";
const _RDBCTPIT = "RestoreDBClusterToPointInTime";
const _RDBI = "RebootDBInstance";
const _RE = "ReaderEndpoint";
const _RFGC = "RemoveFromGlobalCluster";
const _RI = "ResourceIdentifier";
const _RN = "ResourceName";
const _RPMA = "ResourcePendingMaintenanceActions";
const _RRI = "ReadReplicaIdentifiers";
const _RRIe = "ReadReplicaIdentifier";
const _RSI = "ReplicationSourceIdentifier";
const _RSIFS = "RemoveSourceIdentifierFromSubscription";
const _RT = "RestoreType";
const _RTFR = "RemoveTagsFromResource";
const _RTT = "RestoreToTime";
const _S = "Source";
const _SA = "SourceArn";
const _SAZ = "SubnetAvailabilityZone";
const _SCACI = "SupportedCACertificateIdentifiers";
const _SCRWR = "SupportsCertificateRotationWithoutRestart";
const _SCT = "SnapshotCreateTime";
const _SCTu = "SubscriptionCreationTime";
const _SDBC = "StartDBCluster";
const _SDBCI = "SourceDBClusterIdentifier";
const _SDBCPGI = "SourceDBClusterParameterGroupIdentifier";
const _SDBCSA = "SourceDBClusterSnapshotArn";
const _SDBCSI = "SourceDBClusterSnapshotIdentifier";
const _SDBCt = "StopDBCluster";
const _SE = "StorageEncrypted";
const _SFS = "SkipFinalSnapshot";
const _SGS = "SubnetGroupStatus";
const _SI = "SourceIdentifier";
const _SIL = "SourceIdsList";
const _SIn = "SnapshotIdentifier";
const _SIo = "SourceIds";
const _SIou = "SourceId";
const _SIt = "StatusInfos";
const _SIu = "SubnetIds";
const _SIub = "SubnetIdentifier";
const _SLETCL = "SupportsLogExportsToCloudwatchLogs";
const _SN = "SubscriptionName";
const _SS = "SubnetStatus";
const _ST = "StorageType";
const _STA = "SnsTopicArn";
const _STn = "SnapshotType";
const _STo = "SourceType";
const _STt = "StartTime";
const _STta = "StatusType";
const _St = "Status";
const _Su = "Subnets";
const _Sub = "Subnet";
const _T = "Tags";
const _TDBCPGD = "TargetDBClusterParameterGroupDescription";
const _TDBCPGI = "TargetDBClusterParameterGroupIdentifier";
const _TDBCSI = "TargetDBClusterSnapshotIdentifier";
const _TDBII = "TargetDBInstanceIdentifier";
const _TK = "TagKeys";
const _TL = "TagList";
const _Ta = "Tag";
const _Th = "Thumbprint";
const _ULRT = "UseLatestRestorableTime";
const _UT = "UpgradeTarget";
const _V = "Version";
const _VF = "ValidFrom";
const _VI = "VpcId";
const _VSG = "VpcSecurityGroups";
const _VSGI = "VpcSecurityGroupIds";
const _VSGIp = "VpcSecurityGroupId";
const _VSGM = "VpcSecurityGroupMembership";
const _VT = "ValidTill";
const _VTA = "ValuesToAdd";
const _VTR = "ValuesToRemove";
const _VUT = "ValidUpgradeTarget";
const _Va = "Values";
const _Val = "Value";
const _Vp = "Vpc";
const _m = "message";
const _me = "member";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
