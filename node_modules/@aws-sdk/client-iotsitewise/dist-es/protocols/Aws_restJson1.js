import { requestBuilder as rb } from "@smithy/core";
import { isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { IoTSiteWiseServiceException as __BaseException } from "../models/IoTSiteWiseServiceException";
import { AccessDeniedException, ConflictingOperationException, InternalFailureException, InvalidRequestException, LimitExceededException, QueryTimeoutException, ResourceAlreadyExistsException, ResourceNotFoundException, ServiceUnavailableException, ThrottlingException, UnauthorizedException, ValidationException, } from "../models/models_0";
import { TooManyTagsException } from "../models/models_1";
export const se_AssociateAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets/{assetId}/associate");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        childAssetId: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        hierarchyId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AssociateTimeSeriesToAssetPropertyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/timeseries/associate");
    const query = map({
        [_a]: [, __expectNonNull(input[_a], `alias`)],
        [_aI]: [, __expectNonNull(input[_aI], `assetId`)],
        [_pI]: [, __expectNonNull(input[_pI], `propertyId`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_BatchAssociateProjectAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{projectId}/assets/associate");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetIds: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchDisassociateProjectAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{projectId}/assets/disassociate");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetIds: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchGetAssetPropertyAggregatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/properties/batch/aggregates");
    let body;
    body = JSON.stringify(take(input, {
        entries: (_) => se_BatchGetAssetPropertyAggregatesEntries(_, context),
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchGetAssetPropertyValueCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/properties/batch/latest");
    let body;
    body = JSON.stringify(take(input, {
        entries: (_) => _json(_),
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchGetAssetPropertyValueHistoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/properties/batch/history");
    let body;
    body = JSON.stringify(take(input, {
        entries: (_) => se_BatchGetAssetPropertyValueHistoryEntries(_, context),
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchPutAssetPropertyValueCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/properties");
    let body;
    body = JSON.stringify(take(input, {
        entries: (_) => se_PutAssetPropertyValueEntries(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/access-policies");
    let body;
    body = JSON.stringify(take(input, {
        accessPolicyIdentity: (_) => _json(_),
        accessPolicyPermission: [],
        accessPolicyResource: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets");
    let body;
    body = JSON.stringify(take(input, {
        assetDescription: [],
        assetExternalId: [],
        assetId: [],
        assetModelId: [],
        assetName: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAssetModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/asset-models");
    let body;
    body = JSON.stringify(take(input, {
        assetModelCompositeModels: (_) => se_AssetModelCompositeModelDefinitions(_, context),
        assetModelDescription: [],
        assetModelExternalId: [],
        assetModelHierarchies: (_) => _json(_),
        assetModelId: [],
        assetModelName: [],
        assetModelProperties: (_) => _json(_),
        assetModelType: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAssetModelCompositeModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/asset-models/{assetModelId}/composite-models");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetModelCompositeModelDescription: [],
        assetModelCompositeModelExternalId: [],
        assetModelCompositeModelId: [],
        assetModelCompositeModelName: [],
        assetModelCompositeModelProperties: (_) => _json(_),
        assetModelCompositeModelType: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        composedAssetModelId: [],
        parentAssetModelCompositeModelId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateBulkImportJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/jobs");
    let body;
    body = JSON.stringify(take(input, {
        adaptiveIngestion: [],
        deleteFilesAfterImport: [],
        errorReportLocation: (_) => _json(_),
        files: (_) => _json(_),
        jobConfiguration: (_) => _json(_),
        jobName: [],
        jobRoleArn: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDashboardCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dashboards");
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        dashboardDefinition: [],
        dashboardDescription: [],
        dashboardName: [],
        projectId: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/20200301/gateways");
    let body;
    body = JSON.stringify(take(input, {
        gatewayName: [],
        gatewayPlatform: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePortalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/portals");
    let body;
    body = JSON.stringify(take(input, {
        alarms: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        notificationSenderEmail: [],
        portalAuthMode: [],
        portalContactEmail: [],
        portalDescription: [],
        portalLogoImageFile: (_) => se_ImageFile(_, context),
        portalName: [],
        roleArn: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects");
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        portalId: [],
        projectDescription: [],
        projectName: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/access-policies/{accessPolicyId}");
    b.p("accessPolicyId", () => input.accessPolicyId, "{accessPolicyId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteAssetModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteAssetModelCompositeModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}/composite-models/{assetModelCompositeModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    b.p("assetModelCompositeModelId", () => input.assetModelCompositeModelId, "{assetModelCompositeModelId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteDashboardCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dashboards/{dashboardId}");
    b.p("dashboardId", () => input.dashboardId, "{dashboardId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/20200301/gateways/{gatewayId}");
    b.p("gatewayId", () => input.gatewayId, "{gatewayId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeletePortalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/portals/{portalId}");
    b.p("portalId", () => input.portalId, "{portalId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{projectId}");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteTimeSeriesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/timeseries/delete");
    const query = map({
        [_a]: [, input[_a]],
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/access-policies/{accessPolicyId}");
    b.p("accessPolicyId", () => input.accessPolicyId, "{accessPolicyId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/actions/{actionId}");
    b.p("actionId", () => input.actionId, "{actionId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    const query = map({
        [_eP]: [() => input.excludeProperties !== void 0, () => input[_eP].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeAssetCompositeModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}/composite-models/{assetCompositeModelId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    b.p("assetCompositeModelId", () => input.assetCompositeModelId, "{assetCompositeModelId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAssetModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    const query = map({
        [_eP]: [() => input.excludeProperties !== void 0, () => input[_eP].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeAssetModelCompositeModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}/composite-models/{assetModelCompositeModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    b.p("assetModelCompositeModelId", () => input.assetModelCompositeModelId, "{assetModelCompositeModelId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAssetPropertyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}/properties/{propertyId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    b.p("propertyId", () => input.propertyId, "{propertyId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBulkImportJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDashboardCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dashboards/{dashboardId}");
    b.p("dashboardId", () => input.dashboardId, "{dashboardId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDefaultEncryptionConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/configuration/account/encryption");
    let body;
    body = "";
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/20200301/gateways/{gatewayId}");
    b.p("gatewayId", () => input.gatewayId, "{gatewayId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeGatewayCapabilityConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/20200301/gateways/{gatewayId}/capability/{capabilityNamespace}");
    b.p("gatewayId", () => input.gatewayId, "{gatewayId}", false);
    b.p("capabilityNamespace", () => input.capabilityNamespace, "{capabilityNamespace}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeLoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/logging");
    let body;
    body = "";
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribePortalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/portals/{portalId}");
    b.p("portalId", () => input.portalId, "{portalId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{projectId}");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeStorageConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/configuration/account/storage");
    let body;
    body = "";
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeTimeSeriesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/timeseries/describe");
    const query = map({
        [_a]: [, input[_a]],
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DisassociateAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets/{assetId}/disassociate");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        childAssetId: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        hierarchyId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DisassociateTimeSeriesFromAssetPropertyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/timeseries/disassociate");
    const query = map({
        [_a]: [, __expectNonNull(input[_a], `alias`)],
        [_aI]: [, __expectNonNull(input[_aI], `assetId`)],
        [_pI]: [, __expectNonNull(input[_pI], `propertyId`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ExecuteActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/actions");
    let body;
    body = JSON.stringify(take(input, {
        actionDefinitionId: [],
        actionPayload: (_) => _json(_),
        clientToken: [],
        targetResource: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ExecuteQueryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/queries/execution");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        queryStatement: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetAssetPropertyAggregatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/properties/aggregates");
    const query = map({
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
        [_pA]: [, input[_pA]],
        [_aT]: [
            __expectNonNull(input.aggregateTypes, `aggregateTypes`) != null,
            () => (input[_aT] || []).map((_entry) => _entry),
        ],
        [_r]: [, __expectNonNull(input[_r], `resolution`)],
        [_q]: [() => input.qualities !== void 0, () => (input[_q] || []).map((_entry) => _entry)],
        [_sD]: [
            __expectNonNull(input.startDate, `startDate`) != null,
            () => (input[_sD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eD]: [
            __expectNonNull(input.endDate, `endDate`) != null,
            () => (input[_eD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_tO]: [, input[_tO]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAssetPropertyValueCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/properties/latest");
    const query = map({
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
        [_pA]: [, input[_pA]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAssetPropertyValueHistoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/properties/history");
    const query = map({
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
        [_pA]: [, input[_pA]],
        [_sD]: [() => input.startDate !== void 0, () => (input[_sD].toISOString().split(".")[0] + "Z").toString()],
        [_eD]: [() => input.endDate !== void 0, () => (input[_eD].toISOString().split(".")[0] + "Z").toString()],
        [_q]: [() => input.qualities !== void 0, () => (input[_q] || []).map((_entry) => _entry)],
        [_tO]: [, input[_tO]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetInterpolatedAssetPropertyValuesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/properties/interpolated");
    const query = map({
        [_aI]: [, input[_aI]],
        [_pI]: [, input[_pI]],
        [_pA]: [, input[_pA]],
        [_sTIS]: [__expectNonNull(input.startTimeInSeconds, `startTimeInSeconds`) != null, () => input[_sTIS].toString()],
        [_sTOIN]: [() => input.startTimeOffsetInNanos !== void 0, () => input[_sTOIN].toString()],
        [_eTIS]: [__expectNonNull(input.endTimeInSeconds, `endTimeInSeconds`) != null, () => input[_eTIS].toString()],
        [_eTOIN]: [() => input.endTimeOffsetInNanos !== void 0, () => input[_eTOIN].toString()],
        [_qu]: [, __expectNonNull(input[_qu], `quality`)],
        [_iIS]: [__expectNonNull(input.intervalInSeconds, `intervalInSeconds`) != null, () => input[_iIS].toString()],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_t]: [, __expectNonNull(input[_t], `type`)],
        [_iWIS]: [() => input.intervalWindowInSeconds !== void 0, () => input[_iWIS].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAccessPoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/access-policies");
    const query = map({
        [_iT]: [, input[_iT]],
        [_iI]: [, input[_iI]],
        [_rT]: [, input[_rT]],
        [_rI]: [, input[_rI]],
        [_iA]: [, input[_iA]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListActionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/actions");
    const query = map({
        [_tRT]: [, __expectNonNull(input[_tRT], `targetResourceType`)],
        [_tRI]: [, __expectNonNull(input[_tRI], `targetResourceId`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetModelCompositeModelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}/composite-models");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetModelPropertiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}/properties");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_f]: [, input[_f]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetModelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_aMT]: [() => input.assetModelTypes !== void 0, () => (input[_aMT] || []).map((_entry) => _entry)],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetPropertiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}/properties");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_f]: [, input[_f]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetRelationshipsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}/assetRelationships");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    const query = map({
        [_tT]: [, __expectNonNull(input[_tT], `traversalType`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_aMI]: [, input[_aMI]],
        [_f]: [, input[_f]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssociatedAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{assetId}/hierarchies");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    const query = map({
        [_hI]: [, input[_hI]],
        [_tD]: [, input[_tD]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListBulkImportJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_f]: [, input[_f]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCompositionRelationshipsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/asset-models/{assetModelId}/composition-relationships");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDashboardsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dashboards");
    const query = map({
        [_pIr]: [, __expectNonNull(input[_pIr], `projectId`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListGatewaysCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/20200301/gateways");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPortalsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/portals");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProjectAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{projectId}/assets");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProjectsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects");
    const query = map({
        [_pIo]: [, __expectNonNull(input[_pIo], `portalId`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTimeSeriesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/timeseries");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_aI]: [, input[_aI]],
        [_aP]: [, input[_aP]],
        [_tST]: [, input[_tST]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutDefaultEncryptionConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/configuration/account/encryption");
    let body;
    body = JSON.stringify(take(input, {
        encryptionType: [],
        kmsKeyId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutLoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/logging");
    let body;
    body = JSON.stringify(take(input, {
        loggingOptions: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutStorageConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/configuration/account/storage");
    let body;
    body = JSON.stringify(take(input, {
        disassociatedDataStorage: [],
        multiLayerStorage: (_) => _json(_),
        retentionPeriod: (_) => _json(_),
        storageType: [],
        warmTier: [],
        warmTierRetentionPeriod: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/access-policies/{accessPolicyId}");
    b.p("accessPolicyId", () => input.accessPolicyId, "{accessPolicyId}", false);
    let body;
    body = JSON.stringify(take(input, {
        accessPolicyIdentity: (_) => _json(_),
        accessPolicyPermission: [],
        accessPolicyResource: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets/{assetId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetDescription: [],
        assetExternalId: [],
        assetName: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateAssetModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/asset-models/{assetModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetModelCompositeModels: (_) => se_AssetModelCompositeModels(_, context),
        assetModelDescription: [],
        assetModelExternalId: [],
        assetModelHierarchies: (_) => _json(_),
        assetModelName: [],
        assetModelProperties: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateAssetModelCompositeModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/asset-models/{assetModelId}/composite-models/{assetModelCompositeModelId}");
    b.p("assetModelId", () => input.assetModelId, "{assetModelId}", false);
    b.p("assetModelCompositeModelId", () => input.assetModelCompositeModelId, "{assetModelCompositeModelId}", false);
    let body;
    body = JSON.stringify(take(input, {
        assetModelCompositeModelDescription: [],
        assetModelCompositeModelExternalId: [],
        assetModelCompositeModelName: [],
        assetModelCompositeModelProperties: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateAssetPropertyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets/{assetId}/properties/{propertyId}");
    b.p("assetId", () => input.assetId, "{assetId}", false);
    b.p("propertyId", () => input.propertyId, "{propertyId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        propertyAlias: [],
        propertyNotificationState: [],
        propertyUnit: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateDashboardCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dashboards/{dashboardId}");
    b.p("dashboardId", () => input.dashboardId, "{dashboardId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        dashboardDefinition: [],
        dashboardDescription: [],
        dashboardName: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/20200301/gateways/{gatewayId}");
    b.p("gatewayId", () => input.gatewayId, "{gatewayId}", false);
    let body;
    body = JSON.stringify(take(input, {
        gatewayName: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateGatewayCapabilityConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/20200301/gateways/{gatewayId}/capability");
    b.p("gatewayId", () => input.gatewayId, "{gatewayId}", false);
    let body;
    body = JSON.stringify(take(input, {
        capabilityConfiguration: [],
        capabilityNamespace: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdatePortalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/portals/{portalId}");
    b.p("portalId", () => input.portalId, "{portalId}", false);
    let body;
    body = JSON.stringify(take(input, {
        alarms: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        notificationSenderEmail: [],
        portalContactEmail: [],
        portalDescription: [],
        portalLogoImage: (_) => se_Image(_, context),
        portalName: [],
        roleArn: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{projectId}");
    b.p("projectId", () => input.projectId, "{projectId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        projectDescription: [],
        projectName: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "monitor." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_AssociateAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AssociateTimeSeriesToAssetPropertyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_BatchAssociateProjectAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errors: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchDisassociateProjectAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errors: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchGetAssetPropertyAggregatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errorEntries: _json,
        nextToken: __expectString,
        skippedEntries: (_) => de_BatchGetAssetPropertyAggregatesSkippedEntries(_, context),
        successEntries: (_) => de_BatchGetAssetPropertyAggregatesSuccessEntries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchGetAssetPropertyValueCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errorEntries: _json,
        nextToken: __expectString,
        skippedEntries: (_) => de_BatchGetAssetPropertyValueSkippedEntries(_, context),
        successEntries: (_) => de_BatchGetAssetPropertyValueSuccessEntries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchGetAssetPropertyValueHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errorEntries: _json,
        nextToken: __expectString,
        skippedEntries: (_) => de_BatchGetAssetPropertyValueHistorySkippedEntries(_, context),
        successEntries: (_) => de_BatchGetAssetPropertyValueHistorySuccessEntries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchPutAssetPropertyValueCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errorEntries: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessPolicyArn: __expectString,
        accessPolicyId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAssetCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetArn: __expectString,
        assetId: __expectString,
        assetStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAssetModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelArn: __expectString,
        assetModelId: __expectString,
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAssetModelCompositeModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelCompositeModelId: __expectString,
        assetModelCompositeModelPath: _json,
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBulkImportJobCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobId: __expectString,
        jobName: __expectString,
        jobStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDashboardCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dashboardArn: __expectString,
        dashboardId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateGatewayCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        gatewayArn: __expectString,
        gatewayId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreatePortalCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        portalArn: __expectString,
        portalId: __expectString,
        portalStartUrl: __expectString,
        portalStatus: _json,
        ssoApplicationId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateProjectCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        projectArn: __expectString,
        projectId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteAssetCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteAssetModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteAssetModelCompositeModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteDashboardCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteGatewayCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeletePortalCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        portalStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteProjectCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteTimeSeriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessPolicyArn: __expectString,
        accessPolicyCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        accessPolicyId: __expectString,
        accessPolicyIdentity: _json,
        accessPolicyLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        accessPolicyPermission: __expectString,
        accessPolicyResource: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionDefinitionId: __expectString,
        actionId: __expectString,
        actionPayload: _json,
        executionTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        targetResource: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeAssetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetArn: __expectString,
        assetCompositeModelSummaries: _json,
        assetCompositeModels: _json,
        assetCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        assetDescription: __expectString,
        assetExternalId: __expectString,
        assetHierarchies: _json,
        assetId: __expectString,
        assetLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        assetModelId: __expectString,
        assetName: __expectString,
        assetProperties: _json,
        assetStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeAssetCompositeModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionDefinitions: _json,
        assetCompositeModelDescription: __expectString,
        assetCompositeModelExternalId: __expectString,
        assetCompositeModelId: __expectString,
        assetCompositeModelName: __expectString,
        assetCompositeModelPath: _json,
        assetCompositeModelProperties: _json,
        assetCompositeModelSummaries: _json,
        assetCompositeModelType: __expectString,
        assetId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeAssetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelArn: __expectString,
        assetModelCompositeModelSummaries: _json,
        assetModelCompositeModels: (_) => de_AssetModelCompositeModels(_, context),
        assetModelCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        assetModelDescription: __expectString,
        assetModelExternalId: __expectString,
        assetModelHierarchies: _json,
        assetModelId: __expectString,
        assetModelLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        assetModelName: __expectString,
        assetModelProperties: _json,
        assetModelStatus: _json,
        assetModelType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeAssetModelCompositeModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionDefinitions: _json,
        assetModelCompositeModelDescription: __expectString,
        assetModelCompositeModelExternalId: __expectString,
        assetModelCompositeModelId: __expectString,
        assetModelCompositeModelName: __expectString,
        assetModelCompositeModelPath: _json,
        assetModelCompositeModelProperties: _json,
        assetModelCompositeModelSummaries: _json,
        assetModelCompositeModelType: __expectString,
        assetModelId: __expectString,
        compositionDetails: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeAssetPropertyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetExternalId: __expectString,
        assetId: __expectString,
        assetModelId: __expectString,
        assetName: __expectString,
        assetProperty: _json,
        compositeModel: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBulkImportJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        adaptiveIngestion: __expectBoolean,
        deleteFilesAfterImport: __expectBoolean,
        errorReportLocation: _json,
        files: _json,
        jobConfiguration: _json,
        jobCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        jobId: __expectString,
        jobLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        jobName: __expectString,
        jobRoleArn: __expectString,
        jobStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDashboardCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dashboardArn: __expectString,
        dashboardCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dashboardDefinition: __expectString,
        dashboardDescription: __expectString,
        dashboardId: __expectString,
        dashboardLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dashboardName: __expectString,
        projectId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDefaultEncryptionConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationStatus: _json,
        encryptionType: __expectString,
        kmsKeyArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeGatewayCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        gatewayArn: __expectString,
        gatewayCapabilitySummaries: _json,
        gatewayId: __expectString,
        gatewayName: __expectString,
        gatewayPlatform: _json,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeGatewayCapabilityConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        capabilityConfiguration: __expectString,
        capabilityNamespace: __expectString,
        capabilitySyncStatus: __expectString,
        gatewayId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        loggingOptions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePortalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        alarms: _json,
        notificationSenderEmail: __expectString,
        portalArn: __expectString,
        portalAuthMode: __expectString,
        portalClientId: __expectString,
        portalContactEmail: __expectString,
        portalCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        portalDescription: __expectString,
        portalId: __expectString,
        portalLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        portalLogoImageLocation: _json,
        portalName: __expectString,
        portalStartUrl: __expectString,
        portalStatus: _json,
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        portalId: __expectString,
        projectArn: __expectString,
        projectCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        projectDescription: __expectString,
        projectId: __expectString,
        projectLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        projectName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeStorageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationStatus: _json,
        disassociatedDataStorage: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        multiLayerStorage: _json,
        retentionPeriod: _json,
        storageType: __expectString,
        warmTier: __expectString,
        warmTierRetentionPeriod: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTimeSeriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        alias: __expectString,
        assetId: __expectString,
        dataType: __expectString,
        dataTypeSpec: __expectString,
        propertyId: __expectString,
        timeSeriesArn: __expectString,
        timeSeriesCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        timeSeriesId: __expectString,
        timeSeriesLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DisassociateAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DisassociateTimeSeriesFromAssetPropertyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ExecuteActionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ExecuteQueryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        columns: _json,
        nextToken: __expectString,
        rows: (_) => de_Rows(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAssetPropertyAggregatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        aggregatedValues: (_) => de_AggregatedValues(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAssetPropertyValueCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        propertyValue: (_) => de_AssetPropertyValue(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAssetPropertyValueHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetPropertyValueHistory: (_) => de_AssetPropertyValueHistory(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetInterpolatedAssetPropertyValuesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        interpolatedAssetPropertyValues: (_) => de_InterpolatedAssetPropertyValues(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAccessPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessPolicySummaries: (_) => de_AccessPolicySummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetModelCompositeModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelCompositeModelSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetModelPropertiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelPropertySummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelSummaries: (_) => de_AssetModelSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetPropertiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetPropertySummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetRelationshipsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetRelationshipSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetSummaries: (_) => de_AssetSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssociatedAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetSummaries: (_) => de_AssociatedAssetsSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBulkImportJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListCompositionRelationshipsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        compositionRelationshipSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDashboardsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dashboardSummaries: (_) => de_DashboardSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListGatewaysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        gatewaySummaries: (_) => de_GatewaySummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPortalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        portalSummaries: (_) => de_PortalSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProjectAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetIds: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        projectSummaries: (_) => de_ProjectSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTimeSeriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TimeSeriesSummaries: (_) => de_TimeSeriesSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutDefaultEncryptionConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationStatus: _json,
        encryptionType: __expectString,
        kmsKeyArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutStorageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationStatus: _json,
        disassociatedDataStorage: __expectString,
        multiLayerStorage: _json,
        retentionPeriod: _json,
        storageType: __expectString,
        warmTier: __expectString,
        warmTierRetentionPeriod: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateAssetCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateAssetModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateAssetModelCompositeModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assetModelCompositeModelPath: _json,
        assetModelStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateAssetPropertyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateDashboardCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateGatewayCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateGatewayCapabilityConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        capabilityNamespace: __expectString,
        capabilitySyncStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdatePortalCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        portalStatus: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingOperationException":
        case "com.amazonaws.iotsitewise#ConflictingOperationException":
            throw await de_ConflictingOperationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iotsitewise#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iotsitewise#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iotsitewise#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iotsitewise#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iotsitewise#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iotsitewise#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iotsitewise#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "AccessDeniedException":
        case "com.amazonaws.iotsitewise#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "QueryTimeoutException":
        case "com.amazonaws.iotsitewise#QueryTimeoutException":
            throw await de_QueryTimeoutExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iotsitewise#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iotsitewise#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.iotsitewise#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictingOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceArn: __expectString,
        resourceId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictingOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_QueryTimeoutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new QueryTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceArn: __expectString,
        resourceId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceName: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AssetModelCompositeModelDefinitions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return _json(entry);
    });
};
const se_AssetModelCompositeModels = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return _json(entry);
    });
};
const se_AssetPropertyValue = (input, context) => {
    return take(input, {
        quality: [],
        timestamp: _json,
        value: (_) => se_Variant(_, context),
    });
};
const se_AssetPropertyValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AssetPropertyValue(entry, context);
    });
};
const se_BatchGetAssetPropertyAggregatesEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchGetAssetPropertyAggregatesEntry(entry, context);
    });
};
const se_BatchGetAssetPropertyAggregatesEntry = (input, context) => {
    return take(input, {
        aggregateTypes: _json,
        assetId: [],
        endDate: (_) => Math.round(_.getTime() / 1000),
        entryId: [],
        propertyAlias: [],
        propertyId: [],
        qualities: _json,
        resolution: [],
        startDate: (_) => Math.round(_.getTime() / 1000),
        timeOrdering: [],
    });
};
const se_BatchGetAssetPropertyValueHistoryEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchGetAssetPropertyValueHistoryEntry(entry, context);
    });
};
const se_BatchGetAssetPropertyValueHistoryEntry = (input, context) => {
    return take(input, {
        assetId: [],
        endDate: (_) => Math.round(_.getTime() / 1000),
        entryId: [],
        propertyAlias: [],
        propertyId: [],
        qualities: _json,
        startDate: (_) => Math.round(_.getTime() / 1000),
        timeOrdering: [],
    });
};
const se_Image = (input, context) => {
    return take(input, {
        file: (_) => se_ImageFile(_, context),
        id: [],
    });
};
const se_ImageFile = (input, context) => {
    return take(input, {
        data: context.base64Encoder,
        type: [],
    });
};
const se_PutAssetPropertyValueEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PutAssetPropertyValueEntry(entry, context);
    });
};
const se_PutAssetPropertyValueEntry = (input, context) => {
    return take(input, {
        assetId: [],
        entryId: [],
        propertyAlias: [],
        propertyId: [],
        propertyValues: (_) => se_AssetPropertyValues(_, context),
    });
};
const se_Variant = (input, context) => {
    return take(input, {
        booleanValue: [],
        doubleValue: __serializeFloat,
        integerValue: [],
        stringValue: [],
    });
};
const de_AccessPolicySummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessPolicySummary(entry, context);
    });
    return retVal;
};
const de_AccessPolicySummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        id: __expectString,
        identity: _json,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        permission: __expectString,
        resource: _json,
    });
};
const de_AggregatedValue = (output, context) => {
    return take(output, {
        quality: __expectString,
        timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        value: (_) => de_Aggregates(_, context),
    });
};
const de_AggregatedValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AggregatedValue(entry, context);
    });
    return retVal;
};
const de_Aggregates = (output, context) => {
    return take(output, {
        average: __limitedParseDouble,
        count: __limitedParseDouble,
        maximum: __limitedParseDouble,
        minimum: __limitedParseDouble,
        standardDeviation: __limitedParseDouble,
        sum: __limitedParseDouble,
    });
};
const de_AssetModelCompositeModels = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return _json(entry);
    });
    return retVal;
};
const de_AssetModelSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssetModelSummary(entry, context);
    });
    return retVal;
};
const de_AssetModelSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        assetModelType: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalId: __expectString,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        status: _json,
    });
};
const de_AssetPropertyValue = (output, context) => {
    return take(output, {
        quality: __expectString,
        timestamp: _json,
        value: (_) => de_Variant(_, context),
    });
};
const de_AssetPropertyValueHistory = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssetPropertyValue(entry, context);
    });
    return retVal;
};
const de_AssetSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssetSummary(entry, context);
    });
    return retVal;
};
const de_AssetSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        assetModelId: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalId: __expectString,
        hierarchies: _json,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        status: _json,
    });
};
const de_AssociatedAssetsSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssociatedAssetsSummary(entry, context);
    });
    return retVal;
};
const de_AssociatedAssetsSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        assetModelId: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        externalId: __expectString,
        hierarchies: _json,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        status: _json,
    });
};
const de_BatchGetAssetPropertyAggregatesErrorInfo = (output, context) => {
    return take(output, {
        errorCode: __expectString,
        errorTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BatchGetAssetPropertyAggregatesSkippedEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyAggregatesSkippedEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyAggregatesSkippedEntry = (output, context) => {
    return take(output, {
        completionStatus: __expectString,
        entryId: __expectString,
        errorInfo: (_) => de_BatchGetAssetPropertyAggregatesErrorInfo(_, context),
    });
};
const de_BatchGetAssetPropertyAggregatesSuccessEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyAggregatesSuccessEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyAggregatesSuccessEntry = (output, context) => {
    return take(output, {
        aggregatedValues: (_) => de_AggregatedValues(_, context),
        entryId: __expectString,
    });
};
const de_BatchGetAssetPropertyValueErrorInfo = (output, context) => {
    return take(output, {
        errorCode: __expectString,
        errorTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BatchGetAssetPropertyValueHistoryErrorInfo = (output, context) => {
    return take(output, {
        errorCode: __expectString,
        errorTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_BatchGetAssetPropertyValueHistorySkippedEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyValueHistorySkippedEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyValueHistorySkippedEntry = (output, context) => {
    return take(output, {
        completionStatus: __expectString,
        entryId: __expectString,
        errorInfo: (_) => de_BatchGetAssetPropertyValueHistoryErrorInfo(_, context),
    });
};
const de_BatchGetAssetPropertyValueHistorySuccessEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyValueHistorySuccessEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyValueHistorySuccessEntry = (output, context) => {
    return take(output, {
        assetPropertyValueHistory: (_) => de_AssetPropertyValueHistory(_, context),
        entryId: __expectString,
    });
};
const de_BatchGetAssetPropertyValueSkippedEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyValueSkippedEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyValueSkippedEntry = (output, context) => {
    return take(output, {
        completionStatus: __expectString,
        entryId: __expectString,
        errorInfo: (_) => de_BatchGetAssetPropertyValueErrorInfo(_, context),
    });
};
const de_BatchGetAssetPropertyValueSuccessEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchGetAssetPropertyValueSuccessEntry(entry, context);
    });
    return retVal;
};
const de_BatchGetAssetPropertyValueSuccessEntry = (output, context) => {
    return take(output, {
        assetPropertyValue: (_) => de_AssetPropertyValue(_, context),
        entryId: __expectString,
    });
};
const de_DashboardSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashboardSummary(entry, context);
    });
    return retVal;
};
const de_DashboardSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
    });
};
const de_Datum = (output, context) => {
    return take(output, {
        arrayValue: (_) => de_DatumList(_, context),
        nullValue: __expectBoolean,
        rowValue: (_) => de_Row(_, context),
        scalarValue: __expectString,
    });
};
const de_DatumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Datum(entry, context);
    });
    return retVal;
};
const de_GatewaySummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GatewaySummary(entry, context);
    });
    return retVal;
};
const de_GatewaySummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        gatewayCapabilitySummaries: _json,
        gatewayId: __expectString,
        gatewayName: __expectString,
        gatewayPlatform: _json,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_InterpolatedAssetPropertyValue = (output, context) => {
    return take(output, {
        timestamp: _json,
        value: (_) => de_Variant(_, context),
    });
};
const de_InterpolatedAssetPropertyValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InterpolatedAssetPropertyValue(entry, context);
    });
    return retVal;
};
const de_PortalSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PortalSummary(entry, context);
    });
    return retVal;
};
const de_PortalSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        roleArn: __expectString,
        startUrl: __expectString,
        status: _json,
    });
};
const de_ProjectSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProjectSummary(entry, context);
    });
    return retVal;
};
const de_ProjectSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
        lastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
    });
};
const de_Row = (output, context) => {
    return take(output, {
        data: (_) => de_DatumList(_, context),
    });
};
const de_Rows = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Row(entry, context);
    });
    return retVal;
};
const de_TimeSeriesSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TimeSeriesSummary(entry, context);
    });
    return retVal;
};
const de_TimeSeriesSummary = (output, context) => {
    return take(output, {
        alias: __expectString,
        assetId: __expectString,
        dataType: __expectString,
        dataTypeSpec: __expectString,
        propertyId: __expectString,
        timeSeriesArn: __expectString,
        timeSeriesCreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        timeSeriesId: __expectString,
        timeSeriesLastUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_Variant = (output, context) => {
    return take(output, {
        booleanValue: __expectBoolean,
        doubleValue: __limitedParseDouble,
        integerValue: __expectInt32,
        stringValue: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _a = "alias";
const _aI = "assetId";
const _aMI = "assetModelId";
const _aMT = "assetModelTypes";
const _aP = "aliasPrefix";
const _aT = "aggregateTypes";
const _cT = "clientToken";
const _eD = "endDate";
const _eP = "excludeProperties";
const _eTIS = "endTimeInSeconds";
const _eTOIN = "endTimeOffsetInNanos";
const _f = "filter";
const _hI = "hierarchyId";
const _iA = "iamArn";
const _iI = "identityId";
const _iIS = "intervalInSeconds";
const _iT = "identityType";
const _iWIS = "intervalWindowInSeconds";
const _mR = "maxResults";
const _nT = "nextToken";
const _pA = "propertyAlias";
const _pI = "propertyId";
const _pIo = "portalId";
const _pIr = "projectId";
const _q = "qualities";
const _qu = "quality";
const _r = "resolution";
const _rA = "resourceArn";
const _rI = "resourceId";
const _rT = "resourceType";
const _sD = "startDate";
const _sTIS = "startTimeInSeconds";
const _sTOIN = "startTimeOffsetInNanos";
const _t = "type";
const _tD = "traversalDirection";
const _tK = "tagKeys";
const _tO = "timeOrdering";
const _tRI = "targetResourceId";
const _tRT = "targetResourceType";
const _tST = "timeSeriesType";
const _tT = "traversalType";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
