import { awsExpectUnion as __expectUnion } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { AccessDeniedException, BaseException, ConflictException, DependencyFailureException, DisabledOperationException, InternalException, InvalidPaginationTokenException, InvalidTypeException, LimitExceededException, ResourceAlreadyExistsException, ResourceNotFoundException, SlotNotAvailableException, ValidationException, } from "../models/models_0";
import { OpenSearchServiceException as __BaseException } from "../models/OpenSearchServiceException";
export const se_AcceptInboundConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}/accept");
    b.p("ConnectionId", () => input.ConnectionId, "{ConnectionId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AddDataSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dataSource");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        DataSourceType: (_) => _json(_),
        Description: [],
        Name: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/tags");
    let body;
    body = JSON.stringify(take(input, {
        ARN: [],
        TagList: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AssociatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/packages/associate/{PackageID}/{DomainName}");
    b.p("PackageID", () => input.PackageID, "{PackageID}", false);
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AuthorizeVpcEndpointAccessCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/authorizeVpcEndpointAccess");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Account: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CancelDomainConfigChangeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/config/cancel");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        DryRun: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CancelServiceSoftwareUpdateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/serviceSoftwareUpdate/cancel");
    let body;
    body = JSON.stringify(take(input, {
        DomainName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain");
    let body;
    body = JSON.stringify(take(input, {
        AccessPolicies: [],
        AdvancedOptions: (_) => _json(_),
        AdvancedSecurityOptions: (_) => _json(_),
        AutoTuneOptions: (_) => se_AutoTuneOptionsInput(_, context),
        ClusterConfig: (_) => _json(_),
        CognitoOptions: (_) => _json(_),
        DomainEndpointOptions: (_) => _json(_),
        DomainName: [],
        EBSOptions: (_) => _json(_),
        EncryptionAtRestOptions: (_) => _json(_),
        EngineVersion: [],
        IPAddressType: [],
        LogPublishingOptions: (_) => _json(_),
        NodeToNodeEncryptionOptions: (_) => _json(_),
        OffPeakWindowOptions: (_) => _json(_),
        SnapshotOptions: (_) => _json(_),
        SoftwareUpdateOptions: (_) => _json(_),
        TagList: (_) => _json(_),
        VPCOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateOutboundConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/cc/outboundConnection");
    let body;
    body = JSON.stringify(take(input, {
        ConnectionAlias: [],
        ConnectionMode: [],
        ConnectionProperties: (_) => _json(_),
        LocalDomainInfo: (_) => _json(_),
        RemoteDomainInfo: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/packages");
    let body;
    body = JSON.stringify(take(input, {
        PackageDescription: [],
        PackageName: [],
        PackageSource: (_) => _json(_),
        PackageType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateVpcEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/vpcEndpoints");
    let body;
    body = JSON.stringify(take(input, {
        ClientToken: [],
        DomainArn: [],
        VpcOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteDataSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dataSource/{Name}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteInboundConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}");
    b.p("ConnectionId", () => input.ConnectionId, "{ConnectionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteOutboundConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/cc/outboundConnection/{ConnectionId}");
    b.p("ConnectionId", () => input.ConnectionId, "{ConnectionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeletePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/packages/{PackageID}");
    b.p("PackageID", () => input.PackageID, "{PackageID}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteVpcEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/vpcEndpoints/{VpcEndpointId}");
    b.p("VpcEndpointId", () => input.VpcEndpointId, "{VpcEndpointId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainAutoTunesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/autoTunes");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
    }));
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainChangeProgressCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/progress");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_c]: [, input[_CI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeDomainConfigCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/config");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainHealthCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/health");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainNodesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/nodes");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain-info");
    let body;
    body = JSON.stringify(take(input, {
        DomainNames: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeDryRunProgressCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dryRun");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_dRI]: [, input[_DRI]],
        [_lDRC]: [() => input.LoadDryRunConfig !== void 0, () => input[_LDRC].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeInboundConnectionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/cc/inboundConnection/search");
    let body;
    body = JSON.stringify(take(input, {
        Filters: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeInstanceTypeLimitsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/instanceTypeLimits/{EngineVersion}/{InstanceType}");
    b.p("InstanceType", () => input.InstanceType, "{InstanceType}", false);
    b.p("EngineVersion", () => input.EngineVersion, "{EngineVersion}", false);
    const query = map({
        [_dN]: [, input[_DN]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeOutboundConnectionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/cc/outboundConnection/search");
    let body;
    body = JSON.stringify(take(input, {
        Filters: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribePackagesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/packages/describe");
    let body;
    body = JSON.stringify(take(input, {
        Filters: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeReservedInstanceOfferingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/reservedInstanceOfferings");
    const query = map({
        [_oI]: [, input[_RIOI]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeReservedInstancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/reservedInstances");
    const query = map({
        [_rI]: [, input[_RII]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeVpcEndpointsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/vpcEndpoints/describe");
    let body;
    body = JSON.stringify(take(input, {
        VpcEndpointIds: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DissociatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/packages/dissociate/{PackageID}/{DomainName}");
    b.p("PackageID", () => input.PackageID, "{PackageID}", false);
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetCompatibleVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/compatibleVersions");
    const query = map({
        [_dN]: [, input[_DN]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDataSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dataSource/{Name}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDomainMaintenanceStatusCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/domainMaintenance");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_mI]: [, __expectNonNull(input[_MI], `MaintenanceId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetPackageVersionHistoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/packages/{PackageID}/history");
    b.p("PackageID", () => input.PackageID, "{PackageID}", false);
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetUpgradeHistoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/upgradeDomain/{DomainName}/history");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetUpgradeStatusCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/upgradeDomain/{DomainName}/status");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListDataSourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dataSource");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListDomainMaintenancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/domainMaintenances");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_a]: [, input[_A]],
        [_s]: [, input[_S]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainNamesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/domain");
    const query = map({
        [_eT]: [, input[_ET]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainsForPackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/packages/{PackageID}/domains");
    b.p("PackageID", () => input.PackageID, "{PackageID}", false);
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListInstanceTypeDetailsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/instanceTypeDetails/{EngineVersion}");
    b.p("EngineVersion", () => input.EngineVersion, "{EngineVersion}", false);
    const query = map({
        [_dN]: [, input[_DN]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
        [_rAZ]: [() => input.RetrieveAZs !== void 0, () => input[_RAZ].toString()],
        [_iT]: [, input[_IT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackagesForDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/domain/{DomainName}/packages");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListScheduledActionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/scheduledActions");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/tags");
    const query = map({
        [_ar]: [, __expectNonNull(input[_ARN], `ARN`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/versions");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListVpcEndpointAccessCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/listVpcEndpointAccess");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListVpcEndpointsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/vpcEndpoints");
    const query = map({
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListVpcEndpointsForDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/vpcEndpoints");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_PurchaseReservedInstanceOfferingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/purchaseReservedInstanceOffering");
    let body;
    body = JSON.stringify(take(input, {
        InstanceCount: [],
        ReservationName: [],
        ReservedInstanceOfferingId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RejectInboundConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}/reject");
    b.p("ConnectionId", () => input.ConnectionId, "{ConnectionId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_RemoveTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/tags-removal");
    let body;
    body = JSON.stringify(take(input, {
        ARN: [],
        TagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RevokeVpcEndpointAccessCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/revokeVpcEndpointAccess");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Account: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartDomainMaintenanceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/domainMaintenance");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Action: [],
        NodeId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartServiceSoftwareUpdateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/serviceSoftwareUpdate/start");
    let body;
    body = JSON.stringify(take(input, {
        DesiredStartTime: [],
        DomainName: [],
        ScheduleAt: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateDataSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/dataSource/{Name}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = JSON.stringify(take(input, {
        DataSourceType: (_) => _json(_),
        Description: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateDomainConfigCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/config");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        AccessPolicies: [],
        AdvancedOptions: (_) => _json(_),
        AdvancedSecurityOptions: (_) => _json(_),
        AutoTuneOptions: (_) => se_AutoTuneOptions(_, context),
        ClusterConfig: (_) => _json(_),
        CognitoOptions: (_) => _json(_),
        DomainEndpointOptions: (_) => _json(_),
        DryRun: [],
        DryRunMode: [],
        EBSOptions: (_) => _json(_),
        EncryptionAtRestOptions: (_) => _json(_),
        IPAddressType: [],
        LogPublishingOptions: (_) => _json(_),
        NodeToNodeEncryptionOptions: (_) => _json(_),
        OffPeakWindowOptions: (_) => _json(_),
        SnapshotOptions: (_) => _json(_),
        SoftwareUpdateOptions: (_) => _json(_),
        VPCOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/packages/update");
    let body;
    body = JSON.stringify(take(input, {
        CommitMessage: [],
        PackageDescription: [],
        PackageID: [],
        PackageSource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateScheduledActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/domain/{DomainName}/scheduledAction/update");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        ActionID: [],
        ActionType: [],
        DesiredStartTime: [],
        ScheduleAt: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateVpcEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/vpcEndpoints/update");
    let body;
    body = JSON.stringify(take(input, {
        VpcEndpointId: [],
        VpcOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpgradeDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/2021-01-01/opensearch/upgradeDomain");
    let body;
    body = JSON.stringify(take(input, {
        AdvancedOptions: (_) => _json(_),
        DomainName: [],
        PerformCheckOnly: [],
        TargetVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_AcceptInboundConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connection: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddDataSourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AssociatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainPackageDetails: (_) => de_DomainPackageDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AuthorizeVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AuthorizedPrincipal: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CancelDomainConfigChangeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CancelledChangeIds: _json,
        CancelledChangeProperties: _json,
        DryRun: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CancelServiceSoftwareUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ServiceSoftwareOptions: (_) => de_ServiceSoftwareOptions(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainStatus: (_) => de_DomainStatus(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateOutboundConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ConnectionAlias: __expectString,
        ConnectionId: __expectString,
        ConnectionMode: __expectString,
        ConnectionProperties: _json,
        ConnectionStatus: _json,
        LocalDomainInfo: _json,
        RemoteDomainInfo: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        PackageDetails: (_) => de_PackageDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VpcEndpoint: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteDataSourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainStatus: (_) => de_DomainStatus(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteInboundConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connection: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteOutboundConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connection: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeletePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        PackageDetails: (_) => de_PackageDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VpcEndpointSummary: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainStatus: (_) => de_DomainStatus(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainAutoTunesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AutoTunes: (_) => de_AutoTuneList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainChangeProgressCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ChangeProgressStatus: (_) => de_ChangeProgressStatusDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainConfig: (_) => de_DomainConfig(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainHealthCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ActiveAvailabilityZoneCount: __expectString,
        AvailabilityZoneCount: __expectString,
        ClusterHealth: __expectString,
        DataNodeCount: __expectString,
        DedicatedMaster: __expectBoolean,
        DomainState: __expectString,
        EnvironmentInformation: _json,
        MasterEligibleNodeCount: __expectString,
        MasterNode: __expectString,
        StandByAvailabilityZoneCount: __expectString,
        TotalShards: __expectString,
        TotalUnAssignedShards: __expectString,
        WarmNodeCount: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainNodesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainNodesStatusList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainStatusList: (_) => de_DomainStatusList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDryRunProgressCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DryRunConfig: (_) => de_DomainStatus(_, context),
        DryRunProgressStatus: _json,
        DryRunResults: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeInboundConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connections: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeInstanceTypeLimitsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LimitsByRole: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeOutboundConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connections: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        PackageDetailsList: (_) => de_PackageDetailsList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeReservedInstanceOfferingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ReservedInstanceOfferings: (_) => de_ReservedInstanceOfferingList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeReservedInstancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ReservedInstances: (_) => de_ReservedInstanceList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VpcEndpointErrors: _json,
        VpcEndpoints: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DissociatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainPackageDetails: (_) => de_DomainPackageDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetCompatibleVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CompatibleVersions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDataSourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DataSourceType: (_) => _json(__expectUnion(_)),
        Description: __expectString,
        Name: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainMaintenanceStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Action: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        NodeId: __expectString,
        Status: __expectString,
        StatusMessage: __expectString,
        UpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetPackageVersionHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        PackageID: __expectString,
        PackageVersionHistoryList: (_) => de_PackageVersionHistoryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUpgradeHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        UpgradeHistories: (_) => de_UpgradeHistoryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUpgradeStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        StepStatus: __expectString,
        UpgradeName: __expectString,
        UpgradeStep: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDataSourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DataSources: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainMaintenancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainMaintenances: (_) => de_DomainMaintenanceList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainNames: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainsForPackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainPackageDetailsList: (_) => de_DomainPackageDetailsList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListInstanceTypeDetailsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        InstanceTypeDetails: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackagesForDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainPackageDetailsList: (_) => de_DomainPackageDetailsList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListScheduledActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ScheduledActions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TagList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Versions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AuthorizedPrincipalList: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        VpcEndpointSummaryList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListVpcEndpointsForDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        VpcEndpointSummaryList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PurchaseReservedInstanceOfferingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ReservationName: __expectString,
        ReservedInstanceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RejectInboundConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connection: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RevokeVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_StartDomainMaintenanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MaintenanceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartServiceSoftwareUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ServiceSoftwareOptions: (_) => de_ServiceSoftwareOptions(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDataSourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDomainConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainConfig: (_) => de_DomainConfig(_, context),
        DryRunProgressStatus: _json,
        DryRunResults: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        PackageDetails: (_) => de_PackageDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateScheduledActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ScheduledAction: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VpcEndpoint: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpgradeDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AdvancedOptions: _json,
        ChangeProgressDetails: (_) => de_ChangeProgressDetails(_, context),
        DomainName: __expectString,
        PerformCheckOnly: __expectBoolean,
        TargetVersion: __expectString,
        UpgradeId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.opensearch#DisabledOperationException":
            throw await de_DisabledOperationExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.opensearch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.opensearch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.opensearch#BaseException":
            throw await de_BaseExceptionRes(parsedOutput, context);
        case "DependencyFailureException":
        case "com.amazonaws.opensearch#DependencyFailureException":
            throw await de_DependencyFailureExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.opensearch#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.opensearch#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "AccessDeniedException":
        case "com.amazonaws.opensearch#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.opensearch#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InvalidTypeException":
        case "com.amazonaws.opensearch#InvalidTypeException":
            throw await de_InvalidTypeExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.opensearch#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidPaginationTokenException":
        case "com.amazonaws.opensearch#InvalidPaginationTokenException":
            throw await de_InvalidPaginationTokenExceptionRes(parsedOutput, context);
        case "SlotNotAvailableException":
        case "com.amazonaws.opensearch#SlotNotAvailableException":
            throw await de_SlotNotAvailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BaseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BaseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DependencyFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DependencyFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DisabledOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DisabledOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidPaginationTokenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidPaginationTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidTypeExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_SlotNotAvailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        SlotSuggestions: _json,
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new SlotNotAvailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AutoTuneMaintenanceSchedule = (input, context) => {
    return take(input, {
        CronExpressionForRecurrence: [],
        Duration: _json,
        StartAt: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_AutoTuneMaintenanceScheduleList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AutoTuneMaintenanceSchedule(entry, context);
    });
};
const se_AutoTuneOptions = (input, context) => {
    return take(input, {
        DesiredState: [],
        MaintenanceSchedules: (_) => se_AutoTuneMaintenanceScheduleList(_, context),
        RollbackOnDisable: [],
        UseOffPeakWindow: [],
    });
};
const se_AutoTuneOptionsInput = (input, context) => {
    return take(input, {
        DesiredState: [],
        MaintenanceSchedules: (_) => se_AutoTuneMaintenanceScheduleList(_, context),
        UseOffPeakWindow: [],
    });
};
const de_AccessPoliciesStatus = (output, context) => {
    return take(output, {
        Options: __expectString,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_AdvancedOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_AdvancedSecurityOptions = (output, context) => {
    return take(output, {
        AnonymousAuthDisableDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        AnonymousAuthEnabled: __expectBoolean,
        Enabled: __expectBoolean,
        InternalUserDatabaseEnabled: __expectBoolean,
        SAMLOptions: _json,
    });
};
const de_AdvancedSecurityOptionsStatus = (output, context) => {
    return take(output, {
        Options: (_) => de_AdvancedSecurityOptions(_, context),
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_AutoTune = (output, context) => {
    return take(output, {
        AutoTuneDetails: (_) => de_AutoTuneDetails(_, context),
        AutoTuneType: __expectString,
    });
};
const de_AutoTuneDetails = (output, context) => {
    return take(output, {
        ScheduledAutoTuneDetails: (_) => de_ScheduledAutoTuneDetails(_, context),
    });
};
const de_AutoTuneList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoTune(entry, context);
    });
    return retVal;
};
const de_AutoTuneMaintenanceSchedule = (output, context) => {
    return take(output, {
        CronExpressionForRecurrence: __expectString,
        Duration: _json,
        StartAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_AutoTuneMaintenanceScheduleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoTuneMaintenanceSchedule(entry, context);
    });
    return retVal;
};
const de_AutoTuneOptions = (output, context) => {
    return take(output, {
        DesiredState: __expectString,
        MaintenanceSchedules: (_) => de_AutoTuneMaintenanceScheduleList(_, context),
        RollbackOnDisable: __expectString,
        UseOffPeakWindow: __expectBoolean,
    });
};
const de_AutoTuneOptionsStatus = (output, context) => {
    return take(output, {
        Options: (_) => de_AutoTuneOptions(_, context),
        Status: (_) => de_AutoTuneStatus(_, context),
    });
};
const de_AutoTuneStatus = (output, context) => {
    return take(output, {
        CreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ErrorMessage: __expectString,
        PendingDeletion: __expectBoolean,
        State: __expectString,
        UpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        UpdateVersion: __expectInt32,
    });
};
const de_ChangeProgressDetails = (output, context) => {
    return take(output, {
        ChangeId: __expectString,
        ConfigChangeStatus: __expectString,
        InitiatedBy: __expectString,
        LastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Message: __expectString,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ChangeProgressStage = (output, context) => {
    return take(output, {
        Description: __expectString,
        LastUpdated: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Name: __expectString,
        Status: __expectString,
    });
};
const de_ChangeProgressStageList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ChangeProgressStage(entry, context);
    });
    return retVal;
};
const de_ChangeProgressStatusDetails = (output, context) => {
    return take(output, {
        ChangeId: __expectString,
        ChangeProgressStages: (_) => de_ChangeProgressStageList(_, context),
        CompletedProperties: _json,
        ConfigChangeStatus: __expectString,
        InitiatedBy: __expectString,
        LastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PendingProperties: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        TotalNumberOfStages: __expectInt32,
    });
};
const de_ClusterConfigStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_CognitoOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_DomainConfig = (output, context) => {
    return take(output, {
        AccessPolicies: (_) => de_AccessPoliciesStatus(_, context),
        AdvancedOptions: (_) => de_AdvancedOptionsStatus(_, context),
        AdvancedSecurityOptions: (_) => de_AdvancedSecurityOptionsStatus(_, context),
        AutoTuneOptions: (_) => de_AutoTuneOptionsStatus(_, context),
        ChangeProgressDetails: (_) => de_ChangeProgressDetails(_, context),
        ClusterConfig: (_) => de_ClusterConfigStatus(_, context),
        CognitoOptions: (_) => de_CognitoOptionsStatus(_, context),
        DomainEndpointOptions: (_) => de_DomainEndpointOptionsStatus(_, context),
        EBSOptions: (_) => de_EBSOptionsStatus(_, context),
        EncryptionAtRestOptions: (_) => de_EncryptionAtRestOptionsStatus(_, context),
        EngineVersion: (_) => de_VersionStatus(_, context),
        IPAddressType: (_) => de_IPAddressTypeStatus(_, context),
        LogPublishingOptions: (_) => de_LogPublishingOptionsStatus(_, context),
        ModifyingProperties: _json,
        NodeToNodeEncryptionOptions: (_) => de_NodeToNodeEncryptionOptionsStatus(_, context),
        OffPeakWindowOptions: (_) => de_OffPeakWindowOptionsStatus(_, context),
        SnapshotOptions: (_) => de_SnapshotOptionsStatus(_, context),
        SoftwareUpdateOptions: (_) => de_SoftwareUpdateOptionsStatus(_, context),
        VPCOptions: (_) => de_VPCDerivedInfoStatus(_, context),
    });
};
const de_DomainEndpointOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_DomainMaintenanceDetails = (output, context) => {
    return take(output, {
        Action: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DomainName: __expectString,
        MaintenanceId: __expectString,
        NodeId: __expectString,
        Status: __expectString,
        StatusMessage: __expectString,
        UpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_DomainMaintenanceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainMaintenanceDetails(entry, context);
    });
    return retVal;
};
const de_DomainPackageDetails = (output, context) => {
    return take(output, {
        DomainName: __expectString,
        DomainPackageStatus: __expectString,
        ErrorDetails: _json,
        LastUpdated: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PackageID: __expectString,
        PackageName: __expectString,
        PackageType: __expectString,
        PackageVersion: __expectString,
        ReferencePath: __expectString,
    });
};
const de_DomainPackageDetailsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainPackageDetails(entry, context);
    });
    return retVal;
};
const de_DomainStatus = (output, context) => {
    return take(output, {
        ARN: __expectString,
        AccessPolicies: __expectString,
        AdvancedOptions: _json,
        AdvancedSecurityOptions: (_) => de_AdvancedSecurityOptions(_, context),
        AutoTuneOptions: _json,
        ChangeProgressDetails: (_) => de_ChangeProgressDetails(_, context),
        ClusterConfig: _json,
        CognitoOptions: _json,
        Created: __expectBoolean,
        Deleted: __expectBoolean,
        DomainEndpointOptions: _json,
        DomainId: __expectString,
        DomainName: __expectString,
        DomainProcessingStatus: __expectString,
        EBSOptions: _json,
        EncryptionAtRestOptions: _json,
        Endpoint: __expectString,
        EndpointV2: __expectString,
        Endpoints: _json,
        EngineVersion: __expectString,
        IPAddressType: __expectString,
        LogPublishingOptions: _json,
        ModifyingProperties: _json,
        NodeToNodeEncryptionOptions: _json,
        OffPeakWindowOptions: _json,
        Processing: __expectBoolean,
        ServiceSoftwareOptions: (_) => de_ServiceSoftwareOptions(_, context),
        SnapshotOptions: _json,
        SoftwareUpdateOptions: _json,
        UpgradeProcessing: __expectBoolean,
        VPCOptions: _json,
    });
};
const de_DomainStatusList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainStatus(entry, context);
    });
    return retVal;
};
const de_EBSOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_EncryptionAtRestOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_IPAddressTypeStatus = (output, context) => {
    return take(output, {
        Options: __expectString,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_LogPublishingOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_NodeToNodeEncryptionOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_OffPeakWindowOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_OptionStatus = (output, context) => {
    return take(output, {
        CreationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PendingDeletion: __expectBoolean,
        State: __expectString,
        UpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        UpdateVersion: __expectInt32,
    });
};
const de_PackageDetails = (output, context) => {
    return take(output, {
        AvailablePackageVersion: __expectString,
        AvailablePluginProperties: _json,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        EngineVersion: __expectString,
        ErrorDetails: _json,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PackageDescription: __expectString,
        PackageID: __expectString,
        PackageName: __expectString,
        PackageStatus: __expectString,
        PackageType: __expectString,
    });
};
const de_PackageDetailsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageDetails(entry, context);
    });
    return retVal;
};
const de_PackageVersionHistory = (output, context) => {
    return take(output, {
        CommitMessage: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PackageVersion: __expectString,
        PluginProperties: _json,
    });
};
const de_PackageVersionHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageVersionHistory(entry, context);
    });
    return retVal;
};
const de_RecurringCharge = (output, context) => {
    return take(output, {
        RecurringChargeAmount: __limitedParseDouble,
        RecurringChargeFrequency: __expectString,
    });
};
const de_RecurringChargeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecurringCharge(entry, context);
    });
    return retVal;
};
const de_ReservedInstance = (output, context) => {
    return take(output, {
        BillingSubscriptionId: __expectLong,
        CurrencyCode: __expectString,
        Duration: __expectInt32,
        FixedPrice: __limitedParseDouble,
        InstanceCount: __expectInt32,
        InstanceType: __expectString,
        PaymentOption: __expectString,
        RecurringCharges: (_) => de_RecurringChargeList(_, context),
        ReservationName: __expectString,
        ReservedInstanceId: __expectString,
        ReservedInstanceOfferingId: __expectString,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        State: __expectString,
        UsagePrice: __limitedParseDouble,
    });
};
const de_ReservedInstanceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstance(entry, context);
    });
    return retVal;
};
const de_ReservedInstanceOffering = (output, context) => {
    return take(output, {
        CurrencyCode: __expectString,
        Duration: __expectInt32,
        FixedPrice: __limitedParseDouble,
        InstanceType: __expectString,
        PaymentOption: __expectString,
        RecurringCharges: (_) => de_RecurringChargeList(_, context),
        ReservedInstanceOfferingId: __expectString,
        UsagePrice: __limitedParseDouble,
    });
};
const de_ReservedInstanceOfferingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstanceOffering(entry, context);
    });
    return retVal;
};
const de_ScheduledAutoTuneDetails = (output, context) => {
    return take(output, {
        Action: __expectString,
        ActionType: __expectString,
        Date: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Severity: __expectString,
    });
};
const de_ServiceSoftwareOptions = (output, context) => {
    return take(output, {
        AutomatedUpdateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Cancellable: __expectBoolean,
        CurrentVersion: __expectString,
        Description: __expectString,
        NewVersion: __expectString,
        OptionalDeployment: __expectBoolean,
        UpdateAvailable: __expectBoolean,
        UpdateStatus: __expectString,
    });
};
const de_SnapshotOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_SoftwareUpdateOptionsStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_UpgradeHistory = (output, context) => {
    return take(output, {
        StartTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        StepsList: (_) => de_UpgradeStepsList(_, context),
        UpgradeName: __expectString,
        UpgradeStatus: __expectString,
    });
};
const de_UpgradeHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UpgradeHistory(entry, context);
    });
    return retVal;
};
const de_UpgradeStepItem = (output, context) => {
    return take(output, {
        Issues: _json,
        ProgressPercent: __limitedParseDouble,
        UpgradeStep: __expectString,
        UpgradeStepStatus: __expectString,
    });
};
const de_UpgradeStepsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UpgradeStepItem(entry, context);
    });
    return retVal;
};
const de_VersionStatus = (output, context) => {
    return take(output, {
        Options: __expectString,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const de_VPCDerivedInfoStatus = (output, context) => {
    return take(output, {
        Options: _json,
        Status: (_) => de_OptionStatus(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _A = "Action";
const _ARN = "ARN";
const _CI = "ChangeId";
const _DN = "DomainName";
const _DRI = "DryRunId";
const _ET = "EngineType";
const _IT = "InstanceType";
const _LDRC = "LoadDryRunConfig";
const _MI = "MaintenanceId";
const _MR = "MaxResults";
const _NT = "NextToken";
const _RAZ = "RetrieveAZs";
const _RII = "ReservedInstanceId";
const _RIOI = "ReservedInstanceOfferingId";
const _S = "Status";
const _a = "action";
const _ar = "arn";
const _c = "changeid";
const _dN = "domainName";
const _dRI = "dryRunId";
const _eT = "engineType";
const _iT = "instanceType";
const _lDRC = "loadDryRunConfig";
const _mI = "maintenanceId";
const _mR = "maxResults";
const _nT = "nextToken";
const _oI = "offeringId";
const _rAZ = "retrieveAZs";
const _rI = "reservationId";
const _s = "status";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
