import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, withBaseException, } from "@smithy/smithy-client";
import { AutoScalingServiceException as __BaseException } from "../models/AutoScalingServiceException";
import { ActiveInstanceRefreshNotFoundFault, AlreadyExistsFault, InstanceRefreshInProgressFault, InvalidNextToken, IrreversibleInstanceRefreshFault, LimitExceededFault, ResourceContentionFault, ResourceInUseFault, ScalingActivityInProgressFault, ServiceLinkedRoleFailure, } from "../models/models_0";
export const se_AttachInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachInstancesQuery(input, context),
        [_A]: _AI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachLoadBalancersType(input, context),
        [_A]: _ALB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachLoadBalancerTargetGroupsType(input, context),
        [_A]: _ALBTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachTrafficSourcesType(input, context),
        [_A]: _ATS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchDeleteScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchDeleteScheduledActionType(input, context),
        [_A]: _BDSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchPutScheduledUpdateGroupActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchPutScheduledUpdateGroupActionType(input, context),
        [_A]: _BPSUGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelInstanceRefreshType(input, context),
        [_A]: _CIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CompleteLifecycleActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CompleteLifecycleActionType(input, context),
        [_A]: _CLA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAutoScalingGroupType(input, context),
        [_A]: _CASG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLaunchConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLaunchConfigurationType(input, context),
        [_A]: _CLC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateOrUpdateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateOrUpdateTagsType(input, context),
        [_A]: _COUT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAutoScalingGroupType(input, context),
        [_A]: _DASG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLaunchConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_LaunchConfigurationNameType(input, context),
        [_A]: _DLC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLifecycleHookCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLifecycleHookType(input, context),
        [_A]: _DLH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNotificationConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNotificationConfigurationType(input, context),
        [_A]: _DNC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyType(input, context),
        [_A]: _DP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteScheduledActionType(input, context),
        [_A]: _DSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTagsType(input, context),
        [_A]: _DT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteWarmPoolType(input, context),
        [_A]: _DWP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DAL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAdjustmentTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DAT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AutoScalingGroupNamesType(input, context),
        [_A]: _DASGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAutoScalingInstancesType(input, context),
        [_A]: _DASI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingNotificationTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DASNT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceRefreshesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceRefreshesType(input, context),
        [_A]: _DIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLaunchConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_LaunchConfigurationNamesType(input, context),
        [_A]: _DLCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLifecycleHooksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLifecycleHooksType(input, context),
        [_A]: _DLHe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLifecycleHookTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DLHT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancersRequest(input, context),
        [_A]: _DLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerTargetGroupsRequest(input, context),
        [_A]: _DLBTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMetricCollectionTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DMCT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNotificationConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNotificationConfigurationsType(input, context),
        [_A]: _DNCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePoliciesType(input, context),
        [_A]: _DPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScalingActivitiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScalingActivitiesType(input, context),
        [_A]: _DSAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScalingProcessTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DSPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScheduledActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScheduledActionsType(input, context),
        [_A]: _DSAes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsType(input, context),
        [_A]: _DTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTerminationPolicyTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DTPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficSourcesRequest(input, context),
        [_A]: _DTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeWarmPoolType(input, context),
        [_A]: _DWPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachInstancesQuery(input, context),
        [_A]: _DI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachLoadBalancersType(input, context),
        [_A]: _DLBe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachLoadBalancerTargetGroupsType(input, context),
        [_A]: _DLBTGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachTrafficSourcesType(input, context),
        [_A]: _DTSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableMetricsCollectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableMetricsCollectionQuery(input, context),
        [_A]: _DMC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableMetricsCollectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableMetricsCollectionQuery(input, context),
        [_A]: _EMC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnterStandbyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnterStandbyQuery(input, context),
        [_A]: _ES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExecutePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExecutePolicyType(input, context),
        [_A]: _EP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExitStandbyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExitStandbyQuery(input, context),
        [_A]: _ESx,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPredictiveScalingForecastCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPredictiveScalingForecastType(input, context),
        [_A]: _GPSF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutLifecycleHookCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutLifecycleHookType(input, context),
        [_A]: _PLH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutNotificationConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutNotificationConfigurationType(input, context),
        [_A]: _PNC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutScalingPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutScalingPolicyType(input, context),
        [_A]: _PSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutScheduledUpdateGroupActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutScheduledUpdateGroupActionType(input, context),
        [_A]: _PSUGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutWarmPoolType(input, context),
        [_A]: _PWP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RecordLifecycleActionHeartbeatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RecordLifecycleActionHeartbeatType(input, context),
        [_A]: _RLAH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResumeProcessesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ScalingProcessQuery(input, context),
        [_A]: _RP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RollbackInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RollbackInstanceRefreshType(input, context),
        [_A]: _RIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetDesiredCapacityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetDesiredCapacityType(input, context),
        [_A]: _SDC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetInstanceHealthCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetInstanceHealthQuery(input, context),
        [_A]: _SIH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetInstanceProtectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetInstanceProtectionQuery(input, context),
        [_A]: _SIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartInstanceRefreshType(input, context),
        [_A]: _SIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SuspendProcessesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ScalingProcessQuery(input, context),
        [_A]: _SP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TerminateInstanceInAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TerminateInstanceInAutoScalingGroupType(input, context),
        [_A]: _TIIASG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAutoScalingGroupType(input, context),
        [_A]: _UASG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AttachInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_AttachLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachLoadBalancersResultType(data.AttachLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachLoadBalancerTargetGroupsResultType(data.AttachLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachTrafficSourcesResultType(data.AttachTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchDeleteScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchDeleteScheduledActionAnswer(data.BatchDeleteScheduledActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchPutScheduledUpdateGroupActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchPutScheduledUpdateGroupActionAnswer(data.BatchPutScheduledUpdateGroupActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelInstanceRefreshAnswer(data.CancelInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CompleteLifecycleActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CompleteLifecycleActionAnswer(data.CompleteLifecycleActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateOrUpdateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteLifecycleHookCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLifecycleHookAnswer(data.DeleteLifecycleHookResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteWarmPoolAnswer(data.DeleteWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAccountLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountLimitsAnswer(data.DescribeAccountLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAdjustmentTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAdjustmentTypesAnswer(data.DescribeAdjustmentTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAutoScalingGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AutoScalingGroupsType(data.DescribeAutoScalingGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAutoScalingInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AutoScalingInstancesType(data.DescribeAutoScalingInstancesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAutoScalingNotificationTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAutoScalingNotificationTypesAnswer(data.DescribeAutoScalingNotificationTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceRefreshesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceRefreshesAnswer(data.DescribeInstanceRefreshesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLaunchConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LaunchConfigurationsType(data.DescribeLaunchConfigurationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLifecycleHooksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLifecycleHooksAnswer(data.DescribeLifecycleHooksResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLifecycleHookTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLifecycleHookTypesAnswer(data.DescribeLifecycleHookTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancersResponse(data.DescribeLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerTargetGroupsResponse(data.DescribeLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeMetricCollectionTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMetricCollectionTypesAnswer(data.DescribeMetricCollectionTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNotificationConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNotificationConfigurationsAnswer(data.DescribeNotificationConfigurationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PoliciesType(data.DescribePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScalingActivitiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ActivitiesType(data.DescribeScalingActivitiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScalingProcessTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProcessesType(data.DescribeScalingProcessTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScheduledActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduledActionsType(data.DescribeScheduledActionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagsType(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTerminationPolicyTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTerminationPolicyTypesAnswer(data.DescribeTerminationPolicyTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficSourcesResponse(data.DescribeTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeWarmPoolAnswer(data.DescribeWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachInstancesAnswer(data.DetachInstancesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachLoadBalancersResultType(data.DetachLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachLoadBalancerTargetGroupsResultType(data.DetachLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachTrafficSourcesResultType(data.DetachTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableMetricsCollectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_EnableMetricsCollectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_EnterStandbyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnterStandbyAnswer(data.EnterStandbyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExecutePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ExitStandbyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExitStandbyAnswer(data.ExitStandbyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetPredictiveScalingForecastCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPredictiveScalingForecastAnswer(data.GetPredictiveScalingForecastResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutLifecycleHookCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutLifecycleHookAnswer(data.PutLifecycleHookResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_PutScalingPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PolicyARNType(data.PutScalingPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutScheduledUpdateGroupActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_PutWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutWarmPoolAnswer(data.PutWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RecordLifecycleActionHeartbeatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RecordLifecycleActionHeartbeatAnswer(data.RecordLifecycleActionHeartbeatResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResumeProcessesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_RollbackInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RollbackInstanceRefreshAnswer(data.RollbackInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetDesiredCapacityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_SetInstanceHealthCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_SetInstanceProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetInstanceProtectionAnswer(data.SetInstanceProtectionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartInstanceRefreshAnswer(data.StartInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SuspendProcessesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_TerminateInstanceInAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ActivityType(data.TerminateInstanceInAutoScalingGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ActiveInstanceRefreshNotFound":
        case "com.amazonaws.autoscaling#ActiveInstanceRefreshNotFoundFault":
            throw await de_ActiveInstanceRefreshNotFoundFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "IrreversibleInstanceRefresh":
        case "com.amazonaws.autoscaling#IrreversibleInstanceRefreshFault":
            throw await de_IrreversibleInstanceRefreshFaultRes(parsedOutput, context);
        case "InstanceRefreshInProgress":
        case "com.amazonaws.autoscaling#InstanceRefreshInProgressFault":
            throw await de_InstanceRefreshInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ActiveInstanceRefreshNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ActiveInstanceRefreshNotFoundFault(body.Error, context);
    const exception = new ActiveInstanceRefreshNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AlreadyExistsFault(body.Error, context);
    const exception = new AlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InstanceRefreshInProgressFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InstanceRefreshInProgressFault(body.Error, context);
    const exception = new InstanceRefreshInProgressFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body.Error, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IrreversibleInstanceRefreshFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IrreversibleInstanceRefreshFault(body.Error, context);
    const exception = new IrreversibleInstanceRefreshFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceContentionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceContentionFault(body.Error, context);
    const exception = new ResourceContentionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceInUseFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseFault(body.Error, context);
    const exception = new ResourceInUseFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScalingActivityInProgressFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScalingActivityInProgressFault(body.Error, context);
    const exception = new ScalingActivityInProgressFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceLinkedRoleFailureRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceLinkedRoleFailure(body.Error, context);
    const exception = new ServiceLinkedRoleFailure({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AcceleratorCountRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorManufacturers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorTotalMemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ActivityIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AlarmList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AlarmSpecification = (input, context) => {
    const entries = {};
    if (input[_Al] != null) {
        const memberEntries = se_AlarmList(input[_Al], context);
        if (input[_Al]?.length === 0) {
            entries.Alarms = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Alarms.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AllowedInstanceTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AttachInstancesQuery = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    return entries;
};
const se_AttachLoadBalancersType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LBN] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBN], context);
        if (input[_LBN]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachLoadBalancerTargetGroupsType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TGARN] != null) {
        const memberEntries = se_TargetGroupARNs(input[_TGARN], context);
        if (input[_TGARN]?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachTrafficSourcesType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TrafficSources(input[_TS], context);
        if (input[_TS]?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AutoScalingGroupNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AutoScalingGroupNamesType = (input, context) => {
    const entries = {};
    if (input[_ASGNu] != null) {
        const memberEntries = se_AutoScalingGroupNames(input[_ASGNu], context);
        if (input[_ASGNu]?.length === 0) {
            entries.AutoScalingGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AutoScalingGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_F] != null) {
        const memberEntries = se_Filters(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AutoScalingNotificationTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AvailabilityZones = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BaselineEbsBandwidthMbpsRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_BatchDeleteScheduledActionType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SAN] != null) {
        const memberEntries = se_ScheduledActionNames(input[_SAN], context);
        if (input[_SAN]?.length === 0) {
            entries.ScheduledActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledActionNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BatchPutScheduledUpdateGroupActionType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SUGA] != null) {
        const memberEntries = se_ScheduledUpdateGroupActionRequests(input[_SUGA], context);
        if (input[_SUGA]?.length === 0) {
            entries.ScheduledUpdateGroupActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledUpdateGroupActions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_E] != null) {
        const memberEntries = se_Ebs(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    return entries;
};
const se_BlockDeviceMappings = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_BlockDeviceMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CancelInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    return entries;
};
const se_CheckpointPercentages = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ClassicLinkVPCSecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CompleteLifecycleActionType = (input, context) => {
    const entries = {};
    if (input[_LHN] != null) {
        entries[_LHN] = input[_LHN];
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LAT] != null) {
        entries[_LAT] = input[_LAT];
    }
    if (input[_LAR] != null) {
        entries[_LAR] = input[_LAR];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    return entries;
};
const se_CpuManufacturers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LCN] != null) {
        entries[_LCN] = input[_LCN];
    }
    if (input[_LT] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MIP] != null) {
        const memberEntries = se_MixedInstancesPolicy(input[_MIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_MS] != null) {
        entries[_MS] = input[_MS];
    }
    if (input[_MSa] != null) {
        entries[_MSa] = input[_MSa];
    }
    if (input[_DC] != null) {
        entries[_DC] = input[_DC];
    }
    if (input[_DCe] != null) {
        entries[_DCe] = input[_DCe];
    }
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LBN] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBN], context);
        if (input[_LBN]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TGARN] != null) {
        const memberEntries = se_TargetGroupARNs(input[_TGARN], context);
        if (input[_TGARN]?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HCT] != null) {
        entries[_HCT] = input[_HCT];
    }
    if (input[_HCGP] != null) {
        entries[_HCGP] = input[_HCGP];
    }
    if (input[_PG] != null) {
        entries[_PG] = input[_PG];
    }
    if (input[_VPCZI] != null) {
        entries[_VPCZI] = input[_VPCZI];
    }
    if (input[_TP] != null) {
        const memberEntries = se_TerminationPolicies(input[_TP], context);
        if (input[_TP]?.length === 0) {
            entries.TerminationPolicies = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TerminationPolicies.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NIPFSI] != null) {
        entries[_NIPFSI] = input[_NIPFSI];
    }
    if (input[_CR] != null) {
        entries[_CR] = input[_CR];
    }
    if (input[_LHSL] != null) {
        const memberEntries = se_LifecycleHookSpecifications(input[_LHSL], context);
        if (input[_LHSL]?.length === 0) {
            entries.LifecycleHookSpecificationList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LifecycleHookSpecificationList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_Tags(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SLRARN] != null) {
        entries[_SLRARN] = input[_SLRARN];
    }
    if (input[_MIL] != null) {
        entries[_MIL] = input[_MIL];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_DCT] != null) {
        entries[_DCT] = input[_DCT];
    }
    if (input[_DIW] != null) {
        entries[_DIW] = input[_DIW];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TrafficSources(input[_TS], context);
        if (input[_TS]?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IMP] != null) {
        const memberEntries = se_InstanceMaintenancePolicy(input[_IMP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMaintenancePolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLaunchConfigurationType = (input, context) => {
    const entries = {};
    if (input[_LCN] != null) {
        entries[_LCN] = input[_LCN];
    }
    if (input[_IIm] != null) {
        entries[_IIm] = input[_IIm];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroups(input[_SG], context);
        if (input[_SG]?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CLVPCI] != null) {
        entries[_CLVPCI] = input[_CLVPCI];
    }
    if (input[_CLVPCSG] != null) {
        const memberEntries = se_ClassicLinkVPCSecurityGroups(input[_CLVPCSG], context);
        if (input[_CLVPCSG]?.length === 0) {
            entries.ClassicLinkVPCSecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClassicLinkVPCSecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_RI] != null) {
        entries[_RI] = input[_RI];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappings(input[_BDM], context);
        if (input[_BDM]?.length === 0) {
            entries.BlockDeviceMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IM] != null) {
        const memberEntries = se_InstanceMonitoring(input[_IM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMonitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SPp] != null) {
        entries[_SPp] = input[_SPp];
    }
    if (input[_IIP] != null) {
        entries[_IIP] = input[_IIP];
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_APIA] != null) {
        entries[_APIA] = input[_APIA];
    }
    if (input[_PT] != null) {
        entries[_PT] = input[_PT];
    }
    if (input[_MO] != null) {
        const memberEntries = se_InstanceMetadataOptions(input[_MO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateOrUpdateTagsType = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        const memberEntries = se_Tags(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CustomizedMetricSpecification = (input, context) => {
    const entries = {};
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_D] != null) {
        const memberEntries = se_MetricDimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_Me] != null) {
        const memberEntries = se_TargetTrackingMetricDataQueries(input[_Me], context);
        if (input[_Me]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_FD] != null) {
        entries[_FD] = input[_FD];
    }
    return entries;
};
const se_DeleteLifecycleHookType = (input, context) => {
    const entries = {};
    if (input[_LHN] != null) {
        entries[_LHN] = input[_LHN];
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    return entries;
};
const se_DeleteNotificationConfigurationType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TARN] != null) {
        entries[_TARN] = input[_TARN];
    }
    return entries;
};
const se_DeletePolicyType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DeleteScheduledActionType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SANc] != null) {
        entries[_SANc] = input[_SANc];
    }
    return entries;
};
const se_DeleteTagsType = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        const memberEntries = se_Tags(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteWarmPoolType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_FD] != null) {
        entries[_FD] = input[_FD];
    }
    return entries;
};
const se_DescribeAutoScalingInstancesType = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInstanceRefreshesType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_IRI] != null) {
        const memberEntries = se_InstanceRefreshIds(input[_IRI], context);
        if (input[_IRI]?.length === 0) {
            entries.InstanceRefreshIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRefreshIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeLifecycleHooksType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LHNi] != null) {
        const memberEntries = se_LifecycleHookNames(input[_LHNi], context);
        if (input[_LHNi]?.length === 0) {
            entries.LifecycleHookNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LifecycleHookNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeLoadBalancersRequest = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeLoadBalancerTargetGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeNotificationConfigurationsType = (input, context) => {
    const entries = {};
    if (input[_ASGNu] != null) {
        const memberEntries = se_AutoScalingGroupNames(input[_ASGNu], context);
        if (input[_ASGNu]?.length === 0) {
            entries.AutoScalingGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AutoScalingGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribePoliciesType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PNo] != null) {
        const memberEntries = se_PolicyNames(input[_PNo], context);
        if (input[_PNo]?.length === 0) {
            entries.PolicyNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PTo] != null) {
        const memberEntries = se_PolicyTypes(input[_PTo], context);
        if (input[_PTo]?.length === 0) {
            entries.PolicyTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeScalingActivitiesType = (input, context) => {
    const entries = {};
    if (input[_AIc] != null) {
        const memberEntries = se_ActivityIds(input[_AIc], context);
        if (input[_AIc]?.length === 0) {
            entries.ActivityIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActivityIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_IDG] != null) {
        entries[_IDG] = input[_IDG];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeScheduledActionsType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SAN] != null) {
        const memberEntries = se_ScheduledActionNames(input[_SAN], context);
        if (input[_SAN]?.length === 0) {
            entries.ScheduledActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeTagsType = (input, context) => {
    const entries = {};
    if (input[_F] != null) {
        const memberEntries = se_Filters(input[_F], context);
        if (input[_F]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeTrafficSourcesRequest = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TST] != null) {
        entries[_TST] = input[_TST];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeWarmPoolType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DesiredConfiguration = (input, context) => {
    const entries = {};
    if (input[_LT] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MIP] != null) {
        const memberEntries = se_MixedInstancesPolicy(input[_MIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachInstancesQuery = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SDDC] != null) {
        entries[_SDDC] = input[_SDDC];
    }
    return entries;
};
const se_DetachLoadBalancersType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LBN] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBN], context);
        if (input[_LBN]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachLoadBalancerTargetGroupsType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TGARN] != null) {
        const memberEntries = se_TargetGroupARNs(input[_TGARN], context);
        if (input[_TGARN]?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachTrafficSourcesType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TrafficSources(input[_TS], context);
        if (input[_TS]?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableMetricsCollectionQuery = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_Me] != null) {
        const memberEntries = se_Metrics(input[_Me], context);
        if (input[_Me]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Ebs = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_VS] != null) {
        entries[_VS] = input[_VS];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    return entries;
};
const se_EnableMetricsCollectionQuery = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_Me] != null) {
        const memberEntries = se_Metrics(input[_Me], context);
        if (input[_Me]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_G] != null) {
        entries[_G] = input[_G];
    }
    return entries;
};
const se_EnterStandbyQuery = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SDDC] != null) {
        entries[_SDDC] = input[_SDDC];
    }
    return entries;
};
const se_ExcludedInstanceTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExecutePolicyType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_HC] != null) {
        entries[_HC] = input[_HC];
    }
    if (input[_MV] != null) {
        entries[_MV] = __serializeFloat(input[_MV]);
    }
    if (input[_BT] != null) {
        entries[_BT] = __serializeFloat(input[_BT]);
    }
    return entries;
};
const se_ExitStandbyQuery = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    return entries;
};
const se_Filter = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Va] != null) {
        const memberEntries = se_Values(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Filters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Filter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_GetPredictiveScalingForecastType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const se_InstanceGenerations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceMaintenancePolicy = (input, context) => {
    const entries = {};
    if (input[_MHP] != null) {
        entries[_MHP] = input[_MHP];
    }
    if (input[_MHPa] != null) {
        entries[_MHPa] = input[_MHPa];
    }
    return entries;
};
const se_InstanceMetadataOptions = (input, context) => {
    const entries = {};
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    if (input[_HPRHL] != null) {
        entries[_HPRHL] = input[_HPRHL];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    return entries;
};
const se_InstanceMonitoring = (input, context) => {
    const entries = {};
    if (input[_Ena] != null) {
        entries[_Ena] = input[_Ena];
    }
    return entries;
};
const se_InstanceRefreshIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceRequirements = (input, context) => {
    const entries = {};
    if (input[_VCC] != null) {
        const memberEntries = se_VCpuCountRequest(input[_VCC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VCpuCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMB] != null) {
        const memberEntries = se_MemoryMiBRequest(input[_MMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CM] != null) {
        const memberEntries = se_CpuManufacturers(input[_CM], context);
        if (input[_CM]?.length === 0) {
            entries.CpuManufacturers = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuManufacturers.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MGBPVC] != null) {
        const memberEntries = se_MemoryGiBPerVCpuRequest(input[_MGBPVC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryGiBPerVCpu.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EIT] != null) {
        const memberEntries = se_ExcludedInstanceTypes(input[_EIT], context);
        if (input[_EIT]?.length === 0) {
            entries.ExcludedInstanceTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedInstanceTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IG] != null) {
        const memberEntries = se_InstanceGenerations(input[_IG], context);
        if (input[_IG]?.length === 0) {
            entries.InstanceGenerations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceGenerations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SMPPOLP] != null) {
        entries[_SMPPOLP] = input[_SMPPOLP];
    }
    if (input[_MSPAPOOODP] != null) {
        entries[_MSPAPOOODP] = input[_MSPAPOOODP];
    }
    if (input[_ODMPPOLP] != null) {
        entries[_ODMPPOLP] = input[_ODMPPOLP];
    }
    if (input[_BM] != null) {
        entries[_BM] = input[_BM];
    }
    if (input[_BP] != null) {
        entries[_BP] = input[_BP];
    }
    if (input[_RHS] != null) {
        entries[_RHS] = input[_RHS];
    }
    if (input[_NIC] != null) {
        const memberEntries = se_NetworkInterfaceCountRequest(input[_NIC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LS] != null) {
        entries[_LS] = input[_LS];
    }
    if (input[_LST] != null) {
        const memberEntries = se_LocalStorageTypes(input[_LST], context);
        if (input[_LST]?.length === 0) {
            entries.LocalStorageTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalStorageTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TLSGB] != null) {
        const memberEntries = se_TotalLocalStorageGBRequest(input[_TLSGB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TotalLocalStorageGB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BEBM] != null) {
        const memberEntries = se_BaselineEbsBandwidthMbpsRequest(input[_BEBM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselineEbsBandwidthMbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AT] != null) {
        const memberEntries = se_AcceleratorTypes(input[_AT], context);
        if (input[_AT]?.length === 0) {
            entries.AcceleratorTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AC] != null) {
        const memberEntries = se_AcceleratorCountRequest(input[_AC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AM] != null) {
        const memberEntries = se_AcceleratorManufacturers(input[_AM], context);
        if (input[_AM]?.length === 0) {
            entries.AcceleratorManufacturers = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorManufacturers.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AN] != null) {
        const memberEntries = se_AcceleratorNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AcceleratorNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ATMMB] != null) {
        const memberEntries = se_AcceleratorTotalMemoryMiBRequest(input[_ATMMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTotalMemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NBG] != null) {
        const memberEntries = se_NetworkBandwidthGbpsRequest(input[_NBG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkBandwidthGbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AIT] != null) {
        const memberEntries = se_AllowedInstanceTypes(input[_AIT], context);
        if (input[_AIT]?.length === 0) {
            entries.AllowedInstanceTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllowedInstanceTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceReusePolicy = (input, context) => {
    const entries = {};
    if (input[_ROSI] != null) {
        entries[_ROSI] = input[_ROSI];
    }
    return entries;
};
const se_InstancesDistribution = (input, context) => {
    const entries = {};
    if (input[_ODAS] != null) {
        entries[_ODAS] = input[_ODAS];
    }
    if (input[_ODBC] != null) {
        entries[_ODBC] = input[_ODBC];
    }
    if (input[_ODPABC] != null) {
        entries[_ODPABC] = input[_ODPABC];
    }
    if (input[_SAS] != null) {
        entries[_SAS] = input[_SAS];
    }
    if (input[_SIPp] != null) {
        entries[_SIPp] = input[_SIPp];
    }
    if (input[_SMP] != null) {
        entries[_SMP] = input[_SMP];
    }
    return entries;
};
const se_LaunchConfigurationNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LaunchConfigurationNamesType = (input, context) => {
    const entries = {};
    if (input[_LCNa] != null) {
        const memberEntries = se_LaunchConfigurationNames(input[_LCNa], context);
        if (input[_LCNa]?.length === 0) {
            entries.LaunchConfigurationNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchConfigurationNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_LaunchConfigurationNameType = (input, context) => {
    const entries = {};
    if (input[_LCN] != null) {
        entries[_LCN] = input[_LCN];
    }
    return entries;
};
const se_LaunchTemplate = (input, context) => {
    const entries = {};
    if (input[_LTS] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_O] != null) {
        const memberEntries = se_Overrides(input[_O], context);
        if (input[_O]?.length === 0) {
            entries.Overrides = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Overrides.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateOverrides = (input, context) => {
    const entries = {};
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_WC] != null) {
        entries[_WC] = input[_WC];
    }
    if (input[_LTS] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirements(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_V] != null) {
        entries[_V] = input[_V];
    }
    return entries;
};
const se_LifecycleHookNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LifecycleHookSpecification = (input, context) => {
    const entries = {};
    if (input[_LHN] != null) {
        entries[_LHN] = input[_LHN];
    }
    if (input[_LTi] != null) {
        entries[_LTi] = input[_LTi];
    }
    if (input[_NM] != null) {
        entries[_NM] = input[_NM];
    }
    if (input[_HTe] != null) {
        entries[_HTe] = input[_HTe];
    }
    if (input[_DR] != null) {
        entries[_DR] = input[_DR];
    }
    if (input[_NTARN] != null) {
        entries[_NTARN] = input[_NTARN];
    }
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    return entries;
};
const se_LifecycleHookSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LifecycleHookSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadBalancerNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalStorageTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MemoryGiBPerVCpuRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_MemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_Metric = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_MetricDimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQuery = (input, context) => {
    const entries = {};
    if (input[_Id] != null) {
        entries[_Id] = input[_Id];
    }
    if (input[_Ex] != null) {
        entries[_Ex] = input[_Ex];
    }
    if (input[_MSe] != null) {
        const memberEntries = se_MetricStat(input[_MSe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_L] != null) {
        entries[_L] = input[_L];
    }
    if (input[_RD] != null) {
        entries[_RD] = input[_RD];
    }
    return entries;
};
const se_MetricDimension = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_MetricDimensions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDimension(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Metrics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStat = (input, context) => {
    const entries = {};
    if (input[_Met] != null) {
        const memberEntries = se_Metric(input[_Met], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_MixedInstancesPolicy = (input, context) => {
    const entries = {};
    if (input[_LT] != null) {
        const memberEntries = se_LaunchTemplate(input[_LT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ID] != null) {
        const memberEntries = se_InstancesDistribution(input[_ID], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstancesDistribution.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_NetworkBandwidthGbpsRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_NetworkInterfaceCountRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_Overrides = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateOverrides(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PolicyTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PredefinedMetricSpecification = (input, context) => {
    const entries = {};
    if (input[_PMT] != null) {
        entries[_PMT] = input[_PMT];
    }
    if (input[_RL] != null) {
        entries[_RL] = input[_RL];
    }
    return entries;
};
const se_PredictiveScalingConfiguration = (input, context) => {
    const entries = {};
    if (input[_MSet] != null) {
        const memberEntries = se_PredictiveScalingMetricSpecifications(input[_MSet], context);
        if (input[_MSet]?.length === 0) {
            entries.MetricSpecifications = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricSpecifications.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Mo] != null) {
        entries[_Mo] = input[_Mo];
    }
    if (input[_SBT] != null) {
        entries[_SBT] = input[_SBT];
    }
    if (input[_MCBB] != null) {
        entries[_MCBB] = input[_MCBB];
    }
    if (input[_MCB] != null) {
        entries[_MCB] = input[_MCB];
    }
    return entries;
};
const se_PredictiveScalingCustomizedCapacityMetric = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingCustomizedLoadMetric = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingCustomizedScalingMetric = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingMetricSpecification = (input, context) => {
    const entries = {};
    if (input[_TV] != null) {
        entries[_TV] = __serializeFloat(input[_TV]);
    }
    if (input[_PMPS] != null) {
        const memberEntries = se_PredictiveScalingPredefinedMetricPair(input[_PMPS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedMetricPairSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PSMS] != null) {
        const memberEntries = se_PredictiveScalingPredefinedScalingMetric(input[_PSMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedScalingMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PLMS] != null) {
        const memberEntries = se_PredictiveScalingPredefinedLoadMetric(input[_PLMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedLoadMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CSMS] != null) {
        const memberEntries = se_PredictiveScalingCustomizedScalingMetric(input[_CSMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedScalingMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CLMS] != null) {
        const memberEntries = se_PredictiveScalingCustomizedLoadMetric(input[_CLMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedLoadMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CCMS] != null) {
        const memberEntries = se_PredictiveScalingCustomizedCapacityMetric(input[_CCMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedCapacityMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingMetricSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PredictiveScalingMetricSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PredictiveScalingPredefinedLoadMetric = (input, context) => {
    const entries = {};
    if (input[_PMT] != null) {
        entries[_PMT] = input[_PMT];
    }
    if (input[_RL] != null) {
        entries[_RL] = input[_RL];
    }
    return entries;
};
const se_PredictiveScalingPredefinedMetricPair = (input, context) => {
    const entries = {};
    if (input[_PMT] != null) {
        entries[_PMT] = input[_PMT];
    }
    if (input[_RL] != null) {
        entries[_RL] = input[_RL];
    }
    return entries;
};
const se_PredictiveScalingPredefinedScalingMetric = (input, context) => {
    const entries = {};
    if (input[_PMT] != null) {
        entries[_PMT] = input[_PMT];
    }
    if (input[_RL] != null) {
        entries[_RL] = input[_RL];
    }
    return entries;
};
const se_ProcessNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PutLifecycleHookType = (input, context) => {
    const entries = {};
    if (input[_LHN] != null) {
        entries[_LHN] = input[_LHN];
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LTi] != null) {
        entries[_LTi] = input[_LTi];
    }
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_NTARN] != null) {
        entries[_NTARN] = input[_NTARN];
    }
    if (input[_NM] != null) {
        entries[_NM] = input[_NM];
    }
    if (input[_HTe] != null) {
        entries[_HTe] = input[_HTe];
    }
    if (input[_DR] != null) {
        entries[_DR] = input[_DR];
    }
    return entries;
};
const se_PutNotificationConfigurationType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_TARN] != null) {
        entries[_TARN] = input[_TARN];
    }
    if (input[_NTo] != null) {
        const memberEntries = se_AutoScalingNotificationTypes(input[_NTo], context);
        if (input[_NTo]?.length === 0) {
            entries.NotificationTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NotificationTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutScalingPolicyType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PTol] != null) {
        entries[_PTol] = input[_PTol];
    }
    if (input[_ATd] != null) {
        entries[_ATd] = input[_ATd];
    }
    if (input[_MAS] != null) {
        entries[_MAS] = input[_MAS];
    }
    if (input[_MAM] != null) {
        entries[_MAM] = input[_MAM];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_Co] != null) {
        entries[_Co] = input[_Co];
    }
    if (input[_MAT] != null) {
        entries[_MAT] = input[_MAT];
    }
    if (input[_SAt] != null) {
        const memberEntries = se_StepAdjustments(input[_SAt], context);
        if (input[_SAt]?.length === 0) {
            entries.StepAdjustments = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StepAdjustments.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EIW] != null) {
        entries[_EIW] = input[_EIW];
    }
    if (input[_TTC] != null) {
        const memberEntries = se_TargetTrackingConfiguration(input[_TTC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetTrackingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ena] != null) {
        entries[_Ena] = input[_Ena];
    }
    if (input[_PSC] != null) {
        const memberEntries = se_PredictiveScalingConfiguration(input[_PSC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredictiveScalingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutScheduledUpdateGroupActionType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SANc] != null) {
        entries[_SANc] = input[_SANc];
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti].toISOString().split(".")[0] + "Z";
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_R] != null) {
        entries[_R] = input[_R];
    }
    if (input[_MS] != null) {
        entries[_MS] = input[_MS];
    }
    if (input[_MSa] != null) {
        entries[_MSa] = input[_MSa];
    }
    if (input[_DC] != null) {
        entries[_DC] = input[_DC];
    }
    if (input[_TZ] != null) {
        entries[_TZ] = input[_TZ];
    }
    return entries;
};
const se_PutWarmPoolType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_MGPC] != null) {
        entries[_MGPC] = input[_MGPC];
    }
    if (input[_MS] != null) {
        entries[_MS] = input[_MS];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    if (input[_IRP] != null) {
        const memberEntries = se_InstanceReusePolicy(input[_IRP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceReusePolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RecordLifecycleActionHeartbeatType = (input, context) => {
    const entries = {};
    if (input[_LHN] != null) {
        entries[_LHN] = input[_LHN];
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LAT] != null) {
        entries[_LAT] = input[_LAT];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    return entries;
};
const se_RefreshPreferences = (input, context) => {
    const entries = {};
    if (input[_MHP] != null) {
        entries[_MHP] = input[_MHP];
    }
    if (input[_IW] != null) {
        entries[_IW] = input[_IW];
    }
    if (input[_CP] != null) {
        const memberEntries = se_CheckpointPercentages(input[_CP], context);
        if (input[_CP]?.length === 0) {
            entries.CheckpointPercentages = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CheckpointPercentages.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CD] != null) {
        entries[_CD] = input[_CD];
    }
    if (input[_SM] != null) {
        entries[_SM] = input[_SM];
    }
    if (input[_AR] != null) {
        entries[_AR] = input[_AR];
    }
    if (input[_SIPI] != null) {
        entries[_SIPI] = input[_SIPI];
    }
    if (input[_SIt] != null) {
        entries[_SIt] = input[_SIt];
    }
    if (input[_AS] != null) {
        const memberEntries = se_AlarmSpecification(input[_AS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MHPa] != null) {
        entries[_MHPa] = input[_MHPa];
    }
    return entries;
};
const se_RollbackInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    return entries;
};
const se_ScalingProcessQuery = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_SPc] != null) {
        const memberEntries = se_ProcessNames(input[_SPc], context);
        if (input[_SPc]?.length === 0) {
            entries.ScalingProcesses = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScalingProcesses.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ScheduledActionNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ScheduledUpdateGroupActionRequest = (input, context) => {
    const entries = {};
    if (input[_SANc] != null) {
        entries[_SANc] = input[_SANc];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_R] != null) {
        entries[_R] = input[_R];
    }
    if (input[_MS] != null) {
        entries[_MS] = input[_MS];
    }
    if (input[_MSa] != null) {
        entries[_MSa] = input[_MSa];
    }
    if (input[_DC] != null) {
        entries[_DC] = input[_DC];
    }
    if (input[_TZ] != null) {
        entries[_TZ] = input[_TZ];
    }
    return entries;
};
const se_ScheduledUpdateGroupActionRequests = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledUpdateGroupActionRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetDesiredCapacityType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_DC] != null) {
        entries[_DC] = input[_DC];
    }
    if (input[_HC] != null) {
        entries[_HC] = input[_HC];
    }
    return entries;
};
const se_SetInstanceHealthQuery = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_HS] != null) {
        entries[_HS] = input[_HS];
    }
    if (input[_SRGP] != null) {
        entries[_SRGP] = input[_SRGP];
    }
    return entries;
};
const se_SetInstanceProtectionQuery = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        const memberEntries = se_InstanceIds(input[_II], context);
        if (input[_II]?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_PFSI] != null) {
        entries[_PFSI] = input[_PFSI];
    }
    return entries;
};
const se_StartInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_Str] != null) {
        entries[_Str] = input[_Str];
    }
    if (input[_DCes] != null) {
        const memberEntries = se_DesiredConfiguration(input[_DCes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DesiredConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        const memberEntries = se_RefreshPreferences(input[_P], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Preferences.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_StepAdjustment = (input, context) => {
    const entries = {};
    if (input[_MILB] != null) {
        entries[_MILB] = __serializeFloat(input[_MILB]);
    }
    if (input[_MIUB] != null) {
        entries[_MIUB] = __serializeFloat(input[_MIUB]);
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    return entries;
};
const se_StepAdjustments = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_StepAdjustment(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_RIe] != null) {
        entries[_RIe] = input[_RIe];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    if (input[_PAL] != null) {
        entries[_PAL] = input[_PAL];
    }
    return entries;
};
const se_Tags = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupARNs = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetTrackingConfiguration = (input, context) => {
    const entries = {};
    if (input[_PMS] != null) {
        const memberEntries = se_PredefinedMetricSpecification(input[_PMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CMS] != null) {
        const memberEntries = se_CustomizedMetricSpecification(input[_CMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        entries[_TV] = __serializeFloat(input[_TV]);
    }
    if (input[_DSI] != null) {
        entries[_DSI] = input[_DSI];
    }
    return entries;
};
const se_TargetTrackingMetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetTrackingMetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetTrackingMetricDataQuery = (input, context) => {
    const entries = {};
    if (input[_Id] != null) {
        entries[_Id] = input[_Id];
    }
    if (input[_Ex] != null) {
        entries[_Ex] = input[_Ex];
    }
    if (input[_MSe] != null) {
        const memberEntries = se_TargetTrackingMetricStat(input[_MSe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_L] != null) {
        entries[_L] = input[_L];
    }
    if (input[_RD] != null) {
        entries[_RD] = input[_RD];
    }
    return entries;
};
const se_TargetTrackingMetricStat = (input, context) => {
    const entries = {};
    if (input[_Met] != null) {
        const memberEntries = se_Metric(input[_Met], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_TerminateInstanceInAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_SDDC] != null) {
        entries[_SDDC] = input[_SDDC];
    }
    return entries;
};
const se_TerminationPolicies = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TotalLocalStorageGBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_TrafficSourceIdentifier = (input, context) => {
    const entries = {};
    if (input[_Ide] != null) {
        entries[_Ide] = input[_Ide];
    }
    if (input[_Ty] != null) {
        entries[_Ty] = input[_Ty];
    }
    return entries;
};
const se_TrafficSources = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TrafficSourceIdentifier(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_UpdateAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input[_ASGN] != null) {
        entries[_ASGN] = input[_ASGN];
    }
    if (input[_LCN] != null) {
        entries[_LCN] = input[_LCN];
    }
    if (input[_LT] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MIP] != null) {
        const memberEntries = se_MixedInstancesPolicy(input[_MIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MS] != null) {
        entries[_MS] = input[_MS];
    }
    if (input[_MSa] != null) {
        entries[_MSa] = input[_MSa];
    }
    if (input[_DC] != null) {
        entries[_DC] = input[_DC];
    }
    if (input[_DCe] != null) {
        entries[_DCe] = input[_DCe];
    }
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HCT] != null) {
        entries[_HCT] = input[_HCT];
    }
    if (input[_HCGP] != null) {
        entries[_HCGP] = input[_HCGP];
    }
    if (input[_PG] != null) {
        entries[_PG] = input[_PG];
    }
    if (input[_VPCZI] != null) {
        entries[_VPCZI] = input[_VPCZI];
    }
    if (input[_TP] != null) {
        const memberEntries = se_TerminationPolicies(input[_TP], context);
        if (input[_TP]?.length === 0) {
            entries.TerminationPolicies = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TerminationPolicies.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NIPFSI] != null) {
        entries[_NIPFSI] = input[_NIPFSI];
    }
    if (input[_SLRARN] != null) {
        entries[_SLRARN] = input[_SLRARN];
    }
    if (input[_MIL] != null) {
        entries[_MIL] = input[_MIL];
    }
    if (input[_CR] != null) {
        entries[_CR] = input[_CR];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_DCT] != null) {
        entries[_DCT] = input[_DCT];
    }
    if (input[_DIW] != null) {
        entries[_DIW] = input[_DIW];
    }
    if (input[_IMP] != null) {
        const memberEntries = se_InstanceMaintenancePolicy(input[_IMP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMaintenancePolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Values = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VCpuCountRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const de_AcceleratorCountRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_AcceleratorManufacturers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorTotalMemoryMiBRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_AcceleratorTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ActiveInstanceRefreshNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_Activities = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Activity(entry, context);
    });
};
const de_ActivitiesType = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents[_Ac] = [];
    }
    else if (output[_Ac] != null && output[_Ac][_me] != null) {
        contents[_Ac] = de_Activities(__getArrayIfSingleItem(output[_Ac][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_Activity = (output, context) => {
    const contents = {};
    if (output[_AIct] != null) {
        contents[_AIct] = __expectString(output[_AIct]);
    }
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_De] != null) {
        contents[_De] = __expectString(output[_De]);
    }
    if (output[_Ca] != null) {
        contents[_Ca] = __expectString(output[_Ca]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ST]));
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));
    }
    if (output[_SC] != null) {
        contents[_SC] = __expectString(output[_SC]);
    }
    if (output[_SMt] != null) {
        contents[_SMt] = __expectString(output[_SMt]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = __strictParseInt32(output[_Pr]);
    }
    if (output[_Det] != null) {
        contents[_Det] = __expectString(output[_Det]);
    }
    if (output[_ASGS] != null) {
        contents[_ASGS] = __expectString(output[_ASGS]);
    }
    if (output[_ASGARN] != null) {
        contents[_ASGARN] = __expectString(output[_ASGARN]);
    }
    return contents;
};
const de_ActivityType = (output, context) => {
    const contents = {};
    if (output[_Act] != null) {
        contents[_Act] = de_Activity(output[_Act], context);
    }
    return contents;
};
const de_AdjustmentType = (output, context) => {
    const contents = {};
    if (output[_ATd] != null) {
        contents[_ATd] = __expectString(output[_ATd]);
    }
    return contents;
};
const de_AdjustmentTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdjustmentType(entry, context);
    });
};
const de_Alarm = (output, context) => {
    const contents = {};
    if (output[_ANl] != null) {
        contents[_ANl] = __expectString(output[_ANl]);
    }
    if (output[_AARN] != null) {
        contents[_AARN] = __expectString(output[_AARN]);
    }
    return contents;
};
const de_AlarmList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Alarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Alarm(entry, context);
    });
};
const de_AlarmSpecification = (output, context) => {
    const contents = {};
    if (output.Alarms === "") {
        contents[_Al] = [];
    }
    else if (output[_Al] != null && output[_Al][_me] != null) {
        contents[_Al] = de_AlarmList(__getArrayIfSingleItem(output[_Al][_me]), context);
    }
    return contents;
};
const de_AllowedInstanceTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AttachLoadBalancersResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AttachLoadBalancerTargetGroupsResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AttachTrafficSourcesResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AutoScalingGroup = (output, context) => {
    const contents = {};
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_ASGARN] != null) {
        contents[_ASGARN] = __expectString(output[_ASGARN]);
    }
    if (output[_LCN] != null) {
        contents[_LCN] = __expectString(output[_LCN]);
    }
    if (output[_LT] != null) {
        contents[_LT] = de_LaunchTemplateSpecification(output[_LT], context);
    }
    if (output[_MIP] != null) {
        contents[_MIP] = de_MixedInstancesPolicy(output[_MIP], context);
    }
    if (output[_MS] != null) {
        contents[_MS] = __strictParseInt32(output[_MS]);
    }
    if (output[_MSa] != null) {
        contents[_MSa] = __strictParseInt32(output[_MSa]);
    }
    if (output[_DC] != null) {
        contents[_DC] = __strictParseInt32(output[_DC]);
    }
    if (output[_PC] != null) {
        contents[_PC] = __strictParseInt32(output[_PC]);
    }
    if (output[_DCe] != null) {
        contents[_DCe] = __strictParseInt32(output[_DCe]);
    }
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_me] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_me]), context);
    }
    if (output.LoadBalancerNames === "") {
        contents[_LBN] = [];
    }
    else if (output[_LBN] != null && output[_LBN][_me] != null) {
        contents[_LBN] = de_LoadBalancerNames(__getArrayIfSingleItem(output[_LBN][_me]), context);
    }
    if (output.TargetGroupARNs === "") {
        contents[_TGARN] = [];
    }
    else if (output[_TGARN] != null && output[_TGARN][_me] != null) {
        contents[_TGARN] = de_TargetGroupARNs(__getArrayIfSingleItem(output[_TGARN][_me]), context);
    }
    if (output[_HCT] != null) {
        contents[_HCT] = __expectString(output[_HCT]);
    }
    if (output[_HCGP] != null) {
        contents[_HCGP] = __strictParseInt32(output[_HCGP]);
    }
    if (output.Instances === "") {
        contents[_In] = [];
    }
    else if (output[_In] != null && output[_In][_me] != null) {
        contents[_In] = de_Instances(__getArrayIfSingleItem(output[_In][_me]), context);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CT]));
    }
    if (output.SuspendedProcesses === "") {
        contents[_SPu] = [];
    }
    else if (output[_SPu] != null && output[_SPu][_me] != null) {
        contents[_SPu] = de_SuspendedProcesses(__getArrayIfSingleItem(output[_SPu][_me]), context);
    }
    if (output[_PG] != null) {
        contents[_PG] = __expectString(output[_PG]);
    }
    if (output[_VPCZI] != null) {
        contents[_VPCZI] = __expectString(output[_VPCZI]);
    }
    if (output.EnabledMetrics === "") {
        contents[_EM] = [];
    }
    else if (output[_EM] != null && output[_EM][_me] != null) {
        contents[_EM] = de_EnabledMetrics(__getArrayIfSingleItem(output[_EM][_me]), context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_TagDescriptionList(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output.TerminationPolicies === "") {
        contents[_TP] = [];
    }
    else if (output[_TP] != null && output[_TP][_me] != null) {
        contents[_TP] = de_TerminationPolicies(__getArrayIfSingleItem(output[_TP][_me]), context);
    }
    if (output[_NIPFSI] != null) {
        contents[_NIPFSI] = __parseBoolean(output[_NIPFSI]);
    }
    if (output[_SLRARN] != null) {
        contents[_SLRARN] = __expectString(output[_SLRARN]);
    }
    if (output[_MIL] != null) {
        contents[_MIL] = __strictParseInt32(output[_MIL]);
    }
    if (output[_CR] != null) {
        contents[_CR] = __parseBoolean(output[_CR]);
    }
    if (output[_WPC] != null) {
        contents[_WPC] = de_WarmPoolConfiguration(output[_WPC], context);
    }
    if (output[_WPS] != null) {
        contents[_WPS] = __strictParseInt32(output[_WPS]);
    }
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_DCT] != null) {
        contents[_DCT] = __expectString(output[_DCT]);
    }
    if (output[_DIW] != null) {
        contents[_DIW] = __strictParseInt32(output[_DIW]);
    }
    if (output.TrafficSources === "") {
        contents[_TS] = [];
    }
    else if (output[_TS] != null && output[_TS][_me] != null) {
        contents[_TS] = de_TrafficSources(__getArrayIfSingleItem(output[_TS][_me]), context);
    }
    if (output[_IMP] != null) {
        contents[_IMP] = de_InstanceMaintenancePolicy(output[_IMP], context);
    }
    return contents;
};
const de_AutoScalingGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoScalingGroup(entry, context);
    });
};
const de_AutoScalingGroupsType = (output, context) => {
    const contents = {};
    if (output.AutoScalingGroups === "") {
        contents[_ASG] = [];
    }
    else if (output[_ASG] != null && output[_ASG][_me] != null) {
        contents[_ASG] = de_AutoScalingGroups(__getArrayIfSingleItem(output[_ASG][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_AutoScalingInstanceDetails = (output, context) => {
    const contents = {};
    if (output[_IIn] != null) {
        contents[_IIn] = __expectString(output[_IIn]);
    }
    if (output[_IT] != null) {
        contents[_IT] = __expectString(output[_IT]);
    }
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_AZv] != null) {
        contents[_AZv] = __expectString(output[_AZv]);
    }
    if (output[_LSi] != null) {
        contents[_LSi] = __expectString(output[_LSi]);
    }
    if (output[_HS] != null) {
        contents[_HS] = __expectString(output[_HS]);
    }
    if (output[_LCN] != null) {
        contents[_LCN] = __expectString(output[_LCN]);
    }
    if (output[_LT] != null) {
        contents[_LT] = de_LaunchTemplateSpecification(output[_LT], context);
    }
    if (output[_PFSI] != null) {
        contents[_PFSI] = __parseBoolean(output[_PFSI]);
    }
    if (output[_WC] != null) {
        contents[_WC] = __expectString(output[_WC]);
    }
    return contents;
};
const de_AutoScalingInstances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoScalingInstanceDetails(entry, context);
    });
};
const de_AutoScalingInstancesType = (output, context) => {
    const contents = {};
    if (output.AutoScalingInstances === "") {
        contents[_ASI] = [];
    }
    else if (output[_ASI] != null && output[_ASI][_me] != null) {
        contents[_ASI] = de_AutoScalingInstances(__getArrayIfSingleItem(output[_ASI][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_AutoScalingNotificationTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_BaselineEbsBandwidthMbpsRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_BatchDeleteScheduledActionAnswer = (output, context) => {
    const contents = {};
    if (output.FailedScheduledActions === "") {
        contents[_FSA] = [];
    }
    else if (output[_FSA] != null && output[_FSA][_me] != null) {
        contents[_FSA] = de_FailedScheduledUpdateGroupActionRequests(__getArrayIfSingleItem(output[_FSA][_me]), context);
    }
    return contents;
};
const de_BatchPutScheduledUpdateGroupActionAnswer = (output, context) => {
    const contents = {};
    if (output.FailedScheduledUpdateGroupActions === "") {
        contents[_FSUGA] = [];
    }
    else if (output[_FSUGA] != null && output[_FSUGA][_me] != null) {
        contents[_FSUGA] = de_FailedScheduledUpdateGroupActionRequests(__getArrayIfSingleItem(output[_FSUGA][_me]), context);
    }
    return contents;
};
const de_BlockDeviceMapping = (output, context) => {
    const contents = {};
    if (output[_VN] != null) {
        contents[_VN] = __expectString(output[_VN]);
    }
    if (output[_DN] != null) {
        contents[_DN] = __expectString(output[_DN]);
    }
    if (output[_E] != null) {
        contents[_E] = de_Ebs(output[_E], context);
    }
    if (output[_ND] != null) {
        contents[_ND] = __parseBoolean(output[_ND]);
    }
    return contents;
};
const de_BlockDeviceMappings = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BlockDeviceMapping(entry, context);
    });
};
const de_CancelInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output[_IRIn] != null) {
        contents[_IRIn] = __expectString(output[_IRIn]);
    }
    return contents;
};
const de_CapacityForecast = (output, context) => {
    const contents = {};
    if (output.Timestamps === "") {
        contents[_Tim] = [];
    }
    else if (output[_Tim] != null && output[_Tim][_me] != null) {
        contents[_Tim] = de_PredictiveScalingForecastTimestamps(__getArrayIfSingleItem(output[_Tim][_me]), context);
    }
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_me] != null) {
        contents[_Va] = de_PredictiveScalingForecastValues(__getArrayIfSingleItem(output[_Va][_me]), context);
    }
    return contents;
};
const de_CheckpointPercentages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_ClassicLinkVPCSecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CompleteLifecycleActionAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_CpuManufacturers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CustomizedMetricSpecification = (output, context) => {
    const contents = {};
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_me] != null) {
        contents[_D] = de_MetricDimensions(__getArrayIfSingleItem(output[_D][_me]), context);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    if (output.Metrics === "") {
        contents[_Me] = [];
    }
    else if (output[_Me] != null && output[_Me][_me] != null) {
        contents[_Me] = de_TargetTrackingMetricDataQueries(__getArrayIfSingleItem(output[_Me][_me]), context);
    }
    return contents;
};
const de_DeleteLifecycleHookAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteWarmPoolAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAccountLimitsAnswer = (output, context) => {
    const contents = {};
    if (output[_MNOASG] != null) {
        contents[_MNOASG] = __strictParseInt32(output[_MNOASG]);
    }
    if (output[_MNOLC] != null) {
        contents[_MNOLC] = __strictParseInt32(output[_MNOLC]);
    }
    if (output[_NOASG] != null) {
        contents[_NOASG] = __strictParseInt32(output[_NOASG]);
    }
    if (output[_NOLC] != null) {
        contents[_NOLC] = __strictParseInt32(output[_NOLC]);
    }
    return contents;
};
const de_DescribeAdjustmentTypesAnswer = (output, context) => {
    const contents = {};
    if (output.AdjustmentTypes === "") {
        contents[_ATdj] = [];
    }
    else if (output[_ATdj] != null && output[_ATdj][_me] != null) {
        contents[_ATdj] = de_AdjustmentTypes(__getArrayIfSingleItem(output[_ATdj][_me]), context);
    }
    return contents;
};
const de_DescribeAutoScalingNotificationTypesAnswer = (output, context) => {
    const contents = {};
    if (output.AutoScalingNotificationTypes === "") {
        contents[_ASNT] = [];
    }
    else if (output[_ASNT] != null && output[_ASNT][_me] != null) {
        contents[_ASNT] = de_AutoScalingNotificationTypes(__getArrayIfSingleItem(output[_ASNT][_me]), context);
    }
    return contents;
};
const de_DescribeInstanceRefreshesAnswer = (output, context) => {
    const contents = {};
    if (output.InstanceRefreshes === "") {
        contents[_IRn] = [];
    }
    else if (output[_IRn] != null && output[_IRn][_me] != null) {
        contents[_IRn] = de_InstanceRefreshes(__getArrayIfSingleItem(output[_IRn][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeLifecycleHooksAnswer = (output, context) => {
    const contents = {};
    if (output.LifecycleHooks === "") {
        contents[_LH] = [];
    }
    else if (output[_LH] != null && output[_LH][_me] != null) {
        contents[_LH] = de_LifecycleHooks(__getArrayIfSingleItem(output[_LH][_me]), context);
    }
    return contents;
};
const de_DescribeLifecycleHookTypesAnswer = (output, context) => {
    const contents = {};
    if (output.LifecycleHookTypes === "") {
        contents[_LHT] = [];
    }
    else if (output[_LHT] != null && output[_LHT][_me] != null) {
        contents[_LHT] = de_AutoScalingNotificationTypes(__getArrayIfSingleItem(output[_LHT][_me]), context);
    }
    return contents;
};
const de_DescribeLoadBalancersResponse = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents[_LB] = [];
    }
    else if (output[_LB] != null && output[_LB][_me] != null) {
        contents[_LB] = de_LoadBalancerStates(__getArrayIfSingleItem(output[_LB][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeLoadBalancerTargetGroupsResponse = (output, context) => {
    const contents = {};
    if (output.LoadBalancerTargetGroups === "") {
        contents[_LBTG] = [];
    }
    else if (output[_LBTG] != null && output[_LBTG][_me] != null) {
        contents[_LBTG] = de_LoadBalancerTargetGroupStates(__getArrayIfSingleItem(output[_LBTG][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeMetricCollectionTypesAnswer = (output, context) => {
    const contents = {};
    if (output.Metrics === "") {
        contents[_Me] = [];
    }
    else if (output[_Me] != null && output[_Me][_me] != null) {
        contents[_Me] = de_MetricCollectionTypes(__getArrayIfSingleItem(output[_Me][_me]), context);
    }
    if (output.Granularities === "") {
        contents[_Gr] = [];
    }
    else if (output[_Gr] != null && output[_Gr][_me] != null) {
        contents[_Gr] = de_MetricGranularityTypes(__getArrayIfSingleItem(output[_Gr][_me]), context);
    }
    return contents;
};
const de_DescribeNotificationConfigurationsAnswer = (output, context) => {
    const contents = {};
    if (output.NotificationConfigurations === "") {
        contents[_NC] = [];
    }
    else if (output[_NC] != null && output[_NC][_me] != null) {
        contents[_NC] = de_NotificationConfigurations(__getArrayIfSingleItem(output[_NC][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeTerminationPolicyTypesAnswer = (output, context) => {
    const contents = {};
    if (output.TerminationPolicyTypes === "") {
        contents[_TPT] = [];
    }
    else if (output[_TPT] != null && output[_TPT][_me] != null) {
        contents[_TPT] = de_TerminationPolicies(__getArrayIfSingleItem(output[_TPT][_me]), context);
    }
    return contents;
};
const de_DescribeTrafficSourcesResponse = (output, context) => {
    const contents = {};
    if (output.TrafficSources === "") {
        contents[_TS] = [];
    }
    else if (output[_TS] != null && output[_TS][_me] != null) {
        contents[_TS] = de_TrafficSourceStates(__getArrayIfSingleItem(output[_TS][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeWarmPoolAnswer = (output, context) => {
    const contents = {};
    if (output[_WPC] != null) {
        contents[_WPC] = de_WarmPoolConfiguration(output[_WPC], context);
    }
    if (output.Instances === "") {
        contents[_In] = [];
    }
    else if (output[_In] != null && output[_In][_me] != null) {
        contents[_In] = de_Instances(__getArrayIfSingleItem(output[_In][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DesiredConfiguration = (output, context) => {
    const contents = {};
    if (output[_LT] != null) {
        contents[_LT] = de_LaunchTemplateSpecification(output[_LT], context);
    }
    if (output[_MIP] != null) {
        contents[_MIP] = de_MixedInstancesPolicy(output[_MIP], context);
    }
    return contents;
};
const de_DetachInstancesAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents[_Ac] = [];
    }
    else if (output[_Ac] != null && output[_Ac][_me] != null) {
        contents[_Ac] = de_Activities(__getArrayIfSingleItem(output[_Ac][_me]), context);
    }
    return contents;
};
const de_DetachLoadBalancersResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_DetachLoadBalancerTargetGroupsResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_DetachTrafficSourcesResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_Ebs = (output, context) => {
    const contents = {};
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_VS] != null) {
        contents[_VS] = __strictParseInt32(output[_VS]);
    }
    if (output[_VT] != null) {
        contents[_VT] = __expectString(output[_VT]);
    }
    if (output[_DOT] != null) {
        contents[_DOT] = __parseBoolean(output[_DOT]);
    }
    if (output[_I] != null) {
        contents[_I] = __strictParseInt32(output[_I]);
    }
    if (output[_En] != null) {
        contents[_En] = __parseBoolean(output[_En]);
    }
    if (output[_Th] != null) {
        contents[_Th] = __strictParseInt32(output[_Th]);
    }
    return contents;
};
const de_EnabledMetric = (output, context) => {
    const contents = {};
    if (output[_Met] != null) {
        contents[_Met] = __expectString(output[_Met]);
    }
    if (output[_G] != null) {
        contents[_G] = __expectString(output[_G]);
    }
    return contents;
};
const de_EnabledMetrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EnabledMetric(entry, context);
    });
};
const de_EnterStandbyAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents[_Ac] = [];
    }
    else if (output[_Ac] != null && output[_Ac][_me] != null) {
        contents[_Ac] = de_Activities(__getArrayIfSingleItem(output[_Ac][_me]), context);
    }
    return contents;
};
const de_ExcludedInstanceTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ExitStandbyAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents[_Ac] = [];
    }
    else if (output[_Ac] != null && output[_Ac][_me] != null) {
        contents[_Ac] = de_Activities(__getArrayIfSingleItem(output[_Ac][_me]), context);
    }
    return contents;
};
const de_FailedScheduledUpdateGroupActionRequest = (output, context) => {
    const contents = {};
    if (output[_SANc] != null) {
        contents[_SANc] = __expectString(output[_SANc]);
    }
    if (output[_EC] != null) {
        contents[_EC] = __expectString(output[_EC]);
    }
    if (output[_EMr] != null) {
        contents[_EMr] = __expectString(output[_EMr]);
    }
    return contents;
};
const de_FailedScheduledUpdateGroupActionRequests = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FailedScheduledUpdateGroupActionRequest(entry, context);
    });
};
const de_GetPredictiveScalingForecastAnswer = (output, context) => {
    const contents = {};
    if (output.LoadForecast === "") {
        contents[_LF] = [];
    }
    else if (output[_LF] != null && output[_LF][_me] != null) {
        contents[_LF] = de_LoadForecasts(__getArrayIfSingleItem(output[_LF][_me]), context);
    }
    if (output[_CF] != null) {
        contents[_CF] = de_CapacityForecast(output[_CF], context);
    }
    if (output[_UT] != null) {
        contents[_UT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UT]));
    }
    return contents;
};
const de_Instance = (output, context) => {
    const contents = {};
    if (output[_IIn] != null) {
        contents[_IIn] = __expectString(output[_IIn]);
    }
    if (output[_IT] != null) {
        contents[_IT] = __expectString(output[_IT]);
    }
    if (output[_AZv] != null) {
        contents[_AZv] = __expectString(output[_AZv]);
    }
    if (output[_LSi] != null) {
        contents[_LSi] = __expectString(output[_LSi]);
    }
    if (output[_HS] != null) {
        contents[_HS] = __expectString(output[_HS]);
    }
    if (output[_LCN] != null) {
        contents[_LCN] = __expectString(output[_LCN]);
    }
    if (output[_LT] != null) {
        contents[_LT] = de_LaunchTemplateSpecification(output[_LT], context);
    }
    if (output[_PFSI] != null) {
        contents[_PFSI] = __parseBoolean(output[_PFSI]);
    }
    if (output[_WC] != null) {
        contents[_WC] = __expectString(output[_WC]);
    }
    return contents;
};
const de_InstanceGenerations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceMaintenancePolicy = (output, context) => {
    const contents = {};
    if (output[_MHP] != null) {
        contents[_MHP] = __strictParseInt32(output[_MHP]);
    }
    if (output[_MHPa] != null) {
        contents[_MHPa] = __strictParseInt32(output[_MHPa]);
    }
    return contents;
};
const de_InstanceMetadataOptions = (output, context) => {
    const contents = {};
    if (output[_HT] != null) {
        contents[_HT] = __expectString(output[_HT]);
    }
    if (output[_HPRHL] != null) {
        contents[_HPRHL] = __strictParseInt32(output[_HPRHL]);
    }
    if (output[_HE] != null) {
        contents[_HE] = __expectString(output[_HE]);
    }
    return contents;
};
const de_InstanceMonitoring = (output, context) => {
    const contents = {};
    if (output[_Ena] != null) {
        contents[_Ena] = __parseBoolean(output[_Ena]);
    }
    return contents;
};
const de_InstanceRefresh = (output, context) => {
    const contents = {};
    if (output[_IRIn] != null) {
        contents[_IRIn] = __expectString(output[_IRIn]);
    }
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output[_SR] != null) {
        contents[_SR] = __expectString(output[_SR]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ST]));
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));
    }
    if (output[_PCe] != null) {
        contents[_PCe] = __strictParseInt32(output[_PCe]);
    }
    if (output[_ITU] != null) {
        contents[_ITU] = __strictParseInt32(output[_ITU]);
    }
    if (output[_PD] != null) {
        contents[_PD] = de_InstanceRefreshProgressDetails(output[_PD], context);
    }
    if (output[_P] != null) {
        contents[_P] = de_RefreshPreferences(output[_P], context);
    }
    if (output[_DCes] != null) {
        contents[_DCes] = de_DesiredConfiguration(output[_DCes], context);
    }
    if (output[_RDo] != null) {
        contents[_RDo] = de_RollbackDetails(output[_RDo], context);
    }
    return contents;
};
const de_InstanceRefreshes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceRefresh(entry, context);
    });
};
const de_InstanceRefreshInProgressFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InstanceRefreshLivePoolProgress = (output, context) => {
    const contents = {};
    if (output[_PCe] != null) {
        contents[_PCe] = __strictParseInt32(output[_PCe]);
    }
    if (output[_ITU] != null) {
        contents[_ITU] = __strictParseInt32(output[_ITU]);
    }
    return contents;
};
const de_InstanceRefreshProgressDetails = (output, context) => {
    const contents = {};
    if (output[_LPP] != null) {
        contents[_LPP] = de_InstanceRefreshLivePoolProgress(output[_LPP], context);
    }
    if (output[_WPP] != null) {
        contents[_WPP] = de_InstanceRefreshWarmPoolProgress(output[_WPP], context);
    }
    return contents;
};
const de_InstanceRefreshWarmPoolProgress = (output, context) => {
    const contents = {};
    if (output[_PCe] != null) {
        contents[_PCe] = __strictParseInt32(output[_PCe]);
    }
    if (output[_ITU] != null) {
        contents[_ITU] = __strictParseInt32(output[_ITU]);
    }
    return contents;
};
const de_InstanceRequirements = (output, context) => {
    const contents = {};
    if (output[_VCC] != null) {
        contents[_VCC] = de_VCpuCountRequest(output[_VCC], context);
    }
    if (output[_MMB] != null) {
        contents[_MMB] = de_MemoryMiBRequest(output[_MMB], context);
    }
    if (output.CpuManufacturers === "") {
        contents[_CM] = [];
    }
    else if (output[_CM] != null && output[_CM][_me] != null) {
        contents[_CM] = de_CpuManufacturers(__getArrayIfSingleItem(output[_CM][_me]), context);
    }
    if (output[_MGBPVC] != null) {
        contents[_MGBPVC] = de_MemoryGiBPerVCpuRequest(output[_MGBPVC], context);
    }
    if (output.ExcludedInstanceTypes === "") {
        contents[_EIT] = [];
    }
    else if (output[_EIT] != null && output[_EIT][_me] != null) {
        contents[_EIT] = de_ExcludedInstanceTypes(__getArrayIfSingleItem(output[_EIT][_me]), context);
    }
    if (output.InstanceGenerations === "") {
        contents[_IG] = [];
    }
    else if (output[_IG] != null && output[_IG][_me] != null) {
        contents[_IG] = de_InstanceGenerations(__getArrayIfSingleItem(output[_IG][_me]), context);
    }
    if (output[_SMPPOLP] != null) {
        contents[_SMPPOLP] = __strictParseInt32(output[_SMPPOLP]);
    }
    if (output[_MSPAPOOODP] != null) {
        contents[_MSPAPOOODP] = __strictParseInt32(output[_MSPAPOOODP]);
    }
    if (output[_ODMPPOLP] != null) {
        contents[_ODMPPOLP] = __strictParseInt32(output[_ODMPPOLP]);
    }
    if (output[_BM] != null) {
        contents[_BM] = __expectString(output[_BM]);
    }
    if (output[_BP] != null) {
        contents[_BP] = __expectString(output[_BP]);
    }
    if (output[_RHS] != null) {
        contents[_RHS] = __parseBoolean(output[_RHS]);
    }
    if (output[_NIC] != null) {
        contents[_NIC] = de_NetworkInterfaceCountRequest(output[_NIC], context);
    }
    if (output[_LS] != null) {
        contents[_LS] = __expectString(output[_LS]);
    }
    if (output.LocalStorageTypes === "") {
        contents[_LST] = [];
    }
    else if (output[_LST] != null && output[_LST][_me] != null) {
        contents[_LST] = de_LocalStorageTypes(__getArrayIfSingleItem(output[_LST][_me]), context);
    }
    if (output[_TLSGB] != null) {
        contents[_TLSGB] = de_TotalLocalStorageGBRequest(output[_TLSGB], context);
    }
    if (output[_BEBM] != null) {
        contents[_BEBM] = de_BaselineEbsBandwidthMbpsRequest(output[_BEBM], context);
    }
    if (output.AcceleratorTypes === "") {
        contents[_AT] = [];
    }
    else if (output[_AT] != null && output[_AT][_me] != null) {
        contents[_AT] = de_AcceleratorTypes(__getArrayIfSingleItem(output[_AT][_me]), context);
    }
    if (output[_AC] != null) {
        contents[_AC] = de_AcceleratorCountRequest(output[_AC], context);
    }
    if (output.AcceleratorManufacturers === "") {
        contents[_AM] = [];
    }
    else if (output[_AM] != null && output[_AM][_me] != null) {
        contents[_AM] = de_AcceleratorManufacturers(__getArrayIfSingleItem(output[_AM][_me]), context);
    }
    if (output.AcceleratorNames === "") {
        contents[_AN] = [];
    }
    else if (output[_AN] != null && output[_AN][_me] != null) {
        contents[_AN] = de_AcceleratorNames(__getArrayIfSingleItem(output[_AN][_me]), context);
    }
    if (output[_ATMMB] != null) {
        contents[_ATMMB] = de_AcceleratorTotalMemoryMiBRequest(output[_ATMMB], context);
    }
    if (output[_NBG] != null) {
        contents[_NBG] = de_NetworkBandwidthGbpsRequest(output[_NBG], context);
    }
    if (output.AllowedInstanceTypes === "") {
        contents[_AIT] = [];
    }
    else if (output[_AIT] != null && output[_AIT][_me] != null) {
        contents[_AIT] = de_AllowedInstanceTypes(__getArrayIfSingleItem(output[_AIT][_me]), context);
    }
    return contents;
};
const de_InstanceReusePolicy = (output, context) => {
    const contents = {};
    if (output[_ROSI] != null) {
        contents[_ROSI] = __parseBoolean(output[_ROSI]);
    }
    return contents;
};
const de_Instances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Instance(entry, context);
    });
};
const de_InstancesDistribution = (output, context) => {
    const contents = {};
    if (output[_ODAS] != null) {
        contents[_ODAS] = __expectString(output[_ODAS]);
    }
    if (output[_ODBC] != null) {
        contents[_ODBC] = __strictParseInt32(output[_ODBC]);
    }
    if (output[_ODPABC] != null) {
        contents[_ODPABC] = __strictParseInt32(output[_ODPABC]);
    }
    if (output[_SAS] != null) {
        contents[_SAS] = __expectString(output[_SAS]);
    }
    if (output[_SIPp] != null) {
        contents[_SIPp] = __strictParseInt32(output[_SIPp]);
    }
    if (output[_SMP] != null) {
        contents[_SMP] = __expectString(output[_SMP]);
    }
    return contents;
};
const de_InvalidNextToken = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_IrreversibleInstanceRefreshFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_LaunchConfiguration = (output, context) => {
    const contents = {};
    if (output[_LCN] != null) {
        contents[_LCN] = __expectString(output[_LCN]);
    }
    if (output[_LCARN] != null) {
        contents[_LCARN] = __expectString(output[_LCARN]);
    }
    if (output[_IIm] != null) {
        contents[_IIm] = __expectString(output[_IIm]);
    }
    if (output[_KN] != null) {
        contents[_KN] = __expectString(output[_KN]);
    }
    if (output.SecurityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_SG] != null && output[_SG][_me] != null) {
        contents[_SG] = de_SecurityGroups(__getArrayIfSingleItem(output[_SG][_me]), context);
    }
    if (output[_CLVPCI] != null) {
        contents[_CLVPCI] = __expectString(output[_CLVPCI]);
    }
    if (output.ClassicLinkVPCSecurityGroups === "") {
        contents[_CLVPCSG] = [];
    }
    else if (output[_CLVPCSG] != null && output[_CLVPCSG][_me] != null) {
        contents[_CLVPCSG] = de_ClassicLinkVPCSecurityGroups(__getArrayIfSingleItem(output[_CLVPCSG][_me]), context);
    }
    if (output[_UD] != null) {
        contents[_UD] = __expectString(output[_UD]);
    }
    if (output[_IT] != null) {
        contents[_IT] = __expectString(output[_IT]);
    }
    if (output[_KI] != null) {
        contents[_KI] = __expectString(output[_KI]);
    }
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    if (output.BlockDeviceMappings === "") {
        contents[_BDM] = [];
    }
    else if (output[_BDM] != null && output[_BDM][_me] != null) {
        contents[_BDM] = de_BlockDeviceMappings(__getArrayIfSingleItem(output[_BDM][_me]), context);
    }
    if (output[_IM] != null) {
        contents[_IM] = de_InstanceMonitoring(output[_IM], context);
    }
    if (output[_SPp] != null) {
        contents[_SPp] = __expectString(output[_SPp]);
    }
    if (output[_IIP] != null) {
        contents[_IIP] = __expectString(output[_IIP]);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CT]));
    }
    if (output[_EO] != null) {
        contents[_EO] = __parseBoolean(output[_EO]);
    }
    if (output[_APIA] != null) {
        contents[_APIA] = __parseBoolean(output[_APIA]);
    }
    if (output[_PT] != null) {
        contents[_PT] = __expectString(output[_PT]);
    }
    if (output[_MO] != null) {
        contents[_MO] = de_InstanceMetadataOptions(output[_MO], context);
    }
    return contents;
};
const de_LaunchConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchConfiguration(entry, context);
    });
};
const de_LaunchConfigurationsType = (output, context) => {
    const contents = {};
    if (output.LaunchConfigurations === "") {
        contents[_LC] = [];
    }
    else if (output[_LC] != null && output[_LC][_me] != null) {
        contents[_LC] = de_LaunchConfigurations(__getArrayIfSingleItem(output[_LC][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_LaunchTemplate = (output, context) => {
    const contents = {};
    if (output[_LTS] != null) {
        contents[_LTS] = de_LaunchTemplateSpecification(output[_LTS], context);
    }
    if (output.Overrides === "") {
        contents[_O] = [];
    }
    else if (output[_O] != null && output[_O][_me] != null) {
        contents[_O] = de_Overrides(__getArrayIfSingleItem(output[_O][_me]), context);
    }
    return contents;
};
const de_LaunchTemplateOverrides = (output, context) => {
    const contents = {};
    if (output[_IT] != null) {
        contents[_IT] = __expectString(output[_IT]);
    }
    if (output[_WC] != null) {
        contents[_WC] = __expectString(output[_WC]);
    }
    if (output[_LTS] != null) {
        contents[_LTS] = de_LaunchTemplateSpecification(output[_LTS], context);
    }
    if (output[_IR] != null) {
        contents[_IR] = de_InstanceRequirements(output[_IR], context);
    }
    return contents;
};
const de_LaunchTemplateSpecification = (output, context) => {
    const contents = {};
    if (output[_LTI] != null) {
        contents[_LTI] = __expectString(output[_LTI]);
    }
    if (output[_LTN] != null) {
        contents[_LTN] = __expectString(output[_LTN]);
    }
    if (output[_V] != null) {
        contents[_V] = __expectString(output[_V]);
    }
    return contents;
};
const de_LifecycleHook = (output, context) => {
    const contents = {};
    if (output[_LHN] != null) {
        contents[_LHN] = __expectString(output[_LHN]);
    }
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_LTi] != null) {
        contents[_LTi] = __expectString(output[_LTi]);
    }
    if (output[_NTARN] != null) {
        contents[_NTARN] = __expectString(output[_NTARN]);
    }
    if (output[_RARN] != null) {
        contents[_RARN] = __expectString(output[_RARN]);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    if (output[_HTe] != null) {
        contents[_HTe] = __strictParseInt32(output[_HTe]);
    }
    if (output[_GT] != null) {
        contents[_GT] = __strictParseInt32(output[_GT]);
    }
    if (output[_DR] != null) {
        contents[_DR] = __expectString(output[_DR]);
    }
    return contents;
};
const de_LifecycleHooks = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LifecycleHook(entry, context);
    });
};
const de_LimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_LoadBalancerNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LoadBalancerState = (output, context) => {
    const contents = {};
    if (output[_LBNo] != null) {
        contents[_LBNo] = __expectString(output[_LBNo]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    return contents;
};
const de_LoadBalancerStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerState(entry, context);
    });
};
const de_LoadBalancerTargetGroupState = (output, context) => {
    const contents = {};
    if (output[_LBTGARN] != null) {
        contents[_LBTGARN] = __expectString(output[_LBTGARN]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    return contents;
};
const de_LoadBalancerTargetGroupStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerTargetGroupState(entry, context);
    });
};
const de_LoadForecast = (output, context) => {
    const contents = {};
    if (output.Timestamps === "") {
        contents[_Tim] = [];
    }
    else if (output[_Tim] != null && output[_Tim][_me] != null) {
        contents[_Tim] = de_PredictiveScalingForecastTimestamps(__getArrayIfSingleItem(output[_Tim][_me]), context);
    }
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_me] != null) {
        contents[_Va] = de_PredictiveScalingForecastValues(__getArrayIfSingleItem(output[_Va][_me]), context);
    }
    if (output[_MSetr] != null) {
        contents[_MSetr] = de_PredictiveScalingMetricSpecification(output[_MSetr], context);
    }
    return contents;
};
const de_LoadForecasts = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadForecast(entry, context);
    });
};
const de_LocalStorageTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MemoryGiBPerVCpuRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseFloat(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_Ma]);
    }
    return contents;
};
const de_MemoryMiBRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_Metric = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_me] != null) {
        contents[_D] = de_MetricDimensions(__getArrayIfSingleItem(output[_D][_me]), context);
    }
    return contents;
};
const de_MetricCollectionType = (output, context) => {
    const contents = {};
    if (output[_Met] != null) {
        contents[_Met] = __expectString(output[_Met]);
    }
    return contents;
};
const de_MetricCollectionTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricCollectionType(entry, context);
    });
};
const de_MetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataQuery(entry, context);
    });
};
const de_MetricDataQuery = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = __expectString(output[_Id]);
    }
    if (output[_Ex] != null) {
        contents[_Ex] = __expectString(output[_Ex]);
    }
    if (output[_MSe] != null) {
        contents[_MSe] = de_MetricStat(output[_MSe], context);
    }
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    if (output[_RD] != null) {
        contents[_RD] = __parseBoolean(output[_RD]);
    }
    return contents;
};
const de_MetricDimension = (output, context) => {
    const contents = {};
    if (output[_Na] != null) {
        contents[_Na] = __expectString(output[_Na]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_MetricDimensions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDimension(entry, context);
    });
};
const de_MetricGranularityType = (output, context) => {
    const contents = {};
    if (output[_G] != null) {
        contents[_G] = __expectString(output[_G]);
    }
    return contents;
};
const de_MetricGranularityTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricGranularityType(entry, context);
    });
};
const de_MetricStat = (output, context) => {
    const contents = {};
    if (output[_Met] != null) {
        contents[_Met] = de_Metric(output[_Met], context);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    return contents;
};
const de_MixedInstancesPolicy = (output, context) => {
    const contents = {};
    if (output[_LT] != null) {
        contents[_LT] = de_LaunchTemplate(output[_LT], context);
    }
    if (output[_ID] != null) {
        contents[_ID] = de_InstancesDistribution(output[_ID], context);
    }
    return contents;
};
const de_NetworkBandwidthGbpsRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseFloat(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_Ma]);
    }
    return contents;
};
const de_NetworkInterfaceCountRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_NotificationConfiguration = (output, context) => {
    const contents = {};
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_TARN] != null) {
        contents[_TARN] = __expectString(output[_TARN]);
    }
    if (output[_NTot] != null) {
        contents[_NTot] = __expectString(output[_NTot]);
    }
    return contents;
};
const de_NotificationConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NotificationConfiguration(entry, context);
    });
};
const de_Overrides = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateOverrides(entry, context);
    });
};
const de_PoliciesType = (output, context) => {
    const contents = {};
    if (output.ScalingPolicies === "") {
        contents[_SPca] = [];
    }
    else if (output[_SPca] != null && output[_SPca][_me] != null) {
        contents[_SPca] = de_ScalingPolicies(__getArrayIfSingleItem(output[_SPca][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_PolicyARNType = (output, context) => {
    const contents = {};
    if (output[_PARN] != null) {
        contents[_PARN] = __expectString(output[_PARN]);
    }
    if (output.Alarms === "") {
        contents[_Al] = [];
    }
    else if (output[_Al] != null && output[_Al][_me] != null) {
        contents[_Al] = de_Alarms(__getArrayIfSingleItem(output[_Al][_me]), context);
    }
    return contents;
};
const de_PredefinedMetricSpecification = (output, context) => {
    const contents = {};
    if (output[_PMT] != null) {
        contents[_PMT] = __expectString(output[_PMT]);
    }
    if (output[_RL] != null) {
        contents[_RL] = __expectString(output[_RL]);
    }
    return contents;
};
const de_PredictiveScalingConfiguration = (output, context) => {
    const contents = {};
    if (output.MetricSpecifications === "") {
        contents[_MSet] = [];
    }
    else if (output[_MSet] != null && output[_MSet][_me] != null) {
        contents[_MSet] = de_PredictiveScalingMetricSpecifications(__getArrayIfSingleItem(output[_MSet][_me]), context);
    }
    if (output[_Mo] != null) {
        contents[_Mo] = __expectString(output[_Mo]);
    }
    if (output[_SBT] != null) {
        contents[_SBT] = __strictParseInt32(output[_SBT]);
    }
    if (output[_MCBB] != null) {
        contents[_MCBB] = __expectString(output[_MCBB]);
    }
    if (output[_MCB] != null) {
        contents[_MCB] = __strictParseInt32(output[_MCB]);
    }
    return contents;
};
const de_PredictiveScalingCustomizedCapacityMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents[_MDQ] = [];
    }
    else if (output[_MDQ] != null && output[_MDQ][_me] != null) {
        contents[_MDQ] = de_MetricDataQueries(__getArrayIfSingleItem(output[_MDQ][_me]), context);
    }
    return contents;
};
const de_PredictiveScalingCustomizedLoadMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents[_MDQ] = [];
    }
    else if (output[_MDQ] != null && output[_MDQ][_me] != null) {
        contents[_MDQ] = de_MetricDataQueries(__getArrayIfSingleItem(output[_MDQ][_me]), context);
    }
    return contents;
};
const de_PredictiveScalingCustomizedScalingMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents[_MDQ] = [];
    }
    else if (output[_MDQ] != null && output[_MDQ][_me] != null) {
        contents[_MDQ] = de_MetricDataQueries(__getArrayIfSingleItem(output[_MDQ][_me]), context);
    }
    return contents;
};
const de_PredictiveScalingForecastTimestamps = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_PredictiveScalingForecastValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseFloat(entry);
    });
};
const de_PredictiveScalingMetricSpecification = (output, context) => {
    const contents = {};
    if (output[_TV] != null) {
        contents[_TV] = __strictParseFloat(output[_TV]);
    }
    if (output[_PMPS] != null) {
        contents[_PMPS] = de_PredictiveScalingPredefinedMetricPair(output[_PMPS], context);
    }
    if (output[_PSMS] != null) {
        contents[_PSMS] = de_PredictiveScalingPredefinedScalingMetric(output[_PSMS], context);
    }
    if (output[_PLMS] != null) {
        contents[_PLMS] = de_PredictiveScalingPredefinedLoadMetric(output[_PLMS], context);
    }
    if (output[_CSMS] != null) {
        contents[_CSMS] = de_PredictiveScalingCustomizedScalingMetric(output[_CSMS], context);
    }
    if (output[_CLMS] != null) {
        contents[_CLMS] = de_PredictiveScalingCustomizedLoadMetric(output[_CLMS], context);
    }
    if (output[_CCMS] != null) {
        contents[_CCMS] = de_PredictiveScalingCustomizedCapacityMetric(output[_CCMS], context);
    }
    return contents;
};
const de_PredictiveScalingMetricSpecifications = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PredictiveScalingMetricSpecification(entry, context);
    });
};
const de_PredictiveScalingPredefinedLoadMetric = (output, context) => {
    const contents = {};
    if (output[_PMT] != null) {
        contents[_PMT] = __expectString(output[_PMT]);
    }
    if (output[_RL] != null) {
        contents[_RL] = __expectString(output[_RL]);
    }
    return contents;
};
const de_PredictiveScalingPredefinedMetricPair = (output, context) => {
    const contents = {};
    if (output[_PMT] != null) {
        contents[_PMT] = __expectString(output[_PMT]);
    }
    if (output[_RL] != null) {
        contents[_RL] = __expectString(output[_RL]);
    }
    return contents;
};
const de_PredictiveScalingPredefinedScalingMetric = (output, context) => {
    const contents = {};
    if (output[_PMT] != null) {
        contents[_PMT] = __expectString(output[_PMT]);
    }
    if (output[_RL] != null) {
        contents[_RL] = __expectString(output[_RL]);
    }
    return contents;
};
const de_Processes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProcessType(entry, context);
    });
};
const de_ProcessesType = (output, context) => {
    const contents = {};
    if (output.Processes === "") {
        contents[_Pro] = [];
    }
    else if (output[_Pro] != null && output[_Pro][_me] != null) {
        contents[_Pro] = de_Processes(__getArrayIfSingleItem(output[_Pro][_me]), context);
    }
    return contents;
};
const de_ProcessType = (output, context) => {
    const contents = {};
    if (output[_PNr] != null) {
        contents[_PNr] = __expectString(output[_PNr]);
    }
    return contents;
};
const de_PutLifecycleHookAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutWarmPoolAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_RecordLifecycleActionHeartbeatAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_RefreshPreferences = (output, context) => {
    const contents = {};
    if (output[_MHP] != null) {
        contents[_MHP] = __strictParseInt32(output[_MHP]);
    }
    if (output[_IW] != null) {
        contents[_IW] = __strictParseInt32(output[_IW]);
    }
    if (output.CheckpointPercentages === "") {
        contents[_CP] = [];
    }
    else if (output[_CP] != null && output[_CP][_me] != null) {
        contents[_CP] = de_CheckpointPercentages(__getArrayIfSingleItem(output[_CP][_me]), context);
    }
    if (output[_CD] != null) {
        contents[_CD] = __strictParseInt32(output[_CD]);
    }
    if (output[_SM] != null) {
        contents[_SM] = __parseBoolean(output[_SM]);
    }
    if (output[_AR] != null) {
        contents[_AR] = __parseBoolean(output[_AR]);
    }
    if (output[_SIPI] != null) {
        contents[_SIPI] = __expectString(output[_SIPI]);
    }
    if (output[_SIt] != null) {
        contents[_SIt] = __expectString(output[_SIt]);
    }
    if (output[_AS] != null) {
        contents[_AS] = de_AlarmSpecification(output[_AS], context);
    }
    if (output[_MHPa] != null) {
        contents[_MHPa] = __strictParseInt32(output[_MHPa]);
    }
    return contents;
};
const de_ResourceContentionFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ResourceInUseFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_RollbackDetails = (output, context) => {
    const contents = {};
    if (output[_RR] != null) {
        contents[_RR] = __expectString(output[_RR]);
    }
    if (output[_RST] != null) {
        contents[_RST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_RST]));
    }
    if (output[_PCOR] != null) {
        contents[_PCOR] = __strictParseInt32(output[_PCOR]);
    }
    if (output[_ITUOR] != null) {
        contents[_ITUOR] = __strictParseInt32(output[_ITUOR]);
    }
    if (output[_PDOR] != null) {
        contents[_PDOR] = de_InstanceRefreshProgressDetails(output[_PDOR], context);
    }
    return contents;
};
const de_RollbackInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output[_IRIn] != null) {
        contents[_IRIn] = __expectString(output[_IRIn]);
    }
    return contents;
};
const de_ScalingActivityInProgressFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScalingPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScalingPolicy(entry, context);
    });
};
const de_ScalingPolicy = (output, context) => {
    const contents = {};
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PARN] != null) {
        contents[_PARN] = __expectString(output[_PARN]);
    }
    if (output[_PTol] != null) {
        contents[_PTol] = __expectString(output[_PTol]);
    }
    if (output[_ATd] != null) {
        contents[_ATd] = __expectString(output[_ATd]);
    }
    if (output[_MAS] != null) {
        contents[_MAS] = __strictParseInt32(output[_MAS]);
    }
    if (output[_MAM] != null) {
        contents[_MAM] = __strictParseInt32(output[_MAM]);
    }
    if (output[_SA] != null) {
        contents[_SA] = __strictParseInt32(output[_SA]);
    }
    if (output[_Co] != null) {
        contents[_Co] = __strictParseInt32(output[_Co]);
    }
    if (output.StepAdjustments === "") {
        contents[_SAt] = [];
    }
    else if (output[_SAt] != null && output[_SAt][_me] != null) {
        contents[_SAt] = de_StepAdjustments(__getArrayIfSingleItem(output[_SAt][_me]), context);
    }
    if (output[_MAT] != null) {
        contents[_MAT] = __expectString(output[_MAT]);
    }
    if (output[_EIW] != null) {
        contents[_EIW] = __strictParseInt32(output[_EIW]);
    }
    if (output.Alarms === "") {
        contents[_Al] = [];
    }
    else if (output[_Al] != null && output[_Al][_me] != null) {
        contents[_Al] = de_Alarms(__getArrayIfSingleItem(output[_Al][_me]), context);
    }
    if (output[_TTC] != null) {
        contents[_TTC] = de_TargetTrackingConfiguration(output[_TTC], context);
    }
    if (output[_Ena] != null) {
        contents[_Ena] = __parseBoolean(output[_Ena]);
    }
    if (output[_PSC] != null) {
        contents[_PSC] = de_PredictiveScalingConfiguration(output[_PSC], context);
    }
    return contents;
};
const de_ScheduledActionsType = (output, context) => {
    const contents = {};
    if (output.ScheduledUpdateGroupActions === "") {
        contents[_SUGA] = [];
    }
    else if (output[_SUGA] != null && output[_SUGA][_me] != null) {
        contents[_SUGA] = de_ScheduledUpdateGroupActions(__getArrayIfSingleItem(output[_SUGA][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_ScheduledUpdateGroupAction = (output, context) => {
    const contents = {};
    if (output[_ASGN] != null) {
        contents[_ASGN] = __expectString(output[_ASGN]);
    }
    if (output[_SANc] != null) {
        contents[_SANc] = __expectString(output[_SANc]);
    }
    if (output[_SAARN] != null) {
        contents[_SAARN] = __expectString(output[_SAARN]);
    }
    if (output[_Ti] != null) {
        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ST]));
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output[_MS] != null) {
        contents[_MS] = __strictParseInt32(output[_MS]);
    }
    if (output[_MSa] != null) {
        contents[_MSa] = __strictParseInt32(output[_MSa]);
    }
    if (output[_DC] != null) {
        contents[_DC] = __strictParseInt32(output[_DC]);
    }
    if (output[_TZ] != null) {
        contents[_TZ] = __expectString(output[_TZ]);
    }
    return contents;
};
const de_ScheduledUpdateGroupActions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledUpdateGroupAction(entry, context);
    });
};
const de_SecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ServiceLinkedRoleFailure = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SetInstanceProtectionAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_StartInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output[_IRIn] != null) {
        contents[_IRIn] = __expectString(output[_IRIn]);
    }
    return contents;
};
const de_StepAdjustment = (output, context) => {
    const contents = {};
    if (output[_MILB] != null) {
        contents[_MILB] = __strictParseFloat(output[_MILB]);
    }
    if (output[_MIUB] != null) {
        contents[_MIUB] = __strictParseFloat(output[_MIUB]);
    }
    if (output[_SA] != null) {
        contents[_SA] = __strictParseInt32(output[_SA]);
    }
    return contents;
};
const de_StepAdjustments = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StepAdjustment(entry, context);
    });
};
const de_SuspendedProcess = (output, context) => {
    const contents = {};
    if (output[_PNr] != null) {
        contents[_PNr] = __expectString(output[_PNr]);
    }
    if (output[_SRu] != null) {
        contents[_SRu] = __expectString(output[_SRu]);
    }
    return contents;
};
const de_SuspendedProcesses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SuspendedProcess(entry, context);
    });
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output[_RIe] != null) {
        contents[_RIe] = __expectString(output[_RIe]);
    }
    if (output[_RT] != null) {
        contents[_RT] = __expectString(output[_RT]);
    }
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    if (output[_PAL] != null) {
        contents[_PAL] = __parseBoolean(output[_PAL]);
    }
    return contents;
};
const de_TagDescriptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagsType = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_me] != null) {
        contents[_T] = de_TagDescriptionList(__getArrayIfSingleItem(output[_T][_me]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_TargetGroupARNs = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TargetTrackingConfiguration = (output, context) => {
    const contents = {};
    if (output[_PMS] != null) {
        contents[_PMS] = de_PredefinedMetricSpecification(output[_PMS], context);
    }
    if (output[_CMS] != null) {
        contents[_CMS] = de_CustomizedMetricSpecification(output[_CMS], context);
    }
    if (output[_TV] != null) {
        contents[_TV] = __strictParseFloat(output[_TV]);
    }
    if (output[_DSI] != null) {
        contents[_DSI] = __parseBoolean(output[_DSI]);
    }
    return contents;
};
const de_TargetTrackingMetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetTrackingMetricDataQuery(entry, context);
    });
};
const de_TargetTrackingMetricDataQuery = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = __expectString(output[_Id]);
    }
    if (output[_Ex] != null) {
        contents[_Ex] = __expectString(output[_Ex]);
    }
    if (output[_MSe] != null) {
        contents[_MSe] = de_TargetTrackingMetricStat(output[_MSe], context);
    }
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    if (output[_RD] != null) {
        contents[_RD] = __parseBoolean(output[_RD]);
    }
    return contents;
};
const de_TargetTrackingMetricStat = (output, context) => {
    const contents = {};
    if (output[_Met] != null) {
        contents[_Met] = de_Metric(output[_Met], context);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    return contents;
};
const de_TerminationPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TotalLocalStorageGBRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseFloat(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_Ma]);
    }
    return contents;
};
const de_TrafficSourceIdentifier = (output, context) => {
    const contents = {};
    if (output[_Ide] != null) {
        contents[_Ide] = __expectString(output[_Ide]);
    }
    if (output[_Ty] != null) {
        contents[_Ty] = __expectString(output[_Ty]);
    }
    return contents;
};
const de_TrafficSources = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficSourceIdentifier(entry, context);
    });
};
const de_TrafficSourceState = (output, context) => {
    const contents = {};
    if (output[_TSr] != null) {
        contents[_TSr] = __expectString(output[_TSr]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    if (output[_Ide] != null) {
        contents[_Ide] = __expectString(output[_Ide]);
    }
    if (output[_Ty] != null) {
        contents[_Ty] = __expectString(output[_Ty]);
    }
    return contents;
};
const de_TrafficSourceStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficSourceState(entry, context);
    });
};
const de_VCpuCountRequest = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __strictParseInt32(output[_M]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_Ma]);
    }
    return contents;
};
const de_WarmPoolConfiguration = (output, context) => {
    const contents = {};
    if (output[_MGPC] != null) {
        contents[_MGPC] = __strictParseInt32(output[_MGPC]);
    }
    if (output[_MS] != null) {
        contents[_MS] = __strictParseInt32(output[_MS]);
    }
    if (output[_PS] != null) {
        contents[_PS] = __expectString(output[_PS]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output[_IRP] != null) {
        contents[_IRP] = de_InstanceReusePolicy(output[_IRP], context);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2011-01-01";
const _A = "Action";
const _AARN = "AlarmARN";
const _AC = "AcceleratorCount";
const _AI = "AttachInstances";
const _AIT = "AllowedInstanceTypes";
const _AIc = "ActivityIds";
const _AIct = "ActivityId";
const _ALB = "AttachLoadBalancers";
const _ALBTG = "AttachLoadBalancerTargetGroups";
const _AM = "AcceleratorManufacturers";
const _AN = "AcceleratorNames";
const _ANl = "AlarmName";
const _APIA = "AssociatePublicIpAddress";
const _AR = "AutoRollback";
const _AS = "AlarmSpecification";
const _ASG = "AutoScalingGroups";
const _ASGARN = "AutoScalingGroupARN";
const _ASGN = "AutoScalingGroupName";
const _ASGNu = "AutoScalingGroupNames";
const _ASGS = "AutoScalingGroupState";
const _ASI = "AutoScalingInstances";
const _ASNT = "AutoScalingNotificationTypes";
const _AT = "AcceleratorTypes";
const _ATMMB = "AcceleratorTotalMemoryMiB";
const _ATS = "AttachTrafficSources";
const _ATd = "AdjustmentType";
const _ATdj = "AdjustmentTypes";
const _AZ = "AvailabilityZones";
const _AZv = "AvailabilityZone";
const _Ac = "Activities";
const _Act = "Activity";
const _Al = "Alarms";
const _BDM = "BlockDeviceMappings";
const _BDSA = "BatchDeleteScheduledAction";
const _BEBM = "BaselineEbsBandwidthMbps";
const _BM = "BareMetal";
const _BP = "BurstablePerformance";
const _BPSUGA = "BatchPutScheduledUpdateGroupAction";
const _BT = "BreachThreshold";
const _C = "Context";
const _CASG = "CreateAutoScalingGroup";
const _CCMS = "CustomizedCapacityMetricSpecification";
const _CD = "CheckpointDelay";
const _CF = "CapacityForecast";
const _CIR = "CancelInstanceRefresh";
const _CLA = "CompleteLifecycleAction";
const _CLC = "CreateLaunchConfiguration";
const _CLMS = "CustomizedLoadMetricSpecification";
const _CLVPCI = "ClassicLinkVPCId";
const _CLVPCSG = "ClassicLinkVPCSecurityGroups";
const _CM = "CpuManufacturers";
const _CMS = "CustomizedMetricSpecification";
const _COUT = "CreateOrUpdateTags";
const _CP = "CheckpointPercentages";
const _CR = "CapacityRebalance";
const _CSMS = "CustomizedScalingMetricSpecification";
const _CT = "CreatedTime";
const _Ca = "Cause";
const _Co = "Cooldown";
const _D = "Dimensions";
const _DAL = "DescribeAccountLimits";
const _DASG = "DeleteAutoScalingGroup";
const _DASGe = "DescribeAutoScalingGroups";
const _DASI = "DescribeAutoScalingInstances";
const _DASNT = "DescribeAutoScalingNotificationTypes";
const _DAT = "DescribeAdjustmentTypes";
const _DC = "DesiredCapacity";
const _DCT = "DesiredCapacityType";
const _DCe = "DefaultCooldown";
const _DCes = "DesiredConfiguration";
const _DI = "DetachInstances";
const _DIR = "DescribeInstanceRefreshes";
const _DIW = "DefaultInstanceWarmup";
const _DLB = "DescribeLoadBalancers";
const _DLBTG = "DescribeLoadBalancerTargetGroups";
const _DLBTGe = "DetachLoadBalancerTargetGroups";
const _DLBe = "DetachLoadBalancers";
const _DLC = "DeleteLaunchConfiguration";
const _DLCe = "DescribeLaunchConfigurations";
const _DLH = "DeleteLifecycleHook";
const _DLHT = "DescribeLifecycleHookTypes";
const _DLHe = "DescribeLifecycleHooks";
const _DMC = "DisableMetricsCollection";
const _DMCT = "DescribeMetricCollectionTypes";
const _DN = "DeviceName";
const _DNC = "DeleteNotificationConfiguration";
const _DNCe = "DescribeNotificationConfigurations";
const _DOT = "DeleteOnTermination";
const _DP = "DeletePolicy";
const _DPe = "DescribePolicies";
const _DR = "DefaultResult";
const _DSA = "DeleteScheduledAction";
const _DSAe = "DescribeScalingActivities";
const _DSAes = "DescribeScheduledActions";
const _DSI = "DisableScaleIn";
const _DSPT = "DescribeScalingProcessTypes";
const _DT = "DeleteTags";
const _DTPT = "DescribeTerminationPolicyTypes";
const _DTS = "DescribeTrafficSources";
const _DTSe = "DetachTrafficSources";
const _DTe = "DescribeTags";
const _DWP = "DeleteWarmPool";
const _DWPe = "DescribeWarmPool";
const _De = "Description";
const _Det = "Details";
const _E = "Ebs";
const _EC = "ErrorCode";
const _EIT = "ExcludedInstanceTypes";
const _EIW = "EstimatedInstanceWarmup";
const _EM = "EnabledMetrics";
const _EMC = "EnableMetricsCollection";
const _EMr = "ErrorMessage";
const _EO = "EbsOptimized";
const _EP = "ExecutePolicy";
const _ES = "EnterStandby";
const _ESx = "ExitStandby";
const _ET = "EndTime";
const _En = "Encrypted";
const _Ena = "Enabled";
const _Ex = "Expression";
const _F = "Filters";
const _FD = "ForceDelete";
const _FSA = "FailedScheduledActions";
const _FSUGA = "FailedScheduledUpdateGroupActions";
const _G = "Granularity";
const _GPSF = "GetPredictiveScalingForecast";
const _GT = "GlobalTimeout";
const _Gr = "Granularities";
const _HC = "HonorCooldown";
const _HCGP = "HealthCheckGracePeriod";
const _HCT = "HealthCheckType";
const _HE = "HttpEndpoint";
const _HPRHL = "HttpPutResponseHopLimit";
const _HS = "HealthStatus";
const _HT = "HttpTokens";
const _HTe = "HeartbeatTimeout";
const _I = "Iops";
const _ID = "InstancesDistribution";
const _IDG = "IncludeDeletedGroups";
const _IG = "InstanceGenerations";
const _II = "InstanceIds";
const _IIP = "IamInstanceProfile";
const _IIm = "ImageId";
const _IIn = "InstanceId";
const _IM = "InstanceMonitoring";
const _IMP = "InstanceMaintenancePolicy";
const _IR = "InstanceRequirements";
const _IRI = "InstanceRefreshIds";
const _IRIn = "InstanceRefreshId";
const _IRP = "InstanceReusePolicy";
const _IRn = "InstanceRefreshes";
const _IT = "InstanceType";
const _ITU = "InstancesToUpdate";
const _ITUOR = "InstancesToUpdateOnRollback";
const _IW = "InstanceWarmup";
const _Id = "Id";
const _Ide = "Identifier";
const _In = "Instances";
const _K = "Key";
const _KI = "KernelId";
const _KN = "KeyName";
const _L = "Label";
const _LAR = "LifecycleActionResult";
const _LAT = "LifecycleActionToken";
const _LB = "LoadBalancers";
const _LBN = "LoadBalancerNames";
const _LBNo = "LoadBalancerName";
const _LBTG = "LoadBalancerTargetGroups";
const _LBTGARN = "LoadBalancerTargetGroupARN";
const _LC = "LaunchConfigurations";
const _LCARN = "LaunchConfigurationARN";
const _LCN = "LaunchConfigurationName";
const _LCNa = "LaunchConfigurationNames";
const _LF = "LoadForecast";
const _LH = "LifecycleHooks";
const _LHN = "LifecycleHookName";
const _LHNi = "LifecycleHookNames";
const _LHSL = "LifecycleHookSpecificationList";
const _LHT = "LifecycleHookTypes";
const _LPP = "LivePoolProgress";
const _LS = "LocalStorage";
const _LST = "LocalStorageTypes";
const _LSi = "LifecycleState";
const _LT = "LaunchTemplate";
const _LTI = "LaunchTemplateId";
const _LTN = "LaunchTemplateName";
const _LTS = "LaunchTemplateSpecification";
const _LTi = "LifecycleTransition";
const _M = "Min";
const _MAM = "MinAdjustmentMagnitude";
const _MAS = "MinAdjustmentStep";
const _MAT = "MetricAggregationType";
const _MCB = "MaxCapacityBuffer";
const _MCBB = "MaxCapacityBreachBehavior";
const _MDQ = "MetricDataQueries";
const _MGBPVC = "MemoryGiBPerVCpu";
const _MGPC = "MaxGroupPreparedCapacity";
const _MHP = "MinHealthyPercentage";
const _MHPa = "MaxHealthyPercentage";
const _MIL = "MaxInstanceLifetime";
const _MILB = "MetricIntervalLowerBound";
const _MIP = "MixedInstancesPolicy";
const _MIUB = "MetricIntervalUpperBound";
const _MMB = "MemoryMiB";
const _MN = "MetricName";
const _MNOASG = "MaxNumberOfAutoScalingGroups";
const _MNOLC = "MaxNumberOfLaunchConfigurations";
const _MO = "MetadataOptions";
const _MR = "MaxRecords";
const _MS = "MinSize";
const _MSPAPOOODP = "MaxSpotPriceAsPercentageOfOptimalOnDemandPrice";
const _MSa = "MaxSize";
const _MSe = "MetricStat";
const _MSet = "MetricSpecifications";
const _MSetr = "MetricSpecification";
const _MV = "MetricValue";
const _Ma = "Max";
const _Me = "Metrics";
const _Met = "Metric";
const _Mo = "Mode";
const _N = "Namespace";
const _NBG = "NetworkBandwidthGbps";
const _NC = "NotificationConfigurations";
const _ND = "NoDevice";
const _NIC = "NetworkInterfaceCount";
const _NIPFSI = "NewInstancesProtectedFromScaleIn";
const _NM = "NotificationMetadata";
const _NOASG = "NumberOfAutoScalingGroups";
const _NOLC = "NumberOfLaunchConfigurations";
const _NT = "NextToken";
const _NTARN = "NotificationTargetARN";
const _NTo = "NotificationTypes";
const _NTot = "NotificationType";
const _Na = "Name";
const _O = "Overrides";
const _ODAS = "OnDemandAllocationStrategy";
const _ODBC = "OnDemandBaseCapacity";
const _ODMPPOLP = "OnDemandMaxPricePercentageOverLowestPrice";
const _ODPABC = "OnDemandPercentageAboveBaseCapacity";
const _P = "Preferences";
const _PAL = "PropagateAtLaunch";
const _PARN = "PolicyARN";
const _PC = "PredictedCapacity";
const _PCOR = "PercentageCompleteOnRollback";
const _PCe = "PercentageComplete";
const _PD = "ProgressDetails";
const _PDOR = "ProgressDetailsOnRollback";
const _PFSI = "ProtectedFromScaleIn";
const _PG = "PlacementGroup";
const _PLH = "PutLifecycleHook";
const _PLMS = "PredefinedLoadMetricSpecification";
const _PMPS = "PredefinedMetricPairSpecification";
const _PMS = "PredefinedMetricSpecification";
const _PMT = "PredefinedMetricType";
const _PN = "PolicyName";
const _PNC = "PutNotificationConfiguration";
const _PNo = "PolicyNames";
const _PNr = "ProcessName";
const _PS = "PoolState";
const _PSC = "PredictiveScalingConfiguration";
const _PSMS = "PredefinedScalingMetricSpecification";
const _PSP = "PutScalingPolicy";
const _PSUGA = "PutScheduledUpdateGroupAction";
const _PT = "PlacementTenancy";
const _PTo = "PolicyTypes";
const _PTol = "PolicyType";
const _PWP = "PutWarmPool";
const _Pr = "Progress";
const _Pro = "Processes";
const _R = "Recurrence";
const _RARN = "RoleARN";
const _RD = "ReturnData";
const _RDo = "RollbackDetails";
const _RHS = "RequireHibernateSupport";
const _RI = "RamdiskId";
const _RIR = "RollbackInstanceRefresh";
const _RIe = "ResourceId";
const _RL = "ResourceLabel";
const _RLAH = "RecordLifecycleActionHeartbeat";
const _ROSI = "ReuseOnScaleIn";
const _RP = "ResumeProcesses";
const _RR = "RollbackReason";
const _RST = "RollbackStartTime";
const _RT = "ResourceType";
const _S = "Statistic";
const _SA = "ScalingAdjustment";
const _SAARN = "ScheduledActionARN";
const _SAN = "ScheduledActionNames";
const _SANc = "ScheduledActionName";
const _SAS = "SpotAllocationStrategy";
const _SAt = "StepAdjustments";
const _SBT = "SchedulingBufferTime";
const _SC = "StatusCode";
const _SDC = "SetDesiredCapacity";
const _SDDC = "ShouldDecrementDesiredCapacity";
const _SG = "SecurityGroups";
const _SI = "SnapshotId";
const _SIH = "SetInstanceHealth";
const _SIP = "SetInstanceProtection";
const _SIPI = "ScaleInProtectedInstances";
const _SIPp = "SpotInstancePools";
const _SIR = "StartInstanceRefresh";
const _SIt = "StandbyInstances";
const _SLRARN = "ServiceLinkedRoleARN";
const _SM = "SkipMatching";
const _SMP = "SpotMaxPrice";
const _SMPPOLP = "SpotMaxPricePercentageOverLowestPrice";
const _SMt = "StatusMessage";
const _SP = "SuspendProcesses";
const _SPc = "ScalingProcesses";
const _SPca = "ScalingPolicies";
const _SPp = "SpotPrice";
const _SPu = "SuspendedProcesses";
const _SR = "StatusReason";
const _SRGP = "ShouldRespectGracePeriod";
const _SRu = "SuspensionReason";
const _ST = "StartTime";
const _SUGA = "ScheduledUpdateGroupActions";
const _St = "Stat";
const _Sta = "Status";
const _Stat = "State";
const _Str = "Strategy";
const _T = "Tags";
const _TARN = "TopicARN";
const _TGARN = "TargetGroupARNs";
const _TIIASG = "TerminateInstanceInAutoScalingGroup";
const _TLSGB = "TotalLocalStorageGB";
const _TP = "TerminationPolicies";
const _TPT = "TerminationPolicyTypes";
const _TS = "TrafficSources";
const _TST = "TrafficSourceType";
const _TSr = "TrafficSource";
const _TTC = "TargetTrackingConfiguration";
const _TV = "TargetValue";
const _TZ = "TimeZone";
const _Th = "Throughput";
const _Ti = "Time";
const _Tim = "Timestamps";
const _Ty = "Type";
const _U = "Unit";
const _UASG = "UpdateAutoScalingGroup";
const _UD = "UserData";
const _UT = "UpdateTime";
const _V = "Version";
const _VCC = "VCpuCount";
const _VN = "VirtualName";
const _VPCZI = "VPCZoneIdentifier";
const _VS = "VolumeSize";
const _VT = "VolumeType";
const _Va = "Values";
const _Val = "Value";
const _WC = "WeightedCapacity";
const _WPC = "WarmPoolConfiguration";
const _WPP = "WarmPoolProgress";
const _WPS = "WarmPoolSize";
const _m = "message";
const _me = "member";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
