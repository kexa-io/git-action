import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, strictParseInt32 as __strictParseInt32, take, withBaseException, } from "@smithy/smithy-client";
import { CodeartifactServiceException as __BaseException } from "../models/CodeartifactServiceException";
import { AccessDeniedException, ConflictException, InternalServerException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_AssociateExternalConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository/external-connection");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_ec]: [, __expectNonNull(input[_eC], `externalConnection`)],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CopyPackageVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package/versions/copy");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_sr]: [, __expectNonNull(input[_sR], `sourceRepository`)],
        [_dr]: [, __expectNonNull(input[_dR], `destinationRepository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        allowOverwrite: [],
        includeFromUpstream: [],
        versionRevisions: (_) => _json(_),
        versions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/domain");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        encryptionKey: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreatePackageGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package-group");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
    });
    let body;
    body = JSON.stringify(take(input, {
        contactInfo: [],
        description: [],
        packageGroup: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateRepositoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/repository");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        tags: (_) => _json(_),
        upstreams: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/domain");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteDomainPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/domain/permissions/policy");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pr]: [, input[_pR]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePackageGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package-group");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePackageVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package/versions/delete");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        expectedStatus: [],
        versions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteRepositoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteRepositoryPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository/permissions/policies");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_pr]: [, input[_pR]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/domain");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribePackageGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package-group");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribePackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/version");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeRepositoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DisassociateExternalConnectionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository/external-connection");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_ec]: [, __expectNonNull(input[_eC], `externalConnection`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DisposePackageVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package/versions/dispose");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        expectedStatus: [],
        versionRevisions: (_) => _json(_),
        versions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAssociatedPackageGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/get-associated-package-group");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAuthorizationTokenCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/authorization-token");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_du]: [() => input.durationSeconds !== void 0, () => input[_dS].toString()],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDomainPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/domain/permissions/policy");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetPackageVersionAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/version/asset");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
        [_a]: [, __expectNonNull(input[_a], `asset`)],
        [_re]: [, input[_pVR]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetPackageVersionReadmeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/version/readme");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetRepositoryEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository/endpoint");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetRepositoryPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repository/permissions/policy");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAllowedRepositoriesForGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package-group-allowed-repositories");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
        [_oRT]: [, __expectNonNull(input[_oRT], `originRestrictionType`)],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAssociatedPackagesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/list-associated-packages");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
        [_pre]: [() => input.preview !== void 0, () => input[_pre].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/domains");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPackageGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package-groups");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
        [_pref]: [, input[_pref]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackagesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/packages");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, input[_f]],
        [_n]: [, input[_n]],
        [_pp]: [, input[_pP]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
        [_pu]: [, input[_pu]],
        [_u]: [, input[_u]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackageVersionAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/version/assets");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackageVersionDependenciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/version/dependencies");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackageVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package/versions");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_s]: [, input[_s]],
        [_sB]: [, input[_sB]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
        [_oT]: [, input[_oT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListRepositoriesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/repositories");
    const query = map({
        [_rp]: [, input[_rP]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListRepositoriesInDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/domain/repositories");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_aa]: [, input[_aA]],
        [_rp]: [, input[_rP]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListSubPackageGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/package-groups/sub-groups");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nt]: [, input[_nT]],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/tags");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_PublishPackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_xacs]: input[_aSHA],
    });
    b.bp("/v1/package/version/publish");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
        [_v]: [, __expectNonNull(input[_pV], `packageVersion`)],
        [_a]: [, __expectNonNull(input[_aN], `assetName`)],
        [_un]: [() => input.unfinished !== void 0, () => input[_un].toString()],
    });
    let body;
    if (input.assetContent !== undefined) {
        body = input.assetContent;
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutDomainPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/domain/permissions/policy");
    let body;
    body = JSON.stringify(take(input, {
        domain: [],
        domainOwner: [],
        policyDocument: [],
        policyRevision: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutPackageOriginConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        restrictions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutRepositoryPermissionsPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/repository/permissions/policy");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        policyDocument: [],
        policyRevision: [],
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/tag");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/untag");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        tagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackageGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package-group");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
    });
    let body;
    body = JSON.stringify(take(input, {
        contactInfo: [],
        description: [],
        packageGroup: [],
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackageGroupOriginConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package-group-origin-configuration");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_pg]: [, __expectNonNull(input[_pG], `packageGroup`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        addAllowedRepositories: (_) => _json(_),
        removeAllowedRepositories: (_) => _json(_),
        restrictions: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackageVersionsStatusCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/package/versions/update_status");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
        [_f]: [, __expectNonNull(input[_f], `format`)],
        [_n]: [, input[_n]],
        [_p]: [, __expectNonNull(input[_p], `package`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        expectedStatus: [],
        targetStatus: [],
        versionRevisions: (_) => _json(_),
        versions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateRepositoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/repository");
    const query = map({
        [_d]: [, __expectNonNull(input[_d], `domain`)],
        [_do]: [, input[_dO]],
        [_r]: [, __expectNonNull(input[_r], `repository`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        upstreams: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const de_AssociateExternalConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CopyPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        failedVersions: _json,
        successfulVersions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domain: (_) => de_DomainDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreatePackageGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domain: (_) => de_DomainDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeletePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        deletedPackage: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeletePackageGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeletePackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        failedVersions: _json,
        successfulVersions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domain: (_) => de_DomainDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        package: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackageGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        packageVersion: (_) => de_PackageVersionDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DisassociateExternalConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DisposePackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        failedVersions: _json,
        successfulVersions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAssociatedPackageGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        associationType: __expectString,
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAuthorizationTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizationToken: __expectString,
        expiration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetPackageVersionAssetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_aN]: [, output.headers[_xa]],
        [_pV]: [, output.headers[_xp]],
        [_pVR]: [, output.headers[_xp_]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.asset = data;
    return contents;
};
export const de_GetPackageVersionReadmeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        format: __expectString,
        namespace: __expectString,
        package: __expectString,
        readme: __expectString,
        version: __expectString,
        versionRevision: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRepositoryEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repositoryEndpoint: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAllowedRepositoriesForGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        allowedRepositories: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssociatedPackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packages: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domains: (_) => de_DomainSummaryList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackageGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packageGroups: (_) => de_PackageGroupSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packages: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackageVersionAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        assets: _json,
        format: __expectString,
        namespace: __expectString,
        nextToken: __expectString,
        package: __expectString,
        version: __expectString,
        versionRevision: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackageVersionDependenciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dependencies: _json,
        format: __expectString,
        namespace: __expectString,
        nextToken: __expectString,
        package: __expectString,
        version: __expectString,
        versionRevision: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultDisplayVersion: __expectString,
        format: __expectString,
        namespace: __expectString,
        nextToken: __expectString,
        package: __expectString,
        versions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListRepositoriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        repositories: (_) => de_RepositorySummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListRepositoriesInDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        repositories: (_) => de_RepositorySummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSubPackageGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packageGroups: (_) => de_PackageGroupSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PublishPackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        asset: _json,
        format: __expectString,
        namespace: __expectString,
        package: __expectString,
        status: __expectString,
        version: __expectString,
        versionRevision: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutPackageOriginConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        originConfiguration: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdatePackageGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdatePackageGroupOriginConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        allowedRepositoryUpdates: _json,
        packageGroup: (_) => de_PackageGroupDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdatePackageVersionsStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        failedVersions: _json,
        successfulVersions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        repository: (_) => de_RepositoryDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [() => void 0 !== parsedOutput.headers[_ra], () => __strictParseInt32(parsedOutput.headers[_ra])],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        reason: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DomainDescription = (output, context) => {
    return take(output, {
        arn: __expectString,
        assetSizeBytes: __expectLong,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        encryptionKey: __expectString,
        name: __expectString,
        owner: __expectString,
        repositoryCount: __expectInt32,
        s3BucketArn: __expectString,
        status: __expectString,
    });
};
const de_DomainSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        encryptionKey: __expectString,
        name: __expectString,
        owner: __expectString,
        status: __expectString,
    });
};
const de_DomainSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainSummary(entry, context);
    });
    return retVal;
};
const de_PackageGroupDescription = (output, context) => {
    return take(output, {
        arn: __expectString,
        contactInfo: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        domainName: __expectString,
        domainOwner: __expectString,
        originConfiguration: _json,
        parent: _json,
        pattern: __expectString,
    });
};
const de_PackageGroupSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        contactInfo: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        domainName: __expectString,
        domainOwner: __expectString,
        originConfiguration: _json,
        parent: _json,
        pattern: __expectString,
    });
};
const de_PackageGroupSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageGroupSummary(entry, context);
    });
    return retVal;
};
const de_PackageVersionDescription = (output, context) => {
    return take(output, {
        displayName: __expectString,
        format: __expectString,
        homePage: __expectString,
        licenses: _json,
        namespace: __expectString,
        origin: _json,
        packageName: __expectString,
        publishedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        revision: __expectString,
        sourceCodeRepository: __expectString,
        status: __expectString,
        summary: __expectString,
        version: __expectString,
    });
};
const de_RepositoryDescription = (output, context) => {
    return take(output, {
        administratorAccount: __expectString,
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        domainName: __expectString,
        domainOwner: __expectString,
        externalConnections: _json,
        name: __expectString,
        upstreams: _json,
    });
};
const de_RepositorySummary = (output, context) => {
    return take(output, {
        administratorAccount: __expectString,
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        domainName: __expectString,
        domainOwner: __expectString,
        name: __expectString,
    });
};
const de_RepositorySummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RepositorySummary(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _a = "asset";
const _aA = "administratorAccount";
const _aN = "assetName";
const _aSHA = "assetSHA256";
const _aa = "administrator-account";
const _d = "domain";
const _dO = "domainOwner";
const _dR = "destinationRepository";
const _dS = "durationSeconds";
const _do = "domain-owner";
const _dr = "destination-repository";
const _du = "duration";
const _eC = "externalConnection";
const _ec = "external-connection";
const _f = "format";
const _mR = "maxResults";
const _mr = "max-results";
const _n = "namespace";
const _nT = "nextToken";
const _nt = "next-token";
const _oRT = "originRestrictionType";
const _oT = "originType";
const _p = "package";
const _pG = "packageGroup";
const _pP = "packagePrefix";
const _pR = "policyRevision";
const _pV = "packageVersion";
const _pVR = "packageVersionRevision";
const _pg = "package-group";
const _pp = "package-prefix";
const _pr = "policy-revision";
const _pre = "preview";
const _pref = "prefix";
const _pu = "publish";
const _r = "repository";
const _rA = "resourceArn";
const _rAS = "retryAfterSeconds";
const _rP = "repositoryPrefix";
const _ra = "retry-after";
const _re = "revision";
const _rp = "repository-prefix";
const _s = "status";
const _sB = "sortBy";
const _sR = "sourceRepository";
const _sr = "source-repository";
const _u = "upstream";
const _un = "unfinished";
const _v = "version";
const _xa = "x-assetname";
const _xacs = "x-amz-content-sha256";
const _xp = "x-packageversion";
const _xp_ = "x-packageversionrevision";
