import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { IvsServiceException as __BaseException } from "./IvsServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface BatchGetChannelRequest {
  arns: string[] | undefined;
}
export declare const ChannelLatencyMode: {
  readonly LowLatency: "LOW";
  readonly NormalLatency: "NORMAL";
};
export type ChannelLatencyMode =
  (typeof ChannelLatencyMode)[keyof typeof ChannelLatencyMode];
export declare const TranscodePreset: {
  readonly ConstrainedBandwidthTranscodePreset: "CONSTRAINED_BANDWIDTH_DELIVERY";
  readonly HigherBandwidthTranscodePreset: "HIGHER_BANDWIDTH_DELIVERY";
};
export type TranscodePreset =
  (typeof TranscodePreset)[keyof typeof TranscodePreset];
export declare const ChannelType: {
  readonly AdvancedHDChannelType: "ADVANCED_HD";
  readonly AdvancedSDChannelType: "ADVANCED_SD";
  readonly BasicChannelType: "BASIC";
  readonly StandardChannelType: "STANDARD";
};
export type ChannelType = (typeof ChannelType)[keyof typeof ChannelType];
export interface Channel {
  arn?: string;
  name?: string;
  latencyMode?: ChannelLatencyMode;
  type?: ChannelType;
  recordingConfigurationArn?: string;
  ingestEndpoint?: string;
  playbackUrl?: string;
  authorized?: boolean;
  tags?: Record<string, string>;
  insecureIngest?: boolean;
  preset?: TranscodePreset;
  playbackRestrictionPolicyArn?: string;
}
export interface BatchError {
  arn?: string;
  code?: string;
  message?: string;
}
export interface BatchGetChannelResponse {
  channels?: Channel[];
  errors?: BatchError[];
}
export interface BatchGetStreamKeyRequest {
  arns: string[] | undefined;
}
export interface StreamKey {
  arn?: string;
  value?: string;
  channelArn?: string;
  tags?: Record<string, string>;
}
export interface BatchGetStreamKeyResponse {
  streamKeys?: StreamKey[];
  errors?: BatchError[];
}
export interface BatchStartViewerSessionRevocationViewerSession {
  channelArn: string | undefined;
  viewerId: string | undefined;
  viewerSessionVersionsLessThanOrEqualTo?: number;
}
export interface BatchStartViewerSessionRevocationRequest {
  viewerSessions: BatchStartViewerSessionRevocationViewerSession[] | undefined;
}
export interface BatchStartViewerSessionRevocationError {
  channelArn: string | undefined;
  viewerId: string | undefined;
  code?: string;
  message?: string;
}
export interface BatchStartViewerSessionRevocationResponse {
  errors?: BatchStartViewerSessionRevocationError[];
}
export declare class PendingVerification extends __BaseException {
  readonly name: "PendingVerification";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<PendingVerification, __BaseException>
  );
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface CreateChannelRequest {
  name?: string;
  latencyMode?: ChannelLatencyMode;
  type?: ChannelType;
  authorized?: boolean;
  recordingConfigurationArn?: string;
  tags?: Record<string, string>;
  insecureIngest?: boolean;
  preset?: TranscodePreset;
  playbackRestrictionPolicyArn?: string;
}
export interface CreateChannelResponse {
  channel?: Channel;
  streamKey?: StreamKey;
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export interface CreatePlaybackRestrictionPolicyRequest {
  allowedCountries?: string[];
  allowedOrigins?: string[];
  enableStrictOriginEnforcement?: boolean;
  name?: string;
  tags?: Record<string, string>;
}
export interface PlaybackRestrictionPolicy {
  arn: string | undefined;
  allowedCountries: string[] | undefined;
  allowedOrigins: string[] | undefined;
  enableStrictOriginEnforcement?: boolean;
  name?: string;
  tags?: Record<string, string>;
}
export interface CreatePlaybackRestrictionPolicyResponse {
  playbackRestrictionPolicy?: PlaybackRestrictionPolicy;
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface S3DestinationConfiguration {
  bucketName: string | undefined;
}
export interface DestinationConfiguration {
  s3?: S3DestinationConfiguration;
}
export declare const RenditionConfigurationRendition: {
  readonly FULL_HD: "FULL_HD";
  readonly HD: "HD";
  readonly LOWEST_RESOLUTION: "LOWEST_RESOLUTION";
  readonly SD: "SD";
};
export type RenditionConfigurationRendition =
  (typeof RenditionConfigurationRendition)[keyof typeof RenditionConfigurationRendition];
export declare const RenditionConfigurationRenditionSelection: {
  readonly ALL: "ALL";
  readonly CUSTOM: "CUSTOM";
  readonly NONE: "NONE";
};
export type RenditionConfigurationRenditionSelection =
  (typeof RenditionConfigurationRenditionSelection)[keyof typeof RenditionConfigurationRenditionSelection];
export interface RenditionConfiguration {
  renditionSelection?: RenditionConfigurationRenditionSelection;
  renditions?: RenditionConfigurationRendition[];
}
export declare const RecordingMode: {
  readonly Disabled: "DISABLED";
  readonly Interval: "INTERVAL";
};
export type RecordingMode = (typeof RecordingMode)[keyof typeof RecordingMode];
export declare const ThumbnailConfigurationResolution: {
  readonly FULL_HD: "FULL_HD";
  readonly HD: "HD";
  readonly LOWEST_RESOLUTION: "LOWEST_RESOLUTION";
  readonly SD: "SD";
};
export type ThumbnailConfigurationResolution =
  (typeof ThumbnailConfigurationResolution)[keyof typeof ThumbnailConfigurationResolution];
export declare const ThumbnailConfigurationStorage: {
  readonly LATEST: "LATEST";
  readonly SEQUENTIAL: "SEQUENTIAL";
};
export type ThumbnailConfigurationStorage =
  (typeof ThumbnailConfigurationStorage)[keyof typeof ThumbnailConfigurationStorage];
export interface ThumbnailConfiguration {
  recordingMode?: RecordingMode;
  targetIntervalSeconds?: number;
  resolution?: ThumbnailConfigurationResolution;
  storage?: ThumbnailConfigurationStorage[];
}
export interface CreateRecordingConfigurationRequest {
  name?: string;
  destinationConfiguration: DestinationConfiguration | undefined;
  tags?: Record<string, string>;
  thumbnailConfiguration?: ThumbnailConfiguration;
  recordingReconnectWindowSeconds?: number;
  renditionConfiguration?: RenditionConfiguration;
}
export declare const RecordingConfigurationState: {
  readonly Active: "ACTIVE";
  readonly CreateFailed: "CREATE_FAILED";
  readonly Creating: "CREATING";
};
export type RecordingConfigurationState =
  (typeof RecordingConfigurationState)[keyof typeof RecordingConfigurationState];
export interface RecordingConfiguration {
  arn: string | undefined;
  name?: string;
  destinationConfiguration: DestinationConfiguration | undefined;
  state: RecordingConfigurationState | undefined;
  tags?: Record<string, string>;
  thumbnailConfiguration?: ThumbnailConfiguration;
  recordingReconnectWindowSeconds?: number;
  renditionConfiguration?: RenditionConfiguration;
}
export interface CreateRecordingConfigurationResponse {
  recordingConfiguration?: RecordingConfiguration;
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export interface CreateStreamKeyRequest {
  channelArn: string | undefined;
  tags?: Record<string, string>;
}
export interface CreateStreamKeyResponse {
  streamKey?: StreamKey;
}
export interface DeleteChannelRequest {
  arn: string | undefined;
}
export interface DeletePlaybackKeyPairRequest {
  arn: string | undefined;
}
export interface DeletePlaybackKeyPairResponse {}
export interface DeletePlaybackRestrictionPolicyRequest {
  arn: string | undefined;
}
export interface DeleteRecordingConfigurationRequest {
  arn: string | undefined;
}
export interface DeleteStreamKeyRequest {
  arn: string | undefined;
}
export interface GetChannelRequest {
  arn: string | undefined;
}
export interface GetChannelResponse {
  channel?: Channel;
}
export interface GetPlaybackKeyPairRequest {
  arn: string | undefined;
}
export interface PlaybackKeyPair {
  arn?: string;
  name?: string;
  fingerprint?: string;
  tags?: Record<string, string>;
}
export interface GetPlaybackKeyPairResponse {
  keyPair?: PlaybackKeyPair;
}
export interface GetPlaybackRestrictionPolicyRequest {
  arn: string | undefined;
}
export interface GetPlaybackRestrictionPolicyResponse {
  playbackRestrictionPolicy?: PlaybackRestrictionPolicy;
}
export interface GetRecordingConfigurationRequest {
  arn: string | undefined;
}
export interface GetRecordingConfigurationResponse {
  recordingConfiguration?: RecordingConfiguration;
}
export declare class ChannelNotBroadcasting extends __BaseException {
  readonly name: "ChannelNotBroadcasting";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ChannelNotBroadcasting, __BaseException>
  );
}
export interface GetStreamRequest {
  channelArn: string | undefined;
}
export declare const StreamHealth: {
  readonly Starving: "STARVING";
  readonly StreamHealthy: "HEALTHY";
  readonly Unknown: "UNKNOWN";
};
export type StreamHealth = (typeof StreamHealth)[keyof typeof StreamHealth];
export declare const StreamState: {
  readonly StreamLive: "LIVE";
  readonly StreamOffline: "OFFLINE";
};
export type StreamState = (typeof StreamState)[keyof typeof StreamState];
export interface _Stream {
  channelArn?: string;
  streamId?: string;
  playbackUrl?: string;
  startTime?: Date;
  state?: StreamState;
  health?: StreamHealth;
  viewerCount?: number;
}
export interface GetStreamResponse {
  stream?: _Stream;
}
export interface GetStreamKeyRequest {
  arn: string | undefined;
}
export interface GetStreamKeyResponse {
  streamKey?: StreamKey;
}
export interface GetStreamSessionRequest {
  channelArn: string | undefined;
  streamId?: string;
}
export interface AudioConfiguration {
  codec?: string;
  targetBitrate?: number;
  sampleRate?: number;
  channels?: number;
}
export interface VideoConfiguration {
  avcProfile?: string;
  avcLevel?: string;
  codec?: string;
  encoder?: string;
  targetBitrate?: number;
  targetFramerate?: number;
  videoHeight?: number;
  videoWidth?: number;
}
export interface IngestConfiguration {
  video?: VideoConfiguration;
  audio?: AudioConfiguration;
}
export interface StreamEvent {
  name?: string;
  type?: string;
  eventTime?: Date;
}
export interface StreamSession {
  streamId?: string;
  startTime?: Date;
  endTime?: Date;
  channel?: Channel;
  ingestConfiguration?: IngestConfiguration;
  recordingConfiguration?: RecordingConfiguration;
  truncatedEvents?: StreamEvent[];
}
export interface GetStreamSessionResponse {
  streamSession?: StreamSession;
}
export interface ImportPlaybackKeyPairRequest {
  publicKeyMaterial: string | undefined;
  name?: string;
  tags?: Record<string, string>;
}
export interface ImportPlaybackKeyPairResponse {
  keyPair?: PlaybackKeyPair;
}
export interface ListChannelsRequest {
  filterByName?: string;
  filterByRecordingConfigurationArn?: string;
  filterByPlaybackRestrictionPolicyArn?: string;
  nextToken?: string;
  maxResults?: number;
}
export interface ChannelSummary {
  arn?: string;
  name?: string;
  latencyMode?: ChannelLatencyMode;
  authorized?: boolean;
  recordingConfigurationArn?: string;
  tags?: Record<string, string>;
  insecureIngest?: boolean;
  type?: ChannelType;
  preset?: TranscodePreset;
  playbackRestrictionPolicyArn?: string;
}
export interface ListChannelsResponse {
  channels: ChannelSummary[] | undefined;
  nextToken?: string;
}
export interface ListPlaybackKeyPairsRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface PlaybackKeyPairSummary {
  arn?: string;
  name?: string;
  tags?: Record<string, string>;
}
export interface ListPlaybackKeyPairsResponse {
  keyPairs: PlaybackKeyPairSummary[] | undefined;
  nextToken?: string;
}
export interface ListPlaybackRestrictionPoliciesRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface PlaybackRestrictionPolicySummary {
  arn: string | undefined;
  allowedCountries: string[] | undefined;
  allowedOrigins: string[] | undefined;
  enableStrictOriginEnforcement?: boolean;
  name?: string;
  tags?: Record<string, string>;
}
export interface ListPlaybackRestrictionPoliciesResponse {
  playbackRestrictionPolicies: PlaybackRestrictionPolicySummary[] | undefined;
  nextToken?: string;
}
export interface ListRecordingConfigurationsRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface RecordingConfigurationSummary {
  arn: string | undefined;
  name?: string;
  destinationConfiguration: DestinationConfiguration | undefined;
  state: RecordingConfigurationState | undefined;
  tags?: Record<string, string>;
}
export interface ListRecordingConfigurationsResponse {
  recordingConfigurations: RecordingConfigurationSummary[] | undefined;
  nextToken?: string;
}
export interface ListStreamKeysRequest {
  channelArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface StreamKeySummary {
  arn?: string;
  channelArn?: string;
  tags?: Record<string, string>;
}
export interface ListStreamKeysResponse {
  streamKeys: StreamKeySummary[] | undefined;
  nextToken?: string;
}
export interface StreamFilters {
  health?: StreamHealth;
}
export interface ListStreamsRequest {
  filterBy?: StreamFilters;
  nextToken?: string;
  maxResults?: number;
}
export interface StreamSummary {
  channelArn?: string;
  streamId?: string;
  state?: StreamState;
  health?: StreamHealth;
  viewerCount?: number;
  startTime?: Date;
}
export interface ListStreamsResponse {
  streams: StreamSummary[] | undefined;
  nextToken?: string;
}
export interface ListStreamSessionsRequest {
  channelArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface StreamSessionSummary {
  streamId?: string;
  startTime?: Date;
  endTime?: Date;
  hasErrorEvent?: boolean;
}
export interface ListStreamSessionsResponse {
  streamSessions: StreamSessionSummary[] | undefined;
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags: Record<string, string> | undefined;
}
export interface PutMetadataRequest {
  channelArn: string | undefined;
  metadata: string | undefined;
}
export interface StartViewerSessionRevocationRequest {
  channelArn: string | undefined;
  viewerId: string | undefined;
  viewerSessionVersionsLessThanOrEqualTo?: number;
}
export interface StartViewerSessionRevocationResponse {}
export interface StopStreamRequest {
  channelArn: string | undefined;
}
export interface StopStreamResponse {}
export declare class StreamUnavailable extends __BaseException {
  readonly name: "StreamUnavailable";
  readonly $fault: "server";
  exceptionMessage?: string;
  constructor(opts: __ExceptionOptionType<StreamUnavailable, __BaseException>);
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface UpdateChannelRequest {
  arn: string | undefined;
  name?: string;
  latencyMode?: ChannelLatencyMode;
  type?: ChannelType;
  authorized?: boolean;
  recordingConfigurationArn?: string;
  insecureIngest?: boolean;
  preset?: TranscodePreset;
  playbackRestrictionPolicyArn?: string;
}
export interface UpdateChannelResponse {
  channel?: Channel;
}
export interface UpdatePlaybackRestrictionPolicyRequest {
  arn: string | undefined;
  allowedCountries?: string[];
  allowedOrigins?: string[];
  enableStrictOriginEnforcement?: boolean;
  name?: string;
}
export interface UpdatePlaybackRestrictionPolicyResponse {
  playbackRestrictionPolicy?: PlaybackRestrictionPolicy;
}
export declare const StreamKeyFilterSensitiveLog: (obj: StreamKey) => any;
export declare const BatchGetStreamKeyResponseFilterSensitiveLog: (
  obj: BatchGetStreamKeyResponse
) => any;
export declare const CreateChannelResponseFilterSensitiveLog: (
  obj: CreateChannelResponse
) => any;
export declare const CreateStreamKeyResponseFilterSensitiveLog: (
  obj: CreateStreamKeyResponse
) => any;
export declare const GetStreamKeyResponseFilterSensitiveLog: (
  obj: GetStreamKeyResponse
) => any;
export declare const PutMetadataRequestFilterSensitiveLog: (
  obj: PutMetadataRequest
) => any;
