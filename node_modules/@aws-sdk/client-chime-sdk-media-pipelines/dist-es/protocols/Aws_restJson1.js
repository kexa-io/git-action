import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { ChimeSDKMediaPipelinesServiceException as __BaseException } from "../models/ChimeSDKMediaPipelinesServiceException";
import { BadRequestException, ConflictException, ForbiddenException, NotFoundException, ResourceLimitExceededException, ServiceFailureException, ServiceUnavailableException, ThrottledClientException, UnauthorizedClientException, } from "../models/models_0";
export const se_CreateMediaCapturePipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/sdk-media-capture-pipelines");
    let body;
    body = JSON.stringify(take(input, {
        ChimeSdkMeetingConfiguration: (_) => _json(_),
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        SinkArn: [],
        SinkType: [],
        SourceArn: [],
        SourceType: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaConcatenationPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/sdk-media-concatenation-pipelines");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Sinks: (_) => _json(_),
        Sources: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaInsightsPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipelines");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        KinesisVideoStreamRecordingSourceRuntimeConfiguration: (_) => se_KinesisVideoStreamRecordingSourceRuntimeConfiguration(_, context),
        KinesisVideoStreamSourceRuntimeConfiguration: (_) => _json(_),
        MediaInsightsPipelineConfigurationArn: [],
        MediaInsightsRuntimeMetadata: (_) => _json(_),
        S3RecordingSinkRuntimeConfiguration: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaInsightsPipelineConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipeline-configurations");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Elements: (_) => _json(_),
        MediaInsightsPipelineConfigurationName: [],
        RealTimeAlertConfiguration: (_) => _json(_),
        ResourceAccessRoleArn: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaLiveConnectorPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/sdk-media-live-connector-pipelines");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Sinks: (_) => _json(_),
        Sources: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaPipelineKinesisVideoStreamPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-pipeline-kinesis-video-stream-pools");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        PoolName: [],
        StreamConfiguration: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMediaStreamPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/sdk-media-stream-pipelines");
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Sinks: (_) => _json(_),
        Sources: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteMediaCapturePipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-capture-pipelines/{MediaPipelineId}");
    b.p("MediaPipelineId", () => input.MediaPipelineId, "{MediaPipelineId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMediaInsightsPipelineConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipeline-configurations/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMediaPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-pipelines/{MediaPipelineId}");
    b.p("MediaPipelineId", () => input.MediaPipelineId, "{MediaPipelineId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMediaPipelineKinesisVideoStreamPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-pipeline-kinesis-video-stream-pools/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_GetMediaCapturePipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-capture-pipelines/{MediaPipelineId}");
    b.p("MediaPipelineId", () => input.MediaPipelineId, "{MediaPipelineId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMediaInsightsPipelineConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipeline-configurations/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMediaPipelineCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-pipelines/{MediaPipelineId}");
    b.p("MediaPipelineId", () => input.MediaPipelineId, "{MediaPipelineId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMediaPipelineKinesisVideoStreamPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-pipeline-kinesis-video-stream-pools/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetSpeakerSearchTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipelines/{Identifier}/speaker-search-tasks/{SpeakerSearchTaskId}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    b.p("SpeakerSearchTaskId", () => input.SpeakerSearchTaskId, "{SpeakerSearchTaskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetVoiceToneAnalysisTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipelines/{Identifier}/voice-tone-analysis-tasks/{VoiceToneAnalysisTaskId}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    b.p("VoiceToneAnalysisTaskId", () => input.VoiceToneAnalysisTaskId, "{VoiceToneAnalysisTaskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListMediaCapturePipelinesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-capture-pipelines");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMediaInsightsPipelineConfigurationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipeline-configurations");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMediaPipelineKinesisVideoStreamPoolsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-pipeline-kinesis-video-stream-pools");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMediaPipelinesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdk-media-pipelines");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags");
    const query = map({
        [_a]: [, __expectNonNull(input[_RARN], `ResourceARN`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_StartSpeakerSearchTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipelines/{Identifier}/speaker-search-tasks");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    const query = map({
        [_o]: [, "start"],
    });
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        KinesisVideoStreamSourceTaskConfiguration: (_) => _json(_),
        VoiceProfileDomainArn: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_StartVoiceToneAnalysisTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipelines/{Identifier}/voice-tone-analysis-tasks");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    const query = map({
        [_o]: [, "start"],
    });
    let body;
    body = JSON.stringify(take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        KinesisVideoStreamSourceTaskConfiguration: (_) => _json(_),
        LanguageCode: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_StopSpeakerSearchTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipelines/{Identifier}/speaker-search-tasks/{SpeakerSearchTaskId}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    b.p("SpeakerSearchTaskId", () => input.SpeakerSearchTaskId, "{SpeakerSearchTaskId}", false);
    const query = map({
        [_o]: [, "stop"],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_StopVoiceToneAnalysisTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/media-insights-pipelines/{Identifier}/voice-tone-analysis-tasks/{VoiceToneAnalysisTaskId}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    b.p("VoiceToneAnalysisTaskId", () => input.VoiceToneAnalysisTaskId, "{VoiceToneAnalysisTaskId}", false);
    const query = map({
        [_o]: [, "stop"],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags");
    const query = map({
        [_o]: [, "tag-resource"],
    });
    let body;
    body = JSON.stringify(take(input, {
        ResourceARN: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags");
    const query = map({
        [_o]: [, "untag-resource"],
    });
    let body;
    body = JSON.stringify(take(input, {
        ResourceARN: [],
        TagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateMediaInsightsPipelineConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipeline-configurations/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    body = JSON.stringify(take(input, {
        Elements: (_) => _json(_),
        RealTimeAlertConfiguration: (_) => _json(_),
        ResourceAccessRoleArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateMediaInsightsPipelineStatusCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-insights-pipeline-status/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    body = JSON.stringify(take(input, {
        UpdateStatus: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateMediaPipelineKinesisVideoStreamPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/media-pipeline-kinesis-video-stream-pools/{Identifier}");
    b.p("Identifier", () => input.Identifier, "{Identifier}", false);
    let body;
    body = JSON.stringify(take(input, {
        StreamConfiguration: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_CreateMediaCapturePipelineCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaCapturePipeline: (_) => de_MediaCapturePipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaConcatenationPipelineCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaConcatenationPipeline: (_) => de_MediaConcatenationPipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaInsightsPipelineCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaInsightsPipeline: (_) => de_MediaInsightsPipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaInsightsPipelineConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaInsightsPipelineConfiguration: (_) => de_MediaInsightsPipelineConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaLiveConnectorPipelineCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaLiveConnectorPipeline: (_) => de_MediaLiveConnectorPipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaPipelineKinesisVideoStreamPoolCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KinesisVideoStreamPoolConfiguration: (_) => de_KinesisVideoStreamPoolConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMediaStreamPipelineCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaStreamPipeline: (_) => de_MediaStreamPipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteMediaCapturePipelineCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteMediaInsightsPipelineConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteMediaPipelineCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteMediaPipelineKinesisVideoStreamPoolCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetMediaCapturePipelineCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaCapturePipeline: (_) => de_MediaCapturePipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMediaInsightsPipelineConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaInsightsPipelineConfiguration: (_) => de_MediaInsightsPipelineConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMediaPipelineCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaPipeline: (_) => de_MediaPipeline(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMediaPipelineKinesisVideoStreamPoolCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KinesisVideoStreamPoolConfiguration: (_) => de_KinesisVideoStreamPoolConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSpeakerSearchTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SpeakerSearchTask: (_) => de_SpeakerSearchTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetVoiceToneAnalysisTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VoiceToneAnalysisTask: (_) => de_VoiceToneAnalysisTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMediaCapturePipelinesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaCapturePipelines: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMediaInsightsPipelineConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaInsightsPipelineConfigurations: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMediaPipelineKinesisVideoStreamPoolsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KinesisVideoStreamPools: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMediaPipelinesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaPipelines: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartSpeakerSearchTaskCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SpeakerSearchTask: (_) => de_SpeakerSearchTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartVoiceToneAnalysisTaskCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        VoiceToneAnalysisTask: (_) => de_VoiceToneAnalysisTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopSpeakerSearchTaskCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_StopVoiceToneAnalysisTaskCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateMediaInsightsPipelineConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MediaInsightsPipelineConfiguration: (_) => de_MediaInsightsPipelineConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateMediaInsightsPipelineStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateMediaPipelineKinesisVideoStreamPoolCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KinesisVideoStreamPoolConfiguration: (_) => de_KinesisVideoStreamPoolConfiguration(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.chimesdkmediapipelines#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.chimesdkmediapipelines#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.chimesdkmediapipelines#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.chimesdkmediapipelines#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.chimesdkmediapipelines#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottledClientException":
        case "com.amazonaws.chimesdkmediapipelines#ThrottledClientException":
            throw await de_ThrottledClientExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.chimesdkmediapipelines#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.chimesdkmediapipelines#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.chimesdkmediapipelines#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottledClientExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottledClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
        RequestId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_FragmentSelector = (input, context) => {
    return take(input, {
        FragmentSelectorType: [],
        TimestampRange: (_) => se_TimestampRange(_, context),
    });
};
const se_KinesisVideoStreamRecordingSourceRuntimeConfiguration = (input, context) => {
    return take(input, {
        FragmentSelector: (_) => se_FragmentSelector(_, context),
        Streams: _json,
    });
};
const se_TimestampRange = (input, context) => {
    return take(input, {
        EndTimestamp: (_) => Math.round(_.getTime() / 1000),
        StartTimestamp: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_FragmentSelector = (output, context) => {
    return take(output, {
        FragmentSelectorType: __expectString,
        TimestampRange: (_) => de_TimestampRange(_, context),
    });
};
const de_KinesisVideoStreamPoolConfiguration = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        PoolArn: __expectString,
        PoolId: __expectString,
        PoolName: __expectString,
        PoolSize: __expectInt32,
        PoolStatus: __expectString,
        StreamConfiguration: _json,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_KinesisVideoStreamRecordingSourceRuntimeConfiguration = (output, context) => {
    return take(output, {
        FragmentSelector: (_) => de_FragmentSelector(_, context),
        Streams: _json,
    });
};
const de_MediaCapturePipeline = (output, context) => {
    return take(output, {
        ChimeSdkMeetingConfiguration: _json,
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        MediaPipelineArn: __expectString,
        MediaPipelineId: __expectString,
        SinkArn: __expectString,
        SinkType: __expectString,
        SourceArn: __expectString,
        SourceType: __expectString,
        Status: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_MediaConcatenationPipeline = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        MediaPipelineArn: __expectString,
        MediaPipelineId: __expectString,
        Sinks: _json,
        Sources: _json,
        Status: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_MediaInsightsPipeline = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        ElementStatuses: _json,
        KinesisVideoStreamRecordingSourceRuntimeConfiguration: (_) => de_KinesisVideoStreamRecordingSourceRuntimeConfiguration(_, context),
        KinesisVideoStreamSourceRuntimeConfiguration: _json,
        MediaInsightsPipelineConfigurationArn: __expectString,
        MediaInsightsRuntimeMetadata: _json,
        MediaPipelineArn: __expectString,
        MediaPipelineId: __expectString,
        S3RecordingSinkRuntimeConfiguration: _json,
        Status: __expectString,
    });
};
const de_MediaInsightsPipelineConfiguration = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        Elements: _json,
        MediaInsightsPipelineConfigurationArn: __expectString,
        MediaInsightsPipelineConfigurationId: __expectString,
        MediaInsightsPipelineConfigurationName: __expectString,
        RealTimeAlertConfiguration: _json,
        ResourceAccessRoleArn: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_MediaLiveConnectorPipeline = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        MediaPipelineArn: __expectString,
        MediaPipelineId: __expectString,
        Sinks: _json,
        Sources: _json,
        Status: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_MediaPipeline = (output, context) => {
    return take(output, {
        MediaCapturePipeline: (_) => de_MediaCapturePipeline(_, context),
        MediaConcatenationPipeline: (_) => de_MediaConcatenationPipeline(_, context),
        MediaInsightsPipeline: (_) => de_MediaInsightsPipeline(_, context),
        MediaLiveConnectorPipeline: (_) => de_MediaLiveConnectorPipeline(_, context),
        MediaStreamPipeline: (_) => de_MediaStreamPipeline(_, context),
    });
};
const de_MediaStreamPipeline = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        MediaPipelineArn: __expectString,
        MediaPipelineId: __expectString,
        Sinks: _json,
        Sources: _json,
        Status: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_SpeakerSearchTask = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        SpeakerSearchTaskId: __expectString,
        SpeakerSearchTaskStatus: __expectString,
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_TimestampRange = (output, context) => {
    return take(output, {
        EndTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        StartTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_VoiceToneAnalysisTask = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        UpdatedTimestamp: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        VoiceToneAnalysisTaskId: __expectString,
        VoiceToneAnalysisTaskStatus: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _MR = "MaxResults";
const _NT = "NextToken";
const _RARN = "ResourceARN";
const _a = "arn";
const _mr = "max-results";
const _nt = "next-token";
const _o = "operation";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
